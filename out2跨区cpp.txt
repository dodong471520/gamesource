I:\work\source\预言OL\yl code\code\Server\GameServer\worldkernel\YyCntSvrClientSink.cpp 4 KB CPP 文件 2010/1/6 16:09:02 2018/10/23 19:32:12 2018/10/23 19:32:12 2
46 	SafeCopy( msg.szReason , szReason , sizeof(msg.szReason) ) ;
47 	SafeCopy( msg.szGmRoleName , szGmRoleName , sizeof(msg.szGmRoleName) ) ;
49 	LOGMSG( "跨区封Ip, GmAccount %d , GmRole %d , Ip %d , 理由:%s" ,
50 				dwGmAccountId , dwGmRoleId , dwIp , szReason  ) ;
52 	for(int i = MSGPORT_MAPGROUP_FIRST; i < m_pMsgPort->GetSize(); i++)
72 	SafeCopy( msg.szGmRoleName , szGmRoleName , sizeof(msg.szGmRoleName) ) ;
73 	
74 	LOGMSG( "跨区封发机超, GmAccount %d , GmRole %d , amount %d , 理由:%s" ,
75 		dwGmAccountId , dwGmRoleId , dwMinTimeOutAmount, szReason  ) ;
76 	

I:\work\source\预言OL\yl code\code\Server\GameServer\mapgroupkernel\MapGroupKernel.cpp 44 KB CPP 文件 2010/1/6 16:09:04 2018/10/23 19:32:11 2018/10/23 19:32:11 3
931 		}
932 		break;
933 	case MAPGROUP_FORBID_IPROLE: // 跨区封IP上的用户 [Chancy 2008-9-12 17:02]
934 		{
935 			const ST_FORBID_IP *pForbidIpRole = ( const ST_FORBID_IP*)buf ;
942 				in_addr addr ;
943 				addr.S_un.S_addr = pForbidIpRole->dwIp ;
944 				SafeSprintf( szMsg , sizeof(szMsg) , "%s跨区封IP %s:%s" , 
945 						pForbidIpRole->szGmRoleName , 
946 						inet_ntoa( addr ) , 
961 			{
962 				MSGBUF szMsg = "" ;
963 				SafeSprintf( szMsg , sizeof(szMsg) , "%s跨区封发机超 %d:%s" , 
964 					pForbidIpRole->szGmRoleName , 
965 					pForbidIpRole->dwMinTimeOutAmount , 

I:\work\source\预言OL\[src.cool]预言OL\yuyancode\code\Server\GameServer\worldkernel\YyCntSvrClientSink.cpp 4 KB CPP 文件 2010/1/6 16:09:02 2018/10/23 19:32:56 2018/10/23 19:32:56 2
46 	SafeCopy( msg.szReason , szReason , sizeof(msg.szReason) ) ;
47 	SafeCopy( msg.szGmRoleName , szGmRoleName , sizeof(msg.szGmRoleName) ) ;
49 	LOGMSG( "跨区封Ip, GmAccount %d , GmRole %d , Ip %d , 理由:%s" ,
50 				dwGmAccountId , dwGmRoleId , dwIp , szReason  ) ;
52 	for(int i = MSGPORT_MAPGROUP_FIRST; i < m_pMsgPort->GetSize(); i++)
72 	SafeCopy( msg.szGmRoleName , szGmRoleName , sizeof(msg.szGmRoleName) ) ;
73 	
74 	LOGMSG( "跨区封发机超, GmAccount %d , GmRole %d , amount %d , 理由:%s" ,
75 		dwGmAccountId , dwGmRoleId , dwMinTimeOutAmount, szReason  ) ;
76 	

I:\work\source\预言OL\[src.cool]预言OL\yuyancode\code\Server\GameServer\mapgroupkernel\MapGroupKernel.cpp 44 KB CPP 文件 2010/1/6 16:09:04 2018/10/23 19:32:51 2018/10/23 19:32:51 3
931 		}
932 		break;
933 	case MAPGROUP_FORBID_IPROLE: // 跨区封IP上的用户 [Chancy 2008-9-12 17:02]
934 		{
935 			const ST_FORBID_IP *pForbidIpRole = ( const ST_FORBID_IP*)buf ;
942 				in_addr addr ;
943 				addr.S_un.S_addr = pForbidIpRole->dwIp ;
944 				SafeSprintf( szMsg , sizeof(szMsg) , "%s跨区封IP %s:%s" , 
945 						pForbidIpRole->szGmRoleName , 
946 						inet_ntoa( addr ) , 
961 			{
962 				MSGBUF szMsg = "" ;
963 				SafeSprintf( szMsg , sizeof(szMsg) , "%s跨区封发机超 %d:%s" , 
964 					pForbidIpRole->szGmRoleName , 
965 					pForbidIpRole->dwMinTimeOutAmount , 

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\TeachService\ResAdjustService.cpp 18 KB CPP 文件 2014/2/25 0:24:34 2018/10/23 20:09:14 2018/10/23 20:09:14 1
169 }
171 /**
172 @name         : 处理其他服务器通过跨区桥服务器转发的消息
173 @param actionId  : 消息码
174 @param bridgeHead  : 桥消息头

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\SocialServer\VoiceService.cpp 86 KB CPP 文件 2014/2/25 0:24:18 2018/10/23 20:09:13 2018/10/23 20:09:13 2
476 			}
477 			break;
479 		case MSG_VOICE_BRIDGEDATA:		// 发送消息到其他服务器，可跨区
480 			{
481 				OnMsgZoneBridgeData( actionId, head, data, len );
529 		}
530 		break;
532 	case MSG_VOICE_BRIDGEDATA:	// 发送消息到其他服务器，可跨区
533 		{
534 			OnVoiceBridgeData( actionId, voiceHead, head, data, len );

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\SocialServer\SchemeZoneMatron.cpp 7 KB CPP 文件 2014/2/25 0:24:13 2018/10/23 20:09:12 2018/10/23 20:09:12 1
201 		// 禁止双人坐骑进入
202 		schemeInfo.bForbidBWM = pCSVReader->GetBool(i, 17, 0);
204 		// 不允许跨区传送
205 		schemeInfo.bForbidStarTrek = pCSVReader->GetBool(i, 18, 0);
207 		// 标志位

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\SocialServer\GlobalSocialServer.cpp 64 KB CPP 文件 2014/2/25 0:23:56 2018/10/23 20:09:11 2018/10/23 20:09:11 22
166 	}
167 }
170 /// 启动跨区桥服务器连接器
171 void GlobalSocialServer::CreateBridgeConnector(void)
172 {
171 void GlobalSocialServer::CreateBridgeConnector(void)
172 {
173 	// 加载跨区桥服务器连接器设定
174 	Ini ini("Bridge.ini");
175 	std::string strBridgeServerIP = ini.getString("Setting","BridgeServerIP","127.0.0.1");
189 	if (nOpenBridge!=1)
190 	{
191 		WarningLn("跨区桥服务器连接禁用!");
192 		return;
193 	}
192 		return;
193 	}
194 	// 跨区桥服务器连接器连接
195 	TraceLn("连接跨区桥服务器:游戏世界ID="<<dwGameWorldID<<":"<<strWorldName.c_str()<<","<<strBridgeServerIP.c_str()<<":"<<nBridgeServerPort);
196 	if(!m_BridgeConnector->Connect(strBridgeServerIP.data(),nBridgeServerPort))
197 	{
196 	if(!m_BridgeConnector->Connect(strBridgeServerIP.data(),nBridgeServerPort))
197 	{
198 		TraceLn("连接跨区桥服务器失败!");
199 		return;
200 	}
199 		return;
200 	}
201 	//TraceLn("连接跨区桥服务器成功!");
203 	// 全部游戏世界加入事件
204 	m_BridgeConnector->registerEventHandler(EVENT_BRIDGE_WORLDLIST_ALL,static_cast<IBridgeEventHandler *>(this));
208 	m_BridgeConnector->registerEventHandler(EVENT_BRIDGE_WORLDLIST_EDIT,static_cast<IBridgeEventHandler *>(this));
209 }
210 /// 关闭跨区桥服务器连接器
211 void GlobalSocialServer::ReleaseBridgeConnector(void)
212 {
219 		// 修改游戏世界事件
220 		m_BridgeConnector->unregisterEventHandler(EVENT_BRIDGE_WORLDLIST_EDIT,static_cast<IBridgeEventHandler *>(this));
222 		// 关闭跨区桥服务器连接器
223 		TraceLn("关闭跨区桥服务器连接器!");
224 		m_BridgeConnector->Release();
225 		m_BridgeConnector = NULL;
384 	}
385 }
388 ////////// IBridgeEventHandler 处理处理跨区桥服务器执行事件 //////////////////
389 /** 
390 @param   wEventID ：事件ID
399 		return;
400 	}
401 	// 取得跨区桥服务器连接器接口
402 	if (NULL==m_BridgeConnector)
403 	{
437 	default:
438 		{
439 			ErrorLn("社会服务器尚有一个跨区桥服务器执行事件订阅了但未处理，wEventID = "<<wEventID);
440 		}
441 		break;
1159 			vanServerIP = DEFAULT_IP_ADDRESS;
1160 		int vanServerPort = ini.getInt("Network", "vanport", 8990);	
1162 		// 连接器连接跨区桥服务器
1163 		CREATE_BEGIN("CreateBridgeConnector......");
1164 		bool bBridgeConnectorOK = false;
1165 		if (NULL==m_BridgeConnector && NULL != m_ManagerConnector && m_ManagerConnector->GetWorldID()!=0)
1166 		{
1167 			// 启动跨区桥服务器连接器
1168 			CreateBridgeConnector();
1169 			if (NULL != m_BridgeConnector)
1526 		if ( NULL==m_pVoiceConnector && NULL != m_ManagerConnector && m_ManagerConnector->GetWorldID()!=0 )
1527 		{
1528 			// 启动跨区桥服务器连接器
1529 			CreateVoiceConnector();
1530 			if (NULL != m_pVoiceConnector)
1812 		/// 关闭语音服连接器
1813 		ReleaseVoiceConnector();
1815 		/// 关闭跨区桥服务器连接器
1816 		ReleaseBridgeConnector();
1818 		// 关闭管理连接器
1975 			dbParam.nOnlineAvgNum		= 0;					// 本区一分钟内平均在线人数
1976 			dbParam.nOnlineMinNum		= MAX_INT_VALUE;		// 本区一分钟内最小在线人数
1977 			dbParam.nOnlineAreaMaxNum	= 0;					// 跨区一分钟内最高在线人数 
1978 			dbParam.nOnlineAreaAvgNum	= 0;					// 跨区一分钟内平均在线人数 
1979 			dbParam.nOnlineAreaMinNum	= MAX_INT_VALUE;		// 跨区一分钟内最小在线人数
1981 			// 计算数据
1982 			DWORD dwRecCounts			= 0;			// 记录数
1982 			DWORD dwRecCounts			= 0;			// 记录数
1983 			double fTotalOnline			= 0.0;			// 本区在线人数汇总
1984 			double fTotalAreaOnline		= 0.0;			// 跨区在线人数汇总
1985 			for (TLIST_OnlineUserCountsInfo::iterator it=m_OnlineUserInfoList.begin();it!=m_OnlineUserInfoList.end();it++)
1986 			{
2012 			{
2013 				dbParam.nOnlineAvgNum		= (int)(fTotalOnline/(double)dwRecCounts);					// 本区一分钟内平均在线人数
2014 				dbParam.nOnlineAreaAvgNum	= (int)(fTotalAreaOnline/(double)dwRecCounts);				// 跨区一分钟内平均在线人数 
2015 			}
2017 			// 调整一下,最小无效情况

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\MiscService\BattleRideCampService.cpp 71 KB CPP 文件 2014/2/25 0:23:19 2018/10/23 20:09:05 2018/10/23 20:09:05 3
95 	if (pBridgeConnector != NULL)
96 	{
97 		// 订阅  跨区桥服务器连接器 MSG_MODULEID_BATTLERIDE_CAMP 消息
98 		pBridgeConnector->registerMessageHandler(MSG_MODULEID_BATTLERIDE_CAMP,this);
100 		pBridgeConnector->registerEventHandler(EVENT_BRIDGE_SERVERLIST_ADD, static_cast<IBridgeEventHandler*>(this));
152 	if (pBridgeConnector != NULL)
153 	{
154 		// 订阅  跨区桥服务器连接器 MSG_MODULEID_BATTLERIDE_CAMP 消息
155 		pBridgeConnector->unregisterMessageHandler(MSG_MODULEID_BATTLERIDE_CAMP);
157 		// 取消桥服务器事件订阅
654 }
656 /**
657 @name         : 处理其他服务器通过跨区桥服务器转发的消息
658 @param actionId  : 消息码
659 @param bridgeHead  : 桥消息头

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\MatchService\WarService.cpp 152 KB CPP 文件 2014/2/25 0:23:13 2018/10/23 20:09:05 2018/10/23 20:09:05 27
5 ** 日  期:	2011-03-19
6 ** 版  本:	1.0
7 ** 描  述:	跨区战场系统
8 ** 应  用:  	
9 	
49 }
51 /**
52 @name   : 创建跨区战场系统
53 */
54 bool CWarService::Create()
83 }
85 /**
86 @name   : 关闭跨区战场系统
87 */
88 void CWarService::Release()
731 	}
733 	// 所有的客户端更新Trackter信息
734 	// 遍历所有玩家 找出和发起者国家ID 相同 要求等级达到条件的玩家 通知其进入跨区国战战场
735 	UserInfo* pUserInfo = pUserManager->findFirstUser();
736 	while (pUserInfo != NULL)
836 		return;
837 	}
838 	// 取得跨区桥服务器连接器接口
839 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
840 	if (NULL == pBridgeConnector)
957 			if (dwSendServerID>0)
958 			{
959 				// 本区发送已存国战信息给公共区社会服消息 dwServerID:服务器ID ,跨区信息专用
960 				g_pMatchService->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_ExistCountryWarData,node.warInfo.dwID, dwClashCampID);
961 			}
1028 {
1029 	bool bAltered = false;
1031 	// 取得跨区桥服务器连接器接口
1032 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
1033 	if (NULL == pBridgeConnector)
1052 void CWarService::OnBridgeMsgExistCountryWarData(DWORD dwWarID, DWORD dwClashCampID)
1053 {
1054 	// 取得跨区桥服务器连接器接口
1055 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
1056 	if (NULL == pBridgeConnector)
1444 	default:
1445 		{
1446 			ErrorLn("跨区战场系统有一个子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
1447 		}
1448 		break;
1449 	}
1450 }
1452 //  处理跨区桥服务器发过来的消息
1453 void CWarService::HandleBridgeMessage(unsigned long actionId, SMsgBridgeHead &bridgeHead, SGameMsgHead* head, LPSTR data, size_t len)
1454 {
1618 		}
1619 		break;
1620 	case Match_WarMsg_RequestCountryInfo:		// 请求更新跨区共享国家信息
1621 		{
1622 			if (nNewlen>0)
1786 					sendData.dwPlayerID		= pOfficerInfo->dwPlayerID;			// 国王角色ID
1787 					sstrcpyn( sendData.szName, pOfficerInfo->szPlayerName, sizeof(sendData.szName));	// 玩家角色名称,由 玩家ID：dwPlayerID 关联取得
1789 					// 发跨区信息消息 dwServerID:服务器ID ,跨区信息专用
1790 					g_pMatchService->SendDataBridgeToServer(bridgeHead.dwServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_RequestKingInfo,dwWarID,0,0,(const char *)&sendData,sizeof(sendData));
1792 					break;
1889 	default:
1890 		{
1891 			ErrorLn("跨区战场系统有一个桥服务器发过来的子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
1892 		}
1893 		break;
1909 	//		if (dwSendServerID>0)
1910 	//		{
1911 	//			// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
1912 	//			return g_pMatchService->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_RequestNewCountryWar,node.dwType,0,0,(const char *)&node,sizeof(node));
1913 	//		}
2535 		sendData.dwCountryID		= dwCountryID;				// 目标国家ID
2536 		sendData.dwFlag				= dwFlag;					// 操作标识
2538 		//  请求检查跨服国战对方是否本区有国战 dwServerID:服务器ID ,跨区信息专用
2539 		g_pMatchService->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_RequestCheckCountryWar,0,0,0,(const char *)&sendData,sizeof(sendData));
2540 	}
2607 	if (dwSendServerID>0)
2608 	{
2609 		//  请求检查跨服国战对方是否本区有国战结果 dwServerID:服务器ID ,跨区信息专用
2610 		g_pMatchService->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_CheckCountryWarResult,dwResultFlag,0,0,(const char *)&node,sizeof(node));
2611 	}
2633 			if (dwSendServerID>0)
2634 			{
2635 				// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
2636 				g_pMatchService->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_RequestAddCountryWar,0,0,0,(const char *)&node,sizeof(node));
2637 			}
2643 	}
2644 }
2648 /*/ 跨区国战召集 功能
2649 @param	unsigned long actionId		: 消息ID
2650 @param	SMsgBridgeHead &bridgeHead	: 桥消息的消息头
2666 	}
2668 	SMsgMatchRequestRequestKqWarCall_SS * pMsg = (SMsgMatchRequestRequestKqWarCall_SS *)(data);
2670 	// 遍历所有玩家 找出和发起者国家ID 相同 要求等级达到条件的玩家 通知其进入跨区国战战场
2671 	UserInfo* pUserInfo = pUserManager->findFirstUser();
2672 	while (pUserInfo != NULL)
2706 		return false;
2707 	}
2709 	// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
2710 	return g_pMatchService->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_RequestAddCountryWarResult,dwWorldID,dwCountryID,dwFlag);
2711 }
3195 			if (dwSendServerID>0)
3196 			{
3197 				// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
3198 				return g_pMatchService->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_RequestAddClanBossWar,0,0,0,data,len);
3199 			}
3984 	}
3986 	//////////////////////////////////////////////////////////////////////////
3987 	// 按算法重连所有跨区国家连接
3989 	// 要连接的战场配置项定义
3990 	static DWORD dwMatchLinkTypeList[1] =

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\MatchService\StrikeService.cpp 39 KB CPP 文件 2014/2/25 0:23:12 2018/10/23 20:09:05 2018/10/23 20:09:05 8
5 ** 日  期:	2010-10-29
6 ** 版  本:	1.0
7 ** 描  述:	跨区竞技系统
8 ** 应  用:  	
9 	
32 }
34 /**
35 @name   : 创建跨区竞技系统
36 */
37 bool CStrikeService::Create()
47 }
49 /**
50 @name   : 关闭跨区竞技系统
51 */
52 void CStrikeService::Release()
364 			continue;
365 		}
366 		// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
367 		g_pMatchService->SendDataBridgeToServer(dwServerArray[i],MSG_MATCH_DATE_PKMSG,Match_PKMsg_UpdatePubIdleRate,dwStrikeServerIdleRate,0,0);
368 	}
1097 	default:
1098 		{
1099 			ErrorLn("跨区竞技系统有一个子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
1100 		}
1101 		break;
1102 	}
1103 }
1105 //  处理跨区桥服务器发过来的消息
1106 void CStrikeService::HandleBridgeMessage(unsigned long actionId, SMsgBridgeHead &bridgeHead, SGameMsgHead* head, LPSTR data, size_t len)
1107 {
1149 	default:
1150 		{
1151 			ErrorLn("跨区竞技系统有一个桥服务器发过来的子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
1152 		}
1153 		break;

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\MatchService\StrikeMatch.cpp 73 KB CPP 文件 2014/2/25 0:23:11 2018/10/23 20:09:04 2018/10/23 20:09:04 5
575 	}
577 }
579 //  处理跨区桥服务器发过来的消息
580 void CStrikeMatch::HandleBridgeMessage(unsigned long actionId, SMsgBridgeHead &bridgeHead, SGameMsgHead* head, LPSTR data, size_t len)
581 {
912 		if (iter==m_mapMatchRequest.end())
913 		{
914 			// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
915 			g_pMatchService->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_CSMSG,Match_CSMsg_RequestCheckCancelMatch,dwActorID,dwWorldID,1);
916 		}
1026 				if (dwSendServerID>0)
1027 				{
1028 					// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
1029 					return g_pMatchService->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_CSMSG,Match_CSMsg_RequestAddMatch,dwMatchTypeID,0,0,data,len);
1030 				}

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\MatchService\MatchService.cpp 284 KB CPP 文件 2014/2/25 0:23:04 2018/10/23 20:09:04 2018/10/23 20:09:04 50
176 		return false;
177 	}
179 	// 创建跨区副本保姆
180 	if (m_EctypeAssist.Create() == false)
181 	{
188 		return false;
189 	}
190 	// 创建跨区竞技系统
191 	if (m_StrikeService.Create() == false)
192 	{
193 		return false;
194 	}
195 	// 跨区战场系统
196 	if (m_WarService.Create() == false)
197 	{
213 		return false;
214 	}
216 	// 订阅  跨区桥服务器连接器 MSG_MODULEID_MATCH 消息
217 	pBridgeConnector->registerMessageHandler(MSG_MODULEID_MATCH,static_cast<IBridgeMessageHandler*>(this));
218 	pBridgeConnector->registerEventHandler(EVENT_BRIDGE_SERVERLIST_ADD, static_cast<IBridgeEventHandler*>(this));
259 void CMatchService::Release()
260 {
262 	// 取消订阅 取得跨区桥服务器连接器MSG_MODULEID_MATCH消息
263 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
264 	if (pBridgeConnector != NULL)
315 	// 关闭挑战系统
316 	m_DummyService.Release();
317 	// 关闭跨区战场系统
318 	m_WarService.Release();
318 	m_WarService.Release();
319 	// 关闭跨区竞技系统
320 	m_StrikeService.Release();
321 	// 关闭跨服竞技撮合系统
321 	// 关闭跨服竞技撮合系统
322 	m_StrikeMatch.Release();
323 	// 关闭跨区副本保姆
324 	m_EctypeAssist.Close();
327 	delete this;
2680 	return bIsOpen;
2681 }
2683 /** 取得跨区副本接口
2684 */
2685 IEctypeAssist* CMatchService::GetEctypeAssist()
2694 	return &m_StrikeMatch;
2695 }
2697 /** 取得跨区竞技系统接口
2698 */
2699 IStrikeService* CMatchService::GetStrikeService()
2701 	return &m_StrikeService;
2702 }
2704 /** 取得跨区战场系统接口
2705 */
2706 IWarService* CMatchService::GetWarService()
2721 }
2723 //////////////////////////////////////////////////////////////////////////
2724 // 取得跨区副本
2725 CEctypeAssist& CMatchService::GetEctypeAssistInstance()
2726 {
2732 	return m_StrikeMatch;
2733 }
2734 // 取得跨区竞技系统
2735 CStrikeService& CMatchService::GetStrikeServiceInstance()
2736 {
2737 	return m_StrikeService;
2738 }
2739 // 取得跨区战争系统
2740 CWarService& CMatchService::GetWarServiceInstance()
2741 {
2794 		return;
2795 	}
2796 	// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
2797 	g_pMatchService->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_SUBMSG,Match_SubMsg_WorldOnlineUserAdd,info.id,info.worldId,(DWORD)nMode);
2800 }
2829 		return;
2830 	}
2831 	// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
2832 	g_pMatchService->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_SUBMSG,Match_SubMsg_WorldOnlineUserRemove,info.id,info.worldId,(DWORD)nMode);
2833 }
2840 }
2842 //////////////////////////////////////////////////////////////////////////
2844 // 发跨区信息消息 dwServerID:服务器ID ,跨区信息专用
2845 bool CMatchService::SendDataBridgeToServer(DWORD dwServerID,WORD wKeyAction,DWORD dwMsgCode,DWORD dwUserData1,DWORD dwUserData2,DWORD dwUserData3,const char * pData,DWORD dwLen)
2846 {
3024 					OnMsgMatchSubMsg(header.DestEndPoint,wKeyAction,&header,obufData.data(),obufData.size());
3025 				}
3026 				else if (MSG_MATCH_KQE==wKeyAction)			// 跨区副本保姆子消息
3027 				{
3028 					m_EctypeAssist.OnMessage(header.DestEndPoint,wKeyAction,&header,obufData.data(),obufData.size());
3074 		header.DestEndPoint= MSG_ENDPOINT_BRIDGE;
3075 		header.wKeyModule  = MSG_MODULEID_MATCH;
3076 		header.wKeyAction  = MSG_MATCH_BRIDGE_DATA;			// 跨区中转消息
3078 		DWORD nDataLens = sizeof(SMsgMatchDataSubMsg)+dwLen;
3080 		SMsgMatchBridgeData headData;
3497 				if (pUserInfo->worldId==dwSendInfWorldID)
3498 				{
3499 					// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
3500 					g_pMatchService->SendDataBridgeToServer(pData->dwID,MSG_MATCH_DATE_SUBMSG,Match_SubMsg_WorldOnlineUserAdd,pUserInfo->id,pUserInfo->worldId,loginXlogout_Mode_Offline);
3501 				}
3563 }
3566 //////////////////IBridgeMessageHandler////////////////////////////////////////////////////////
3568 /** 处理跨区桥服务器发过来的消息
3569 @name         : 处理其他服务器通过跨区桥服务器转发的消息
3570 @param actionId  : 消息码
3571 @param bridgeHead  : 桥消息头
3583 		}
3584 		break;
3585 	case MSG_MATCH_KQE:	// 跨区副本保姆子消息
3586 		{
3587 			m_EctypeAssist.HandleBridgeMessage(actionId,bridgeHead, head, data, len);
3588 		}
3589 		break;
3590 	case MSG_MATCH_BRIDGE_DATA: // 跨区中转消息
3591 		{
3592 			OnBridgeMsgMatchBridgeData(actionId,bridgeHead, head, data, len);
3643 		}
3644 		break;
3645 	case MSG_MATCH_KQE:		// 跨区副本保姆子消息
3646 		{
3647 			m_EctypeAssist.OnMessage(endpointId,actionId,head,data,len);
3976 				break;
3977 			}
3978 			// 跨区撮合,不是跨区不处理 ,|| bridgeHead.dwWorldID!=pRequestHead->dwWorldID
3979 			if (MatchTypeID_PublicFuBen!=pMsg->dwUserData1 )
3980 			{
4000 				break;
4001 			}
4002 			// 跨区撮合,不是跨区不处理 ,|| bridgeHead.dwWorldID!=pRequestHead->dwWorldID
4003 			if (MatchTypeID_PublicFuBen!=pMsg->dwUserData1 )
4004 			{
4053 		}
4054 		break;
4055 	case Match_SubMsg_RequestLookWorldEquip:		// 请求跨区查看玩家装备
4056 		{
4057 			if (nNewlen!=sizeof(SMsgActionWorldLookEquip_SC))
4061 			DWORD dwActorID		= pMsg->dwUserData1;				// 要查看装备角色ID
4062 			DWORD dwWorldID		= pMsg->dwUserData2;				// 信息来源游戏世界ID
4064 			// 请求跨区查看玩家装备
4065 			RequestLookWorldEquip(dwActorID,dwWorldID,bridgeHead.dwServerID,pMsgData,nNewlen);
4066 		}
4081 		}
4082 		break;
4083 	case Match_SubMsg_WorldOnlineUserAdd:		//  跨区用户上线
4084 		{
4085 			if (nNewlen>0)
4090 			DWORD dwWorldID			= pMsg->dwUserData2;				// 游戏世界ID
4091 			DWORD dwUserData		= pMsg->dwUserData3;				// 数据
4093 			// 跨区用户上线
4094 			OnMsgWorldOnlineUserAdd(dwActorID,dwWorldID,dwUserData);
4095 		}
4095 		}
4096 		break;
4097 	case Match_SubMsg_WorldOnlineUserRemove:		//  跨区用户下线
4098 		{
4099 			if (nNewlen>0)
4104 			DWORD dwWorldID			= pMsg->dwUserData2;				// 游戏世界ID
4105 			DWORD dwUserData		= pMsg->dwUserData3;				// 数据
4107 			// 跨区用户上线
4108 			OnMsgWorldOnlineUserRemove(dwActorID,dwWorldID,dwUserData);
4109 		}
4151 	}	
4152 }
4155 // 跨服 跨区中转消息
4156 void CMatchService::OnBridgeMsgMatchBridgeData(unsigned long actionId, SMsgBridgeHead &bridgeHead, SGameMsgHead* head, LPSTR data, size_t len)
4157 {
4167 	// 调式代码
4168 	char szBuf[512]={0};
4169 	sprintf_s(szBuf, _countof(szBuf),_NGT"CMatchService::OnBridgeMsgMatchBridgeData()  跨服  跨区中转消息:目标端点码=%d,角色来自游戏世界ID=%d,角色ID=%d,行为消息码=%d,数据长度=%d",
4170 		pMsg->nDestEndPoint,pMsg->dwFromWorldID,pMsg->dwActorID,pMsg->wKeyAction,pMsg->nDataLens);
4171 	TraceLn(szBuf);
4177 	if (nNewlen!=pMsg->nDataLens)
4178 	{
4179 		ErrorLn(" 跨区中转消息信息数据与大小不符，nDataLens="<<pMsg->nDataLens<<" ,nLen = "<<nNewlen);
4180 		return;
4181 	}
4183 	if (nNewlen<sizeof(SMsgMatchDataSubMsg))
4184 	{
4185 		ErrorLn(" 跨区中转消息信息数据与大小不符，nDataLens="<<pMsg->nDataLens<<" ,nLen = "<<nNewlen);
4186 		return;
4187 	}
4237 				OnMsgMatchSubMsg(header.DestEndPoint,pMsg->wKeyAction,&header,pMsgData,nNewlen);
4238 			}
4239 			else if (MSG_MATCH_KQE==pMsg->wKeyAction)			// 跨区副本保姆子消息
4240 			{
4241 				m_EctypeAssist.OnMessage(header.DestEndPoint,pMsg->wKeyAction,&header,pMsgData,nNewlen);
4250 }
4251 //////////////////////////////////////////////////////////////////////////
4252 // 跨区用户上线
4253 void CMatchService::OnMsgWorldOnlineUserAdd(DWORD dwActorID,DWORD dwWorldID,DWORD dwUserData)
4254 {
4277 	// 调式代码
4278 	char szBuf[512]={0};
4279 	sprintf_s(szBuf, _countof(szBuf),_NGT"CMatchService::OnMsgWorldOnlineUserAdd() 跨区用户上线:角色来自游戏世界ID=%d,角色ID=%d,上线类型=%d",
4280 		dwWorldID,dwActorID,dwUserData);
4281 	TraceLn(szBuf);
4282 #endif
4284 }
4285 // 跨区用户下线
4286 void CMatchService::OnMsgWorldOnlineUserRemove(DWORD dwActorID,DWORD dwWorldID,DWORD dwUserData)
4287 {
4305 	// 调式代码
4306 	char szBuf[512]={0};
4307 	sprintf_s(szBuf, _countof(szBuf),_NGT"CMatchService::OnMsgWorldOnlineUserRemove() 跨区用户下线:角色来自游戏世界ID=%d,角色ID=%d,下线类型=%d",
4308 		dwWorldID,dwActorID,dwUserData);
4309 	TraceLn(szBuf);
5466 	return true;
5467 }
5470 // 请求跨区查看玩家装备
5471 bool CMatchService::RequestLookWorldEquip(DWORD dwActorID,DWORD dwWorldID,DWORD dwFromServerID,const char * pData,DWORD dwLen)
5472 {
5475 		return false;
5476 	}
5477 	// 跨区查看玩家装备
5478 	SMsgActionWorldLookEquip_SC *pMsg = (SMsgActionWorldLookEquip_SC *)pData;
5480 	// 查找用户

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\MatchService\ExternalFacade.cpp 34 KB CPP 文件 2014/2/25 0:23:02 2018/10/23 20:09:03 2018/10/23 20:09:03 2
1231 		}
1232 	}
1234 	// 公共区取跨区国家名称
1235 	if (bLocal)
1236 	{
1253 	else
1254 	{
1255 		// 取得跨区桥服务器连接器接口
1256 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
1257 		if (NULL != pBridgeConnector)

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\MatchService\EctypeAssist.cpp 22 KB CPP 文件 2014/2/25 0:23:01 2018/10/23 20:09:03 2018/10/23 20:09:03 16
5 ** 日  期:	2010/07/14
6 ** 版  本:	1.0
7 ** 描  述:	跨区副本助手
8 ** 应  用:  
9 ********************************************************************/
26 }
28 /**
29 @name   : 创建跨区副本保姆
30 */
31 bool CEctypeAssist::Create()
39 }
41 /**
42 @name   : 关闭跨区副本保姆
43 */
44 void CEctypeAssist::Close()
243 	return emCreateKqe_ok;
244 }
246 /** 取得跨区副本信息
247 */
248 const SKqEctypeScheme* CEctypeAssist::GetKqEctypeScheme(WORD wTypeID)
256 	return &(it->second);
257 }
259 /** 取得跨区副本配置信息
260 */
261 const SKqEctypeConfig* CEctypeAssist::GetKqEctypeConfig()
361 		default:
362 			{
363 				ErrorLn("跨区副本保姆有一个服务器撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
364 			}
365 			break;
367 	}
368 }
370 /** 解析跨区桥服务器来的消息，子消息码为MSG_MATCH_GLOBALECTYPE
371 */
372 void CEctypeAssist::HandleBridgeMessage(unsigned long actionId, SMsgBridgeHead &bridgeHead, SGameMsgHead* head, LPSTR data, size_t len)
382 	// 调式代码
383 	char szBuf[512]={0};
384 	sprintf_s(szBuf, _countof(szBuf),_NGT"CEctypeAssist::HandleBridgeMessage()  解析跨区桥服务器来的消息:来源游戏世界ID=%d,来源服务器ID=%d,子消息代码=%d,len=%d,用户数据=%d,%d,%d",
385 		bridgeHead.dwWorldID,bridgeHead.dwServerID,pMsg->dwMsgCode,len,pMsg->dwUserData1,pMsg->dwUserData2,pMsg->dwUserData3);
386 	TraceLn(szBuf);
416 	default:
417 		{
418 			ErrorLn("跨区副本保姆有一个跨服撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
419 		}
420 		break;
432 		return false;
433 	}
435 	// 跨区副本配置脚本
436 	string strPath;
437 	if (isPublicGameWorld() == true)
453 	return true;
454 }
456 /// purpose:  加载跨区副本配置脚本
457 bool CEctypeAssist::LoadKqEctypeScheme(ICSVReader * pCSVReader)
458 {
485 		if (nCount != 2)
486 		{
487 			ErrorLn("跨区副本配置脚本" << "限制开始时间 配置错误");
488 			return false;
489 		}
500 		if (nCount != 2)
501 		{
502 			ErrorLn("跨区副本配置脚本" << "限制结束时间 配置错误");
503 			return false;
504 		}
708 	pTeam->DoLeave(dwPDBID);
709 }
711 /** 创建一个跨区副本
712 */
713 void CEctypeAssist::OnBridgePersonZone(SMsgBridgeHead &bridgeHead, SMsgMatchDataSubMsg* pSubMsg, LPSTR pszMsg, size_t nLen)
755 				if (pCall->bDeleteOffLine == true)
756 				{
757 					// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
758 					g_pMatchService->SendDataBridgeToServer(dwSrcBriServerID, MSG_MATCH_KQE, MSG_KQE_CALL_CANCEL, pTransMsg->dwPDBID, pCall->dwSerialID, 1, NULL, 0);
759 				}

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\MatchService\DummyService.cpp 45 KB CPP 文件 2014/2/25 0:22:57 2018/10/23 20:09:03 2018/10/23 20:09:03 4
40 }
42 /**
43 @name   : 创建跨区竞技系统
44 */
45 bool CDummyService::Create()
50 }
52 /**
53 @name   : 关闭跨区竞技系统
54 */
55 void CDummyService::Release()
1336 }
1338 //////////////////////////////////////////////////////////////////////////
1339 //  处理跨区桥服务器发过来的消息
1340 void CDummyService::HandleBridgeMessage(unsigned long actionId, SMsgBridgeHead &bridgeHead, SGameMsgHead* head, LPSTR data, size_t len)
1341 {
1366 	default:
1367 		{
1368 			ErrorLn("跨区竞技系统有一个桥服务器发过来的子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
1369 		}
1370 		break;

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\MatchService\BudoService.cpp 87 KB CPP 文件 2014/2/25 0:22:54 2018/10/23 20:09:03 2018/10/23 20:09:03 4
68 }
70 /**
71 @name   : 创建跨区竞技系统
72 */
73 bool CBudoService::Create()
76 }
78 /**
79 @name   : 关闭跨区竞技系统
80 */
81 void CBudoService::Release()
1626 }
1628 //////////////////////////////////////////////////////////////////////////
1629 //  处理跨区桥服务器发过来的消息
1630 void CBudoService::HandleBridgeMessage(unsigned long actionId, SMsgBridgeHead &bridgeHead, SGameMsgHead* head, LPSTR data, size_t len)
1631 {
1656 	default:
1657 		{
1658 			ErrorLn("跨区竞技系统有一个桥服务器发过来的子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
1659 		}
1660 		break;

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\LuaService\LuaAPI.cpp 97 KB CPP 文件 2014/2/25 0:22:39 2018/10/23 20:09:00 2018/10/23 20:09:00 5
1526 }
1528 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
1529 /**************************************  跨区相关 ***********************************************************/
1530 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
1531 /** 是否是公共区
2233 		return false;
2234 	}
2235 	// 取得跨区战场系统接口
2236 	IWarService* pWarService = pMatchService->GetWarService();
2237 	if (NULL==pWarService)
2293 		return false;
2294 	}
2295 	// 取得跨区战场系统接口
2296 	IWarService * pWarService = pMatchService->GetWarService();
2297 	if(pWarService==NULL)
2346 		return false;
2347 	}
2348 	// 取得跨区战场系统接口
2349 	IWarService * pWarService = pMatchService->GetWarService();
2350 	if(pWarService==NULL)
2396 		return false;
2397 	}
2398 	// 取得跨区战场系统接口
2399 	IWarService * pWarService = pMatchService->GetWarService();
2400 	if(pWarService==NULL)

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\KinService\KinService.cpp 141 KB CPP 文件 2014/2/25 0:22:19 2018/10/23 20:08:58 2018/10/23 20:08:58 5
1469 		if (pEvent->dwWorldID == pBridgeConnector->GetPublicWorldID() && pEvent->wServerType == MSG_ENDPOINT_SOCIAL)
1470 		{
1471 			// TraceLn("[跨区家族] 公共区连接桥服务器：dwWorldID=" << pEvent->dwWorldID);
1473 			// 把本地的所有家族信息都发给公共区
1474 			TMap_Kin::iterator it;
1477 				CKin* pKin = it->second;
1478 				
1479 				// TraceLn("[跨区家族] 向公共区同步家族信息：kinID=" << pKin->GetNumProp(emKinProp_ID));
1481 				pKin->SynchToPublicServer();
1482 			}
1484 	}
1485 }
1487 /// purpose: 处理其他服务器通过跨区桥服务器转发的消息
1488 //@ param: actionId 消息码
1489 //@ param: bridgeHead 桥消息头
2794 	// 把数据同步到公共区
2795 	pKin->SynchToPublicServer();
2797 	// TraceLn("[跨区家族] 向公共区同步家族信息：kinID=" << pKin->GetNumProp(emKinProp_ID));
2798 }
2800 /// purpose: 成员上线
3005 	{
3006 		CKin* pKin = itKin->second;
3008 		// TraceLn("[跨区家族] 向公共区同步家族最基本信息：kinID=" << pKin->GetNumProp(emKinProp_ID));
3010 		pKin->SynchKinHeadToPublic();
3011 	}

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\KinService\Kin.cpp 195 KB CPP 文件 2014/2/25 0:22:13 2018/10/23 20:08:57 2018/10/23 20:08:57 1
4150 void CKin::OnClientKinLargess(UserInfo* pUserInfo, LPCSTR pszData, size_t nLen)
4151 {
4153 	// 取得跨区桥服务器连接器接口
4154 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
4155 	

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\KinService\ComKinService.cpp 22 KB CPP 文件 2014/2/25 0:22:10 2018/10/23 20:08:57 2018/10/23 20:08:57 4
227 	}
228 }
230 /// purpose: 处理其他服务器通过跨区桥服务器转发的消息
231 //@ param: actionId 消息码
232 //@ param: bridgeHead 桥消息头
236 void CComKinService::HandleBridgeMessage(unsigned long actionId, SMsgBridgeHead &bridgeHead, SGameMsgHead* head, LPSTR data, size_t len)
237 {
238 	// TraceLn("[跨区家族] 收到桥服务器来的消息：actionId=" << actionId);
240 	switch (actionId)
241 	{
541 		return;
542 	}
544 	// TraceLn("[跨区家族 公共区] 收到家族信息： 家族ID=" << pUpdateKin->dwID);
545 	CKin* pKin = FindKin(pUpdateKin->dwID);
546 	if (pKin != NULL)
627 		return;
628 	}
630 	// TraceLn("[跨区家族 公共区] 家族最基本信息： 家族ID=" << pUpdateKin->dwID);
632 	CKin* pKin = FindKin(pUpdateKin->dwID);
633 	if (pKin != NULL)

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\FriendService\FriendService.cpp 42 KB CPP 文件 2014/2/25 0:21:54 2018/10/23 20:08:55 2018/10/23 20:08:55 1
1333 	return static_cast<IFriendService*>(impl);
1334 }
1337 /// purpose: 处理其他服务器通过跨区桥服务器转发的消息
1338 //@ param: actionId 消息码
1339 //@ param: bridgeHead 桥消息头

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\FriendService\Friend.cpp 39 KB CPP 文件 2014/2/25 0:21:52 2018/10/23 20:08:54 2018/10/23 20:08:54 1
228 		if (pComFriendService == NULL || pComFriendService->IsStressTestArea() == true)
229 		{
230 			// 压测目前暂时不支持跨区好友聊天
231 			return;
232 		}

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\FriendService\ComFriendService.cpp 6 KB CPP 文件 2014/2/25 0:21:50 2018/10/23 20:08:54 2018/10/23 20:08:54 1
169 	return true;
170 }
172 /// purpose: 处理其他服务器通过跨区桥服务器转发的消息
173 //@ param: actionId 消息码
174 //@ param: bridgeHead 桥消息头

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\CountryService\GameCountryAPI.cpp 69 KB CPP 文件 2014/2/25 0:21:30 2018/10/23 20:08:53 2018/10/23 20:08:53 13
432 		}
433 	}
435 	// 公共区取跨区国家名称
436 	if (bLocal)
437 	{
457 	else
458 	{
459 		// 取得跨区桥服务器连接器接口
460 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
461 		if (NULL != pBridgeConnector)
598 		}
599 	}
601 	// 公共区取跨区国家名称
602 	if (bLocal)
603 	{
611 	else
612 	{
613 		// 取得跨区桥服务器连接器接口
614 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
615 		if (NULL != pBridgeConnector)
661 		}
662 	}
664 	// 公共区取跨区国家名称
665 	if (bLocalName)
666 	{
674 	else
675 	{
676 		// 取得跨区桥服务器连接器接口
677 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
678 		if (NULL != pBridgeConnector)
750 		}
751 	}
753 	// 公共区取跨区国家名称
754 	if (bLocal)
755 	{
768 	else
769 	{
770 		// 取得跨区桥服务器连接器接口
771 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
772 		if (NULL != pBridgeConnector)
834 	else
835 	{
836 		// 通过跨区桥服务器连接器接口取得国家群组号
837 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
838 		if (NULL != pBridgeConnector)
914 	else
915 	{
916 		// 通过跨区桥服务器连接器接口取得国家群组号
917 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
918 		if (NULL != pBridgeConnector)
1003 	else
1004 	{
1005 		// 通过跨区桥服务器连接器接口取得国家群组号
1006 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
1007 		if (NULL != pBridgeConnector)
1103 	else
1104 	{
1105 		// 通过跨区桥服务器连接器接口取得国家群组号
1106 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
1107 		if (NULL != pBridgeConnector)
1205 	else
1206 	{
1207 		// 通过跨区桥服务器连接器接口取得国家群组号
1208 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
1209 		if (NULL != pBridgeConnector)

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\CountryService\CountryService.cpp 199 KB CPP 文件 2014/2/25 0:21:25 2018/10/23 20:08:52 2018/10/23 20:08:52 12
170 	// 添加观察者
171 	pUserManager->addObserver(static_cast<IUserManagerObserver *>(this));
173 	// 取得跨区桥服务器连接器接口
174 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
175 	if (NULL==pBridgeConnector)
177 		return false;
178 	}
179 	// 订阅  跨区桥服务器连接器 MSG_MODULEID_COUNTRY 消息
180 	pBridgeConnector->registerMessageHandler(MSG_MODULEID_COUNTRY,this);
182 	// 全部游戏世界加入事件
277 		pUserManager->removeObserver(static_cast<IUserManagerObserver *>(this));
278 	}
280 	// 取得跨区桥服务器连接器接口
281 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
282 	if (NULL!=pBridgeConnector)
690 	return bRet;
691 }
694 ////////////// IBridgeEventHandler 处理处理跨区桥服务器执行事件 ////////////////////////////////////////////////////////////
696 /** 处理处理跨区桥服务器执行事件
697 @param   wEventID ：事件ID
698 @param   pszContext : 上下文
706 		return;
707 	}
708 	// 取得跨区桥服务器连接器接口
709 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
710 	if (NULL==pBridgeConnector)
759 	default:
760 		{
761 			ErrorLn("国家社会服务器尚有一个跨区桥服务器执行事件订阅了但未处理，wEventID = "<<wEventID);
762 		}
763 		break;
765 }
768 //////////////////IBridgeMessageHandler////////////////////////////////////////////////////////
770 /** 处理跨区桥服务器发过来的消息
771 @name         : 处理其他服务器通过跨区桥服务器转发的消息
772 @param actionId  : 消息码
773 @param bridgeHead  : 桥消息头
4167 void CCountryService::UpdateWorldListToClient(DWORD dwClientID,BYTE nUpdateType,DWORD dwUpdateWorldID)
4168 {
4169 	// 取得跨区桥服务器连接器接口
4170 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
4171 	if (NULL==pBridgeConnector)
4300 void CCountryService::UpdateWorldCountryToClient(DWORD dwClientID,BYTE nUpdateType,DWORD dwWorldID,DWORD dwServerID,DWORD dwCountryID)
4301 {
4302 	// 取得跨区桥服务器连接器接口
4303 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
4304 	if (NULL==pBridgeConnector)
4419 void CCountryService::SendWorldCountryToBridgeServer(DWORD dwServerID,DWORD dwCountryID)
4420 {
4421 	// 取得跨区桥服务器连接器接口
4422 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
4423 	if (NULL==pBridgeConnector)

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\CountryService\BasePart.cpp 133 KB CPP 文件 2014/2/25 0:21:18 2018/10/23 20:08:52 2018/10/23 20:08:52 24
1114 	sstrcpyn(saveParam.szLocalName, m_CountryBaseInfo.szLocalName, sizeof(saveParam.szLocalName));
1115 	
1116 	// 跨区国家名称
1117 	sstrcpyn(saveParam.szWorldName, m_CountryBaseInfo.szWorldName, sizeof(saveParam.szWorldName));
1119 	// 修改
2152 	// 本区国家短名称
2153 	sstrcpyn(m_CountryBaseInfo.szLocalName, m_CountryBaseInfo.szName, sizeof(m_CountryBaseInfo.szLocalName));
2154 	// 跨区国家名称
2155 	sprintf_s(m_CountryBaseInfo.szWorldName, sizeof(m_CountryBaseInfo.szWorldName), "%s%s", g_ExternalFacade.GetWorldName(dwWorldID), m_CountryBaseInfo.szName);
2157 	AddCountry(addparam);
2250 	// 本区国家短名称
2251 	sstrcpyn(stSaveParam.szLocalName, m_CountryBaseInfo.szLocalName, sizeof(stSaveParam.szLocalName));
2253 	// 跨区国家名称
2254 	sstrcpyn(stSaveParam.szWorldName, m_CountryBaseInfo.szWorldName, sizeof(stSaveParam.szWorldName));
2255 	//
2483 	// 本区国家短名称
2484 	sstrcpyn(m_CountryBaseInfo.szLocalName, pDBReqCountryBase->szLocalName, sizeof(m_CountryBaseInfo.szLocalName));
2486 	// 跨区国家名称
2487 	sstrcpyn(m_CountryBaseInfo.szWorldName, pDBReqCountryBase->szWorldName, sizeof(m_CountryBaseInfo.szWorldName));
2489 	// 所属数据库游戏世界名称
2498 #ifdef COUNTRY_PRINT_DEBUG_INF
2499 	// 调式代码
2500 	sprintf_s(szBuf, _countof(szBuf),_NGT" 读取国家数据:国家ID=%d,国家名称=%s,等级=%d,等级名=%s,强大程度=%d,文明点数=%d,金钱=%d,木材=%d,粮草=%d,交易税收=%d,官员俸禄=%d,军队俸禄=%d,功勋兑换=%d,文官上限=%d,将军上限=%d,巡捕上限=%d,诸侯上限=%d,候相上限=%d,国王ID=%d,本区国家短名称=%s,跨区国家名称=%s,所属数据库游戏世界名称=%s",
2501 		m_CountryBaseInfo.dwID,m_CountryBaseInfo.szName,m_CountryBaseInfo.nLevel,m_CountryBaseInfo.szLevelName,
2502 		m_CountryBaseInfo.dwPower,m_CountryBaseInfo.dwPiont,m_CountryBaseInfo.dwMoney,m_CountryBaseInfo.dwWood,m_CountryBaseInfo.dwFood,
2801 	// 调式代码
2802 	char szBuf[512]={0};
2803 	sprintf_s(szBuf, _countof(szBuf),_NGT"CBasePart::SendBaseToServer() 社会服务器发送场景服数据:dwZoneServerID=%d,国家ID=%d,国家名称=%s,等级=%d,等级名=%s,强大程度=%d,文明点数=%d,金钱=%d,木材=%d,粮草=%d,交易税收=%d,官员俸禄=%d,军队俸禄=%d,功勋兑换=%d,文官上限=%d,将军上限=%d,巡捕上限=%d,诸侯上限=%d,侯相上限=%d,国王ID=%d,本区国家短名称=%s,跨区国家名称=%s",
2804 		dwZoneServerID,m_CountryBaseInfo.dwID,m_CountryBaseInfo.szName,m_CountryBaseInfo.nLevel,m_CountryBaseInfo.szLevelName,
2805 		m_CountryBaseInfo.dwPower,m_CountryBaseInfo.dwPiont,m_CountryBaseInfo.dwMoney,m_CountryBaseInfo.dwWood,m_CountryBaseInfo.dwFood,
2841 	sendData.nTitleLen				= strlen(m_CountryBaseInfo.szTitle);				// 国家公告长度
2842 	sendData.nLocalNameLen			= strlen(m_CountryBaseInfo.szLocalName);			// 本区国家短名称长度
2843 	sendData.nWorldNameLen			= strlen(m_CountryBaseInfo.szWorldName);			// 跨区国家名称长度
2844 	sendData.nDBWorldNameLen		= strlen(m_CountryBaseInfo.szDBWorldName);			// 所属数据库游戏世界名称长度
2846 	if (sendData.nNameLen>=COUNTRY_NAME_MAXSIZE)
2857 		sendData.nLocalNameLen = COUNTRY_NAME_MAXSIZE-1;
2858 	}
2859 	// 跨区国家名称长度
2860 	if (sendData.nWorldNameLen>=COUNTRY_NAME_MAXSIZE)
2861 	{
2870 	//char szTitle[COUNTRY_LONGSTR_MAXSIZE];					// 国家公告
2871 	//char szLocalName[COUNTRY_NAME_MAXSIZE];					// 本区国家短名称长度
2872 	//char szWorldName[COUNTRY_NAME_MAXSIZE];					// 跨区国家名称长度
2873 	//char szDBWorldName[COUNTRY_NAME_MAXSIZE];					// 所属数据库游戏世界名称
2874 	obuf1024 obuf;
2890 		obuf.push_back(m_CountryBaseInfo.szLocalName, sendData.nLocalNameLen);
2891 	}
2892 	// 跨区国家名称长度
2893 	if (sendData.nWorldNameLen>0)
2894 	{
2979 	sendData.nTitleLen				= strlen(m_CountryBaseInfo.szTitle);				// 国家公告长度
2980 	sendData.nLocalNameLen			= strlen(m_CountryBaseInfo.szLocalName);			// 本区国家短名称长度
2981 	sendData.nWorldNameLen			= strlen(m_CountryBaseInfo.szWorldName);			// 跨区国家名称长度
2982 	sendData.nDBWorldNameLen		= strlen(m_CountryBaseInfo.szDBWorldName);			// 所属数据库游戏世界名称长度
2984 	if (sendData.nNameLen>=COUNTRY_NAME_MAXSIZE)
2995 		sendData.nLocalNameLen = COUNTRY_NAME_MAXSIZE-1;
2996 	}
2997 	// 跨区国家名称长度
2998 	if (sendData.nWorldNameLen>=COUNTRY_NAME_MAXSIZE)
2999 	{
3008 	//char szTitle[COUNTRY_LONGSTR_MAXSIZE];					// 国家公告
3009 	//char szLocalName[COUNTRY_NAME_MAXSIZE];					// 本区国家短名称长度
3010 	//char szWorldName[COUNTRY_NAME_MAXSIZE];					// 跨区国家名称长度
3011 	//char szDBWorldName[COUNTRY_NAME_MAXSIZE];					// 所属数据库游戏世界名称
3013 	obuf1024 obuf;
3029 		obuf.push_back(m_CountryBaseInfo.szLocalName, sendData.nLocalNameLen);
3030 	}
3031 	// 跨区国家名称长度
3032 	if (sendData.nWorldNameLen>0)
3033 	{
3116 	sendData.nTitleLen				= strlen(m_CountryBaseInfo.szTitle);				// 国家公告长度
3117 	sendData.nLocalNameLen			= strlen(m_CountryBaseInfo.szLocalName);			// 本区国家短名称长度
3118 	sendData.nWorldNameLen			= strlen(m_CountryBaseInfo.szWorldName);			// 跨区国家名称长度
3119 	sendData.nDBWorldNameLen		= strlen(m_CountryBaseInfo.szDBWorldName);			// 所属数据库游戏世界名称长度
3121 	if (sendData.nNameLen>=COUNTRY_NAME_MAXSIZE)
3132 		sendData.nLocalNameLen = COUNTRY_NAME_MAXSIZE-1;
3133 	}
3134 	// 跨区国家名称长度
3135 	if (sendData.nWorldNameLen>=COUNTRY_NAME_MAXSIZE)
3136 	{
3145 	//char szTitle[COUNTRY_LONGSTR_MAXSIZE];					// 国家公告
3146 	//char szLocalName[COUNTRY_NAME_MAXSIZE];					// 本区国家短名称长度
3147 	//char szWorldName[COUNTRY_NAME_MAXSIZE];					// 跨区国家名称长度
3148 	//char szDBWorldName[COUNTRY_NAME_MAXSIZE];					// 所属数据库游戏世界名称
3149 	obuf1024 obuf;
3165 		obuf.push_back(m_CountryBaseInfo.szLocalName, sendData.nLocalNameLen);
3166 	}
3167 	// 跨区国家名称长度
3168 	if (sendData.nWorldNameLen>0)
3169 	{
3374 		return;
3375 	}
3377 	// 取得跨区桥服务器连接器接口
3378 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
3379 	if (NULL==pBridgeConnector)
3491 		return;
3492 	}
3494 	/////// 跨区桥服务器连接器  ////////////////////////////////////////
3495 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
3496 	if (NULL==pBridgeConnector)
3549 	// 本区国家名称
3550 	sstrcpyn(sendData.data.szName, m_CountryBaseInfo.szName, sizeof(sendData.data.szName));
3551 	// 跨区国家名称
3552 	sstrcpyn(sendData.data.szWorldName, m_CountryBaseInfo.szWorldName, sizeof(sendData.data.szWorldName));
3553 	// 所属数据库游戏世界名称
3688 	// 本区国家短名称
3689 	sstrcpyn(m_CountryBaseInfo.szLocalName, stCountryBase.szLocalName, sizeof(m_CountryBaseInfo.szLocalName));
3691 	// 跨区国家名称
3692 	sstrcpyn(m_CountryBaseInfo.szWorldName, stCountryBase.szWorldName, sizeof(m_CountryBaseInfo.szWorldName));
3694 	// 所属数据库游戏世界名称
3703 #ifdef TRACE_COUNTRY_DETAIL
3704 	// 调式代码
3705 	sprintf_s(szBuf, _countof(szBuf),_NGT" 读取国家数据:国家ID=%d,国家名称=%s,等级=%d,等级名=%s,强大程度=%d,文明点数=%d,金钱=%d,木材=%d,粮草=%d,交易税收=%d,官员俸禄=%d,军队俸禄=%d,功勋兑换=%d,文官上限=%d,将军上限=%d,巡捕上限=%d,诸侯上限=%d,候相上限=%d,国王ID=%d,本区国家短名称=%s,跨区国家名称=%s,所属数据库游戏世界名称=%s",
3706 		m_CountryBaseInfo.dwID,m_CountryBaseInfo.szName,m_CountryBaseInfo.nLevel,m_CountryBaseInfo.szLevelName,
3707 		m_CountryBaseInfo.dwPower,m_CountryBaseInfo.dwPiont,m_CountryBaseInfo.dwMoney,m_CountryBaseInfo.dwWood,m_CountryBaseInfo.dwFood,
3832 	// 本区国家短名称
3833 	sstrcpyn(stSaveParam.szLocalName, m_CountryBaseInfo.szLocalName, sizeof(stSaveParam.szLocalName));
3835 	// 跨区国家名称
3836 	sstrcpyn(stSaveParam.szWorldName, m_CountryBaseInfo.szWorldName, sizeof(stSaveParam.szWorldName));
3837 	//

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\ClanService\ComClanService.cpp 18 KB CPP 文件 2014/2/25 0:21:12 2018/10/23 20:08:52 2018/10/23 20:08:52 2
227 	}
228 }
230 /// purpose: 处理其他服务器通过跨区桥服务器转发的消息
231 //@ param: actionId 消息码
232 //@ param: bridgeHead 桥消息头
453 	}
454 	SPuMsgClan_UpdateClan* pUpdateClan = (SPuMsgClan_UpdateClan*)pData;
456 	TraceLn("[跨区帮会 公共区] 收到帮会信息： 家族ID=" << pUpdateClan->dwID);
458 	if (nLen != sizeof(SPuMsgClan_UpdateClan) + pUpdateClan->nMemberCount * sizeof(int))
459 	{

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\ClanService\ClanService.cpp 113 KB CPP 文件 2014/2/25 0:21:17 2018/10/23 20:08:52 2018/10/23 20:08:52 3
1154 			{
1155 				CClan* pClan = it->second;
1157 				TraceLn("[跨区帮会 OnBridgeEventExecute] 向公共区同步帮会信息：clanID=" << pClan->GetNumProp(emClanProp_ID));
1158 				pClan->SynchToPublicServer();
1159 			}
2558 	// 同步到公共区
2559 	pClan->SynchToPublicServer();
2561 	TraceLn("[跨区帮会 OnReadDBFinish] 向公共区同步帮会信息：clanID=" << pClan->GetNumProp(emClanProp_ID));
2562 }
2564 /// purpose: 成员上线
2744 	{
2745 		CClan* pClan = it->second;
2747 		//TraceLn("[跨区帮会] 向公共区同步帮会信息：clanID=" << pClan->GetNumProp(emClanProp_ID));
2748 		pClan->SynchToPublicServer();
2749 	}

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\ChatService\GMCommandManager.cpp 19 KB CPP 文件 2014/2/25 0:21:02 2018/10/23 20:08:51 2018/10/23 20:08:51 1
365 	REG_GM_CMD(GMCommand_CheckZone,	"checkzone",		":checkzone 角色名",					"查询玩家在公共区还是普通区",	
366 		RightFlag_ChangePos_Myself, true, false);
368 	REG_GM_CMD(GMCommand_Hang,		"hang",				":hang",								"跨区传送到默认位置",	
369 		RightFlag_ChangePos_Myself, true, false);
370 	//

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\ChatService\ChatService.cpp 91 KB CPP 文件 2014/2/25 0:20:56 2018/10/23 20:08:50 2018/10/23 20:08:50 5
152 	if (pBridgeConnector != NULL)
153 	{
154 		// 订阅  跨区桥服务器连接器 MSG_MODULEID_CHAT 消息
155 		pBridgeConnector->registerMessageHandler(MSG_MODULEID_CHAT,this);
156 	}
166 void ChatService::close()
167 {
168 	// 取消订阅 取得跨区桥服务器连接器MSG_MODULEID_CHAT消息
169 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
170 	if (pBridgeConnector != NULL)
540 	SendReportToGMClient(dwClientID, repInfo);	
541 }
543 // 跨区聊天
544 void ChatService::KuaquBroadcastChatMessage(UserInfoEx* infoex, ulong senderRank, ulong channel, const char* text, int orderSet)
545 {
1366 }
1368 //////////////////IBridgeMessageHandler////////////////////////////////////////////////////////
1370 /** 处理跨区桥服务器发过来的消息
1371 @name         : 处理其他服务器通过跨区桥服务器转发的消息
1372 @param actionId  : 消息码
1373 @param bridgeHead  : 桥消息头

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\ServerManager\ManagerServer\Src\GlobalManagerServer.cpp 77 KB CPP 文件 2014/2/25 0:33:10 2018/10/23 20:08:45 2018/10/23 20:08:45 1
40 	{ 10,MSG_MG_ENDPOINT_VERIFY,	true,false,	"验证码服务器",	"\\Social",		"\\Social\\VerifyService.exe",			"",						"VerifyService.exe",		1000,	0,	0,	0},
41 	{ 11,MSG_MG_ENDPOINT_TRACKER,	true,false,	"Tracker服务器","\\Cluster",	"\\Cluster\\TrackerServer.exe",			"",						"TrackerServer.exe",		1000,	0,	0,	0},
42 	{ 12,MSG_MG_ENDPOINT_BRIDGE,	true,false,	"跨区桥服务器",	"\\Cluster",	"\\Cluster\\BridgeServer.exe",			"",						"BridgeServer.exe",			1000,	0,	0,	0},
43 	{ 13,MSG_MG_ENDPOINT_DBHTTP,	true,false,	"DB应用服务器",	"\\Cluster",	"\\Cluster\\DBHttpServer.exe",			"",						"DBHttpServer.exe",			1000,	0,	0,	0},
44 	{ 14,MSG_MG_ENDPOINT_PASSPORT,	true,false,	"通行证服务器",	"\\Cluster",	"\\Cluster\\PassportServer.exe",		"",						"PassportServer.exe",		1000,	0,	0,	0},

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\ServerManager\ManagerClient\Src\RealTimeDataDraw.cpp 146 KB CPP 文件 2014/2/25 0:32:15 2018/10/23 20:07:25 2018/10/23 20:07:25 1
54 	static const SRTDrawTypeConfigInfo _gRTDrawTypeConfigInfoList[MG_RTDrawType_MaxID] = {
55 		//                                                                                          {   0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,  16,  17,  18,  19,  20,  21 } 
56 		// 实时数据绘图类型ID,					是否启用,	绘图类型名称,服务器类型是否支持			{  无,场景,网关,登录,世界,客户,输入,中心,社会,前端,验证,  Tk,跨区,  DB,通行,语音,语关,  根,  主,  子,管客,  空 }
57 		{ MG_RTDrawType_None,							0,	"未支持",	"显示未支持文字",			{   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   0 }	},	// 无曲线图,只显示文字
58 		{ MG_RTDrawType_OnlineCountsCurve,				1,	"在线",		"在线数曲线图",				{   0,   1,   1,   1,   0,   0,   0,   0,   1,   0,   0,   0,   0,   0,   0,   1,   1,   0,   0,   0,   0,   0 }	},	// 在线数曲线图

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\ServerManager\ManagerClient\Src\MainFrm.cpp 212 KB CPP 文件 2014/2/25 0:32:01 2018/10/23 20:07:24 2018/10/23 20:07:24 2
65 	IDI_ICON_VERIFY,	// 验证码服务器
66 	IDI_ICON_TRACKER,	// Tracker服务器
67 	IDI_ICON_BRIDGE,	// 跨区桥服务器
68 	IDI_ICON_DBHTTP,	// DB应用服务器
69 	IDI_ICON_PASSPORT,	// 通行证服务器
88 	IDI_ICON_VERIFY0,	// 验证码服务器
89 	IDI_ICON_TRACKER0,	// Tracker服务器
90 	IDI_ICON_BRIDGE0,	// 跨区桥服务器
91 	IDI_ICON_DBHTTP0,	// DB应用服务器
92 	IDI_ICON_PASSPORT0,	// 通行证服务器

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\ServerManager\Common\RealTimeDataSrc.cpp 12 KB CPP 文件 2014/2/25 0:20:27 2018/10/23 20:07:19 2018/10/23 20:07:19 1
41 		0,		// 验证码服务器
42 		0,		// Tracker服务器
43 		0,		// 跨区桥服务器
44 		0,		// DB应用服务器
45 		0,		// 通行证服务器

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\ServerManager\Common\ManagerFun.cpp 17 KB CPP 文件 2014/2/25 0:20:27 2018/10/23 20:07:19 2018/10/23 20:07:19 1
188 		_T("验证码服务器"),
189 		_T("Tracker服务器"),
190 		_T("跨区桥服务器"),
191 		_T("DB应用服务器"),
192 		_T("通行证服务器"),

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\ZoneServerLogic\ZoneServiceProvider.cpp 77 KB CPP 文件 2014/2/25 0:20:21 2018/10/23 20:07:19 2018/10/23 20:07:19 7
401 }
402 //////////////////////////////////////////////////////////////////////////
404 /// 关闭跨区桥服务器连接器
405 void CZoneServiceProvider::ReleaseBridgeConnector(void)
406 {
440 @retval buffer 
441 */
443 ////////// IBridgeEventHandler 处理处理跨区桥服务器执行事件 //////////////////
444 /** 
445 @param   wEventID ：事件ID
485 	default:
486 		{
487 			ErrorLn("场景服务器尚有一个跨区桥服务器执行事件订阅了但未处理，wEventID = "<<wEventID);
488 		}
489 		break;
2031 	CALCULATE_RELEASEMODULE("LUA引擎");
2033 	EmphasisLn("完成释放场景服的各个模块.....总耗时="<<::GetTickCount()-nTotalTick<<"ms");
2035 	/// 关闭跨区桥服务器连接器
2036 	ReleaseBridgeConnector();
2036 	ReleaseBridgeConnector();
2037 	EmphasisLn("已关闭跨区桥服务器连接器");
2041 	// 停止逻辑线程
2042 	m_LogicThread.StopThread();
2781 	return m_ManagerConnector;
2782 }
2784 // 获得跨区桥服务器连接器
2785 IBridgeConnector* CZoneServiceProvider::GetBridgeConnector(void)
2786 {
2797 	return m_nCurAreaLoadMapMode;
2798 }
2800 /** 取得跨区服务器
2801 @param   
2802 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\ZoneServerLogic\SchemeZoneMatron.cpp 7 KB CPP 文件 2014/2/25 0:20:14 2018/10/23 20:07:19 2018/10/23 20:07:19 1
202 		// 禁止双人坐骑进入
203 		schemeInfo.bForbidBWM = pCSVReader->GetBool(i, 17, 0);
205 		// 不允许跨区传送
206 		schemeInfo.bForbidStarTrek = pCSVReader->GetBool(i, 18, 0);
208 		// 标志位

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\ZoneServerLogic\MiscServerWrap.cpp 15 KB CPP 文件 2014/2/25 0:19:41 2018/10/23 20:07:15 2018/10/23 20:07:15 1
540 		if (dwNowTicks>dwLastTimes+60000)
541 		{
542 			ErrorLn("难道开了多台登陆服务器？这样会导致跨区的模块无法使用！台数 = " << count);
543 		}
544 		return;

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\ZoneServer\ZoneServiceProvider.cpp 101 KB CPP 文件 2014/2/25 0:12:52 2018/10/23 20:07:10 2018/10/23 20:07:10 20
461 	}
462 }
464 /// 启动跨区桥服务器连接器
465 void CZoneServiceProvider::CreateBridgeConnector(void)
466 {
465 void CZoneServiceProvider::CreateBridgeConnector(void)
466 {
467 	// 加载跨区桥服务器连接器设定
468 	Ini ini("Bridge.ini");
469 	std::string strBridgeServerIP = ini.getString("Setting","BridgeServerIP","127.0.0.1");
490 	if (nOpenBridge!=1)
491 	{
492 		WarningLn("跨区桥服务器连接禁用!");
493 		return;
494 	}
493 		return;
494 	}
495 	// 跨区桥服务器连接器连接
496 	TraceLn("连接跨区桥服务器:游戏世界ID="<<dwGameWorldID<<":"<<strWorldName.c_str()<<","<<strBridgeServerIP.c_str()<<":"<<nBridgeServerPort);
497 	if(!m_BridgeConnector->Connect(strBridgeServerIP.data(),nBridgeServerPort))
498 	{
497 	if(!m_BridgeConnector->Connect(strBridgeServerIP.data(),nBridgeServerPort))
498 	{
499 		TraceLn("连接跨区桥服务器失败!");
500 		return;
501 	}
500 		return;
501 	}
502 	//TraceLn("连接跨区桥服务器成功!");
504 	// 全部游戏世界加入事件
505 	m_BridgeConnector->registerEventHandler(EVENT_BRIDGE_WORLDLIST_ALL,static_cast<IBridgeEventHandler *>(this));
509 	m_BridgeConnector->registerEventHandler(EVENT_BRIDGE_WORLDLIST_EDIT,static_cast<IBridgeEventHandler *>(this));
510 }
511 /// 关闭跨区桥服务器连接器
512 void CZoneServiceProvider::ReleaseBridgeConnector(void)
513 {
520 		// 修改游戏世界事件
521 		m_BridgeConnector->unregisterEventHandler(EVENT_BRIDGE_WORLDLIST_EDIT,static_cast<IBridgeEventHandler *>(this));
523 		// 关闭跨区桥服务器连接器
524 		EmphasisLn("关闭跨区桥服务器连接器!");
525 		m_BridgeConnector->Release();
526 		m_BridgeConnector = NULL;
603 	}
604 }
606 ////////// IBridgeEventHandler 处理处理跨区桥服务器执行事件 //////////////////
607 /** 
608 @param   wEventID ：事件ID
648 	default:
649 		{
650 			ErrorLn("场景服务器尚有一个跨区桥服务器执行事件订阅了但未处理，wEventID = "<<wEventID);
651 		}
652 		break;
1438 #	define      START_SERVICE(name)                   GetProcessMemoryInfo(GetCurrentProcess(),&pmc,sizeof(pmc));  \
1439 	                                                  Trace("开始启动" << name << "[mem:" << pmc.PagefileUsage << "]......" << endl);
1441 	// 连接跨区桥服务器	
1442 	Trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl);
1442 	Trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl);
1443 	START_SERVICE("跨区桥服务器");
1444 	CreateBridgeConnector();
1445 	if(m_BridgeConnector == NULL)
1445 	if(m_BridgeConnector == NULL)
1446 	{
1447 		Error("连接跨区桥服务器失败... ..." << endl);
1448 		return false;
1449 	}
1448 		return false;
1449 	}
1450 	Trace("连接跨区桥服务器成功... ..." << endl);
1451 	Trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl << endl);
1453 	// 加上服务器名服务器ID
2725 	CALCULATE_RELEASEMODULE("LUA引擎");
2727 	EmphasisLn("完成释放场景服的各个模块.....总耗时="<<::GetTickCount()-nTotalTick<<"ms");
2729 	/// 关闭跨区桥服务器连接器
2730 	ReleaseBridgeConnector();
2730 	ReleaseBridgeConnector();
2731 	EmphasisLn("已关闭跨区桥服务器连接器");
2733 	// 关闭管理连接器
2734 	ReleaseManagerConnector();
3496 	return m_ManagerConnector;
3497 }
3499 // 获得跨区桥服务器连接器
3500 IBridgeConnector* CZoneServiceProvider::GetBridgeConnector(void)
3501 {
3512 	return m_nCurAreaLoadMapMode;
3513 }
3515 /** 取得跨区服务器
3516 @param   
3517 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\ZoneServer\SchemeZoneMatron.cpp 7 KB CPP 文件 2014/2/25 0:12:35 2018/10/23 20:07:09 2018/10/23 20:07:09 1
202 		// 禁止双人坐骑进入
203 		schemeInfo.bForbidBWM = pCSVReader->GetBool(i, 17, 0);
205 		// 不允许跨区传送
206 		schemeInfo.bForbidStarTrek = pCSVReader->GetBool(i, 18, 0);
208 		// 标志位

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\ZoneServer\MiscServerWrap.cpp 15 KB CPP 文件 2014/2/25 0:12:13 2018/10/23 20:07:04 2018/10/23 20:07:04 1
540 		if (dwNowTicks>dwLastTimes+60000)
541 		{
542 			ErrorLn("难道开了多台登陆服务器？这样会导致跨区的模块无法使用！台数 = " << count);
543 		}
544 		return;

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\ZoneServer2\ZoneServerLauncher.cpp 9 KB CPP 文件 2014/2/25 0:13:02 2018/10/23 20:07:12 2018/10/23 20:07:12 6
258 	return true;
259 }
264 /// 启动跨区桥服务器连接器
265 bool CZoneServerLauncher::__CreateBridgeConnector(void)
266 {
265 bool CZoneServerLauncher::__CreateBridgeConnector(void)
266 {
267 	// 加载跨区桥服务器连接器设定
268 	Ini ini("Bridge.ini");
269 	std::string strBridgeServerIP = ini.getString("Setting","BridgeServerIP","127.0.0.1");
291 	if (nOpenBridge != 1)
292 	{
293 		WarningLn("跨区桥服务器连接禁用!");
294 		return true;
295 	}
294 		return true;
295 	}
297 	// 跨区桥服务器连接器连接	
298 	if(!m_pBridgeConnector->Connect(strBridgeServerIP.c_str(), nBridgeServerPort))
299 	{
298 	if(!m_pBridgeConnector->Connect(strBridgeServerIP.c_str(), nBridgeServerPort))
299 	{
300 		TraceLn("连接跨区桥服务器失败!");
301 		return false;
302 	}
303 	else
304 	{
305 		TraceLn("连接跨区桥服务器:游戏世界ID="<<dwGameWorldID<<":"<<strWorldName.c_str()<<","<<strBridgeServerIP.c_str()<<":"<<nBridgeServerPort);
306 	}
308 	return true;	

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\TestServer\TestServer.cpp 38 KB CPP 文件 2014/2/25 0:11:39 2018/10/23 20:06:57 2018/10/23 20:06:57 1
1186 	else
1187 	{
1188 		// 取得跨区桥服务器连接器接口
1189 		IBridgeConnector*pBridgeConnector = GetGlobalBridgeConnector();
1190 		if (pBridgeConnector!=NULL)

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\TeamServer\TeamServer.cpp 60 KB CPP 文件 2014/2/25 0:11:34 2018/10/23 20:06:56 2018/10/23 20:06:56 1
1476 	msglinestate.nMode = nMode;
1477 	msglinestate.bActiveExit = pTunnel->IsActiveExitClient(); 
1479 	// 为了让跨区的时候，不退出队伍，强制标记得为断线下线
1480 	if(!bLoginFlag && nMode == loginXlogout_Mode_StarTrek)
1481 	{

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\StarTrekServer\StarTrekServer.cpp 8 KB CPP 文件 2014/2/25 0:11:07 2018/10/23 20:06:53 2018/10/23 20:06:53 7
107 }
109 /**
110 @name         : 处理其他服务器通过跨区桥服务器转发的消息
111 @param actionId  : 消息码
112 @param bridgeHead  : 桥消息头
154 	}
155 }
157 /** 预判断能否跨区	
158 @param	 nInGameWorldID		: 迁入世界ID
159 @param   dwInZoneID			：迁入场景ID
161 @param   nStarTrekType		：传送类型
162 @param   dwStarTrekFlag		：传送标志
163 @param   bAsyncCheck		: 是否需要跨区判断
164 @param   pszCanInLuaFunction: 迁入场景服能否接收的Lua函数
164 @param   pszCanInLuaFunction: 迁入场景服能否接收的Lua函数
165 @param   pszCheckResultLua	: 跨区判断的结果Lua函数
166 @param   跨区判断:
167 　　　　 1: 若在当前进程都失败，则直接返回
168 		 2: 最终结果在pszCheckResultLua返回, 参数输入只需填函数名, 参数依次为:
179 									   pszCanInLuaFunction, pszCheckResultLua);
180 }
182 /** 跨区
183 @param	 nInGameWorldID			: 迁入世界ID
184 @param   dwInZoneID				：迁入场景ID
207 									pszDoneInLuaFunction);
208 }
210 /** 释放跨区对像
211 @param   nSTDir : tStarTrek_MsgDir_In, tStarTrek_MsgDir_Out
212 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\StarTrekServer\OutDirHandler.cpp 26 KB CPP 文件 2014/2/25 0:11:06 2018/10/23 20:06:52 2018/10/23 20:06:52 10
181 	return (*itNeed).second;
182 }
184 /** 预判断能否跨区	
185 @param	 nInGameWorldID		: 迁入世界ID
186 @param   dwInZoneID			：迁入场景ID
188 @param   nStarTrekType		：传送类型
189 @param   dwStarTrekFlag		：传送标志
190 @param   bAsyncCheck		: 是否需要跨区判断
191 @param   pszCanInLuaFunction: 迁入场景服能否接收的Lua函数
191 @param   pszCanInLuaFunction: 迁入场景服能否接收的Lua函数
192 @param   pszCheckResultLua	: 跨区判断的结果Lua函数
193 @param   跨区判断:
194 　　　　 1: 若在当前进程都失败，则直接返回
195 		 2: 最终结果在pszCheckResultLua返回, 参数输入只需填函数名, 参数依次为:
211 	return __CanStarTrek(PDBID, nInGameWorldID, dwInBridgeServerID, dwInZoneID, ptInLoc, nStarTrekType, dwStarTrekFlag, bAsyncCheck, pszCanInLuaFunction, pszCheckResultLua, 0);
212 }
214 /** 判断能否跨区	
215 @param	 nInGameWorldID		: 迁入世界ID
216 @param	 dwInBridgeServerID	: 迁入服务器ID
219 @param   nStarTrekType		：传送类型
220 @param   dwStarTrekFlag		：传送标志
221 @param   bAsyncCheck		: 是否需要跨区判断
222 @param   pszCanInLuaFunction: 迁入场景服能否接收的Lua函数
222 @param   pszCanInLuaFunction: 迁入场景服能否接收的Lua函数
223 @param   pszCheckResultLua	: 跨区判断的结果Lua函数
224 @return  返回:参见tStarTrek_Result_　....
225 */
309 	return tStarTrek_Result_Succeed;
310 }
312 /** 本游戏世界判断是否能跨区
313 @param   nInGameWorldID	　  : 迁入世界ID
314 @param	 dwInBridgeServerID	: 迁入服务器ID
466 	return tStarTrek_Result_Succeed;
467 }
469 /** 跨区
470 @param	 nInGameWorldID			: 迁入世界ID
471 @param   dwInZoneID				：迁入场景ID
554 }
556 /**
557 @name         : 处理其他服务器通过跨区桥服务器转发的消息
558 @param actionId  : 消息码
559 @param bridgeHead  : 桥消息头

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\StarTrekServer\NeedOutObject.cpp 26 KB CPP 文件 2014/2/25 0:11:05 2018/10/23 20:06:52 2018/10/23 20:06:52 4
320 	if(pTerminalTunnel != NULL)
321 	{
322 		pTerminalTunnel->Kickout(EKickoutClient_Reason_StarTrekFailed, "对不起,跨区切换超时.");
323 	}
324 	else
380 			else if (nReasonEx == tStarTrek_Result_CloseStarTreak)
381 			{
382 				sprintf_s(chatText, "对不起,跨区功能已关闭,暂时无法传送,请稍候再试[%d,%d]... ...", nReleaseTreakReason, nReasonEx);
383 			}
384 			else
491 	}
493 	///////////////////////////////////////////////////////////////////
494 	// 发准备跨区事件，让其他模块好做因应
495 	SEventPersonStarTrek_S eventstartrek;
496 	eventstartrek.uidPerson			= pPerson->GetUID();
528 	if(nTrekLen <= -1)
529 	{
530 		ErrorLn("跨区切换失败...取得重构角色现场景失败! PDBID="<<m_Context.PDBID);
531 		debugBreak;
533 		SaveDataAndLogout(tReleaseTreak_Reason_ExportContextFail);

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\StarTrekServer\InDirHandler.cpp 20 KB CPP 文件 2014/2/25 0:11:05 2018/10/23 20:06:52 2018/10/23 20:06:52 1
52 }
54 /**
55 @name         : 处理其他服务器通过跨区桥服务器转发的消息
56 @param actionId  : 消息码
57 @param bridgeHead  : 桥消息头

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\SiegeWarServer\SiegeWarServer.cpp 93 KB CPP 文件 2014/2/25 0:10:42 2018/10/23 20:06:46 2018/10/23 20:06:46 1
2497 		return 0;
2498 	}
2499 	// 取得跨区竞技部件指针
2500 	IPersonStrikePart *pPersonStrikePart = (IPersonStrikePart *)pPerson->GetEntityPart(ENTITYPART_PERSON_STRIKE);
2501 	if (pPersonStrikePart == NULL)

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\SiegeWarServer\ExternalFacade.cpp 67 KB CPP 文件 2014/2/25 0:10:34 2018/10/23 20:06:44 2018/10/23 20:06:44 2
2456 		}
2457 	}
2459 	// 公共区取跨区国家名称
2460 	if (bLocal)
2461 	{
2474 	else
2475 	{
2476 		// 取得跨区桥服务器连接器接口
2477 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
2478 		if (NULL != pBridgeConnector)

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\ShareServer\ZoneSvrSource.cpp 59 KB CPP 文件 2014/2/25 0:10:31 2018/10/23 20:06:43 2018/10/23 20:06:43 6
110 	pEventEngine->Subscibe(static_cast<IEventExecuteSink *>(this), EVENT_PERSON_BATTLERIDE_KNIGHTTYPE, 
111 							SOURCE_TYPE_PERSON, 0, "CZoneSvrSource::Create");
113 	/////// 注册跨区桥服务器连接器 事件处理者 ///////////////////////////////////////////////////////////////////
114 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
115 	if (NULL!=pBridgeConnector)
138 	// 关闭内存信息同步定时器
139 	gZoneServiceProvider->GetTimeAxis()->KillTimer(emShareEmemory_TimeID, this);
141 	/////// 注销跨区桥服务器连接器 事件处理者 ///////////////////////////////////////////////////////////////////
142 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
143 	if (NULL!=pBridgeConnector)
303 	}
304 }
307 ////////// IBridgeEventHandler 处理处理跨区桥服务器执行事件 /////////////////////////////////////////////////////////
308 /** 
309 @param   wEventID ：事件ID
1665 		return;
1666 	}
1668 	/////// 跨区桥服务器连接器  ////////////////////////////////////////
1669 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
1670 	if (NULL!=pBridgeConnector)
1756 		return;
1757 	}
1760 	/////// 跨区桥服务器连接器  ////////////////////////////////////////
1761 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
1762 	if (NULL!=pBridgeConnector)
1818 		return;
1819 	}
1822 	/////// 跨区桥服务器连接器  ////////////////////////////////////////
1823 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
1824 	if (NULL!=pBridgeConnector)

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\ServerModule\ExternalHelper.cpp 48 KB CPP 文件 2014/2/25 0:10:11 2018/10/23 20:06:37 2018/10/23 20:06:37 2
1654 		}
1655 	}
1657 	// 公共区取跨区国家名称
1658 	if (bLocal)
1659 	{
1672 	else
1673 	{
1674 		// 取得跨区桥服务器连接器接口
1675 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
1676 		if (NULL != pBridgeConnector)

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\RelationServer\VerifyPart.cpp 74 KB CPP 文件 2014/2/25 0:09:45 2018/10/23 20:06:31 2018/10/23 20:06:31 2
547 // 	return true;
548 }
551 /** 跨区切换地图时，将部件数据导出带过去,　如果没有数据，将nLen设为0或返回false
552 @param   
553 @param   
565 	return ExportRenewContext(pszContext,nLen);
566 }
568 /** 跨区切换地图时，将部件数据现场导入
569 @param   
570 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\RelationServer\TitlePart.cpp 64 KB CPP 文件 2014/2/25 0:09:44 2018/10/23 20:06:31 2018/10/23 20:06:31 2
727 // 	return true;
728 }
731 /** 跨区切换地图时，将部件数据导出带过去,　如果没有数据，将nLen设为0或返回false
732 @param   
733 @param   
745 	return ExportRenewContext(pszContext,nLen);
746 }
748 /** 跨区切换地图时，将部件数据现场导入
749 @param   
750 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\NerveServer\ZenSkillPart.cpp 184 KB CPP 文件 2014/2/25 0:09:17 2018/10/23 20:06:27 2018/10/23 20:06:27 1
636 // 	return true;
637 }
639 /** 跨区切换地图时，将部件数据导出带过去,　如果没有数据，将nLen设为0或返回false
640 @param   
641 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\NerveServer\NervePart.cpp 121 KB CPP 文件 2014/2/25 0:09:14 2018/10/23 20:06:26 2018/10/23 20:06:26 1
958 	return true;
959 }
961 /** 跨区切换地图时，将部件数据导出带过去,　如果没有数据，将nLen设为0或返回false
962 @param   
963 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MatchServer\WarServer.cpp 67 KB CPP 文件 2014/2/25 0:09:08 2018/10/23 20:06:25 2018/10/23 20:06:25 15
5 ** 日  期:	2011-03-15
6 ** 版  本:	1.0
7 ** 描  述:	跨区战争系统
8 ** 应  用:  	
9 	
366 	return &(iter->second);
367 }
371 /**  请求更新跨区共享国家信息
372 @return  
373 */
387 		return false;
388 	}
390 	// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
391 	return g_pMatchServer->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_RequestCountryInfo,dwCountryID,0,0);
392 }
436 	obufData.push_back(szTitle, sendData.nTitleStrLen);
437 	obufData.push_back(szHistory, sendData.nHistoryStrLen);
439 	// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
440 	return g_pMatchServer->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_RequestAddHistory,dwCountryID,0,0, obufData.data(), obufData.size());
441 }
537 	obufData.push_back(&dwMaxOnlineCount, sizeof(DWORD));
538 	obufData.push_back(&dwBossHP, sizeof(DWORD));
540 	// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
541 	g_pMatchServer->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_WorldCountryWarState,pCountryWar->m_dwTaskWorldWarID,dwRunStep,dwWarResult,obufData.data(), obufData.size());
543 }
808 }
810 //////////////////////////////////////////////////////////////////////////
812 /** 处理跨区桥服务器发过来的消息
813 @name         : 处理其他服务器通过跨区桥服务器转发的消息
814 @param actionId  : 消息码
815 @param bridgeHead  : 桥消息头
1346 	default:
1347 		{
1348 			ErrorLn("跨区战争系统有一个跨服撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
1349 		}
1350 		break;
1415 				break;
1416 			}
1417 			// 取得跨区桥服务器连接器接口
1418 			IBridgeConnector * pBridgeConnector = GetGlobalBridgeConnector();
1419 			if (pBridgeConnector == NULL)
1506 				break;
1507 			}
1508 			// 取得跨区桥服务器连接器接口
1509 			IBridgeConnector * pBridgeConnector = GetGlobalBridgeConnector();
1510 			if (pBridgeConnector == NULL)
2017 	default:
2018 		{
2019 			ErrorLn("跨区战争系统有一个服务器信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
2020 		}
2021 		break;
2213 	default:
2214 		{
2215 			ErrorLn("跨区战争系统有一个客户端信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
2216 		}
2217 		break;

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MatchServer\War.cpp 98 KB CPP 文件 2014/2/25 0:09:04 2018/10/23 20:06:24 2018/10/23 20:06:24 2
415 		return false;
416 	}
417 	// 跨区副本部件
418 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
419 	if (pEctypeAssistPart==NULL)
759 		return false;
760 	}
761 	// 跨区副本部件
762 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
763 	if (pEctypeAssistPart==NULL)

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MatchServer\StrikeVote.cpp 30 KB CPP 文件 2014/2/25 0:09:03 2018/10/23 20:06:24 2018/10/23 20:06:24 1
5 ** 日  期:	2011-2-11
6 ** 版  本:	1.0
7 ** 描  述:	跨区竞技系统
8 ** 应  用:  	
9 	

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MatchServer\StrikeServer.cpp 27 KB CPP 文件 2014/2/25 0:09:02 2018/10/23 20:06:24 2018/10/23 20:06:24 6
5 ** 日  期:	2010-10-27
6 ** 版  本:	1.0
7 ** 描  述:	跨区竞技系统
8 ** 应  用:  	
9 	
45 {
47 }
50 /** 处理跨区桥服务器发过来的消息
51 @name         : 处理其他服务器通过跨区桥服务器转发的消息
52 @param actionId  : 消息码
53 @param bridgeHead  : 桥消息头
86 	default:
87 		{
88 			ErrorLn("跨区竞技系统有一个跨服撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
89 		}
90 		break;
200 	default:
201 		{
202 			ErrorLn("跨区竞技系统有一个服务器撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
203 		}
204 		break;
729 		default:
730 		{
731 			ErrorLn("跨区竞技系统有一个客户端撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
732 		}
733 		break;

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MatchServer\StrikeMatch.cpp 52 KB CPP 文件 2014/2/25 0:09:02 2018/10/23 20:06:24 2018/10/23 20:06:24 11
46 {
48 }
50 /** 处理跨区桥服务器发过来的消息
51 @name         : 处理其他服务器通过跨区桥服务器转发的消息
52 @param actionId  : 消息码
53 @param bridgeHead  : 桥消息头
547 		return;
548 	}
549 	// 跨区副本部件
550 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
551 	if (NULL==pEctypeAssistPart)
643 		return false;
644 	}
645 	// 跨区副本部件
646 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
647 	if (NULL==pEctypeAssistPart)
806 		return;
807 	}
808 	// 跨区副本部件
809 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
810 	if (NULL==pEctypeAssistPart)
1107 		return false;
1108 	}
1109 	// 跨区副本部件
1110 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
1111 	if (NULL==pEctypeAssistPart)
1249 		return false;
1250 	}
1252 	// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
1253 	return g_pMatchServer->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_CSMSG,Match_CSMsg_RequestJoinStrike,pPerson->GetNumProp(CREATURE_PROP_PDBID),pPerson->GetFromGameWorldID(),0,obufData.data(),obufData.size());
1255 }
1304 		return false;
1305 	}
1306 	// 跨区副本部件
1307 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
1308 	if (NULL==pEctypeAssistPart)
1375 		return false;
1376 	}
1378 	// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
1379 	return g_pMatchServer->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_CSMSG,Match_CSMsg_RequestViewStrike,dwPlayerID,pPerson->GetFromGameWorldID(),0,obufData.data(),obufData.size());
1381 }

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MatchServer\StrikeDropPrize.cpp 64 KB CPP 文件 2014/2/25 0:09:00 2018/10/23 20:06:24 2018/10/23 20:06:24 1
5 ** 日  期:	2011-3-12
6 ** 版  本:	1.0
7 ** 描  述:	跨区竞技系统
8 ** 应  用:  	
9 	

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MatchServer\Strike.cpp 329 KB CPP 文件 2014/2/25 0:08:59 2018/10/23 20:06:24 2018/10/23 20:06:24 6
1189 		return false;
1190 	}
1191 	// 跨区副本部件
1192 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
1193 	if (pEctypeAssistPart==NULL)
1591 		return false;
1592 	}
1593 	// 跨区副本部件
1594 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
1595 	if (pEctypeAssistPart==NULL)
6747 						double fEnergyCreditRate	= 1.0;	// 实战声望精力加成系数
6748 						double fEnergyMoneyRate		= 1.0;	// 实战徽章精力加成系数
6750 						// 判断玩家是否有奖励 每个角色每天参与跨区PVP竞技的有效收益时间为3小时，超过3小时，角色仍可加入战斗，但经验、声望奖励为0
6751 						const SEnergyStateSchemeInfo* pEnergyInfo = pVerifyPart->GetEnergyStateInfo(EnergyType_Strike);
6752 						if (pEnergyInfo!=NULL)
7061 						double fEnergyCreditRate	= 1.0;	// 实战声望精力加成系数
7062 						double fEnergyMoneyRate		= 1.0;	// 实战徽章精力加成系数
7064 						// 判断玩家是否有奖励 每个角色每天参与跨区PVP竞技的有效收益时间为3小时，超过3小时，角色仍可加入战斗，但经验、声望奖励为0
7065 						const SEnergyStateSchemeInfo* pEnergyInfo = pVerifyPart->GetEnergyStateInfo(EnergyType_Strike);
7066 						if (pEnergyInfo!=NULL)
7831 					double fEnergyCreditRate	= 1.0;	// 实战声望精力加成系数
7832 					double fEnergyMoneyRate		= 1.0;	// 实战徽章精力加成系数
7834 					// 判断玩家是否有奖励 每个角色每天参与跨区PVP竞技的有效收益时间为3小时，超过3小时，角色仍可加入战斗，但经验、声望奖励为0
7835 					const SEnergyStateSchemeInfo* pEnergyInfo = pVerifyPart->GetEnergyStateInfo(EnergyType_Strike);
7836 					if (pEnergyInfo!=NULL)
8158 					double fEnergyCreditRate	= 1.0;	// 实战声望精力加成系数
8159 					double fEnergyMoneyRate		= 1.0;	// 实战徽章精力加成系数
8161 					// 判断玩家是否有奖励 每个角色每天参与跨区PVP竞技的有效收益时间为3小时，超过3小时，角色仍可加入战斗，但经验、声望奖励为0
8162 					const SEnergyStateSchemeInfo* pEnergyInfo = pVerifyPart->GetEnergyStateInfo(EnergyType_Strike);
8163 					if (pEnergyInfo!=NULL)

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MatchServer\PersonStrikePart.cpp 95 KB CPP 文件 2014/2/25 0:08:56 2018/10/23 20:06:23 2018/10/23 20:06:23 4
722 // 	return true;
723 }
726 /** 跨区切换地图时，将部件数据导出带过去,　如果没有数据，将nLen设为0或返回false
727 @param   
728 @param   
740 	return ExportRenewContext(pszContext,nLen);
741 }
743 /** 跨区切换地图时，将部件数据现场导入
744 @param   
745 @param   
1235 		return;
1236 	}
1238 	// 跨区副本部件
1239 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) m_pMaster->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
1240 	if (pEctypeAssistPart==NULL)
1272 	m_StrikeInfo.wLocx			= 0;					// x坐标
1273 	m_StrikeInfo.wLocy			= 0;					// y坐标
1275 	// 跨区副本部件
1276 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) m_pMaster->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
1277 	if (pEctypeAssistPart==NULL)

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MatchServer\MatchServer.cpp 290 KB CPP 文件 2014/2/25 0:08:51 2018/10/23 20:06:23 2018/10/23 20:06:23 57
102 		return false;
103 	}
105 	// 创建跨区副本助手
106 	if (m_EctypeAssist.Create() == false)
107 	{
118 		return false;
119 	}
120 	// 创建跨区竞技系统模块
121 	if (m_StrikeServer.Create() == false)
122 	{
128 		return false;
129 	}
131 	// 创建跨区战争系统模块
132 	if (m_WarServer.Create() == false)
133 	{
172 		return false;
173 	}
175 	// 订阅  跨区桥服务器连接器 MSG_MODULEID_MATCH 消息
176 	pBridgeConnector->registerMessageHandler(MSG_MODULEID_MATCH,this);
177 	// 订阅 MSG_MODULEID_MATCH 模块消息
209 	// 正在释放Release
210 	m_bRelease = true;
212 	// 取消订阅 取得跨区桥服务器连接器MSG_MODULEID_MATCH消息
213 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
214 	if (pBridgeConnector != NULL)
261 	// 关闭战场管理器
262 	m_WarManager.Release();
264 	// 关闭跨区战争系统模块
265 	m_WarServer.Release();
267 	// 关闭竞技场管理器
267 	// 关闭竞技场管理器
268 	m_StrikeManager.Release();
270 	// 关闭跨区竞技系统模块
271 	m_StrikeServer.Release();
273 	// 关闭跨服竞技撮合系统模块
279 	// 关闭公共区遣返模块
280 	m_PublicWatcher.Close();
282 	// 关闭跨区副本助手
283 	m_EctypeAssist.Close();
285 	delete this;
3574 }*/
3576 //////////////////////////////////////////////////////////////////////////
3578 /** 创建跨区副本部件
3579 */
3580 IEctypeAssistPart* CMatchServer::CreateEctypeAssistPart()
3588 	return new CPersonStrikePart();
3589 }
3592 /** 取得跨区副本助手
3593 */
3594 IEctypeAssist* CMatchServer::GetEctypeAssist()
3604 	return &m_StrikeMatch;
3605 }
3607 /** 取得跨区竞技系统接口
3608 */
3609 IStrikeServer* CMatchServer::GetStrikeServer()
3619 	return &m_StrikeManager;
3620 }
3622 /** 取得跨区战争系统接口
3623 */
3624 IWarServer* CMatchServer::GetWarServer()
3662 }
3665 //////////////////////////////////////////////////////////////////////////
3667 /** 取得跨区副本助手
3668 */
3669 CEctypeAssist& CMatchServer::GetEctypeAssistInstance()
3677 	return m_StrikeMatch;
3678 }
3680 /** 取得跨区竞技系统
3681 */
3682 CStrikeServer& CMatchServer::GetStrikeServerInstance()
3698 	return m_mapStrikeSceneSchemeList;
3699 }
3701 // 取得跨区战争系统
3702 CWarServer& CMatchServer::GetWarServerInstance()
3703 {
3879 }
3880 //////////////////////////////////////////////////////////////////////////
3882 // 发跨区信息消息 dwServerID:服务器ID ,跨区信息专用
3883 bool CMatchServer::SendDataBridgeToServer(DWORD dwServerID,WORD wKeyAction,DWORD dwMsgCode,DWORD dwUserData1,DWORD dwUserData2,DWORD dwUserData3,const char * pData,DWORD dwLen)
3884 {
5161 		return false;
5162 	}
5164 	// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
5165 	return SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_SUBMSG,Match_SubMsg_RequestCancelMatch,pPerson->GetNumProp(CREATURE_PROP_PDBID),pPerson->GetFromGameWorldID(),dwReason);
5166 }
5192 		return false;
5193 	}
5195 	// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
5196 	return SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_SUBMSG,Match_SubMsg_RequestAcceptMatch,pPerson->GetNumProp(CREATURE_PROP_PDBID),pPerson->GetFromGameWorldID(),dwFlag);
5197 }
5222 		return false;
5223 	}
5225 	// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
5226 	return SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_SUBMSG,Match_SubMsg_RequestTeamInfo,pPerson->GetNumProp(CREATURE_PROP_PDBID),pPerson->GetFromGameWorldID(),0);
5227 }
5226 	return SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_SUBMSG,Match_SubMsg_RequestTeamInfo,pPerson->GetNumProp(CREATURE_PROP_PDBID),pPerson->GetFromGameWorldID(),0);
5227 }
5230 /** 请求跨区查看玩家装备
5231 @param  const char * pData	: 请求消息数据
5232 @param  DWORD dwLen			: 请求消息数据长度
5239 		return false;
5240 	}
5241 	// 跨区查看玩家装备
5242 	SMsgActionWorldLookEquip_SC *pMsg = (SMsgActionWorldLookEquip_SC *)pData;
5244 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
5255 		if (dwSendServerID>0)
5256 		{
5257 			// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
5258 			SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_SUBMSG,Match_SubMsg_RequestLookWorldEquip,pMsg->dwPDBID,getThisGameWorldID(),0,pData,dwLen);
5259 		}
5266 		if (dwSendServerID>0)
5267 		{
5268 			// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
5269 			SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_SUBMSG,Match_SubMsg_RequestLookWorldEquip,pMsg->dwPDBID,getThisGameWorldID(),0,pData,dwLen);
5270 		}
5331 		return false;
5332 	}
5334 	// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
5335 	return SendDataBridgeToServer(dwSendServerID,
5336 								  MSG_MATCH_DATE_SUBMSG,
5491 	return NULL;
5492 }
5494 /** 取得跨区世界文明等级
5495 @param  DWORD dwWorldID		: 游戏世界ID
5495 @param  DWORD dwWorldID		: 游戏世界ID
5496 @return  DWORD 跨区世界文明等级
5497 */
5498 DWORD CMatchServer::GetWorldCivilGrade(DWORD dwWorldID)
5528 	return pBridgeCountry->GetCivilGrade();
5529 }
5531 /** 取得跨区世界文明点数
5532 @param  DWORD dwWorldID		: 游戏世界ID
5532 @param  DWORD dwWorldID		: 游戏世界ID
5533 @return  DWORD 跨区世界文明点数
5534 */
5535 DWORD CMatchServer::GetWorldCivilDot(DWORD dwWorldID)
5608 		return;
5609 	}
5610 	// 跨区副本部件
5611 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
5612 	if (NULL==pEctypeAssistPart)
5672 	}
5673 }
5675 // 请求跨区查看玩家装备
5676 void CMatchServer::OnMsgRequestLookWorldEquip(DWORD dwActorID,DWORD dwWorldID,DWORD dwFromServerID,const char * pData,DWORD dwLen)
5677 {
5680 		return;
5681 	}
5682 	// 跨区查看玩家装备
5683 	SMsgActionWorldLookEquip_SC *pMsg = (SMsgActionWorldLookEquip_SC *)pData;
5685 	if (dwActorID!=pMsg->dwPDBID || pMsg->dwFromPDBID==0)
5708 	{
5709 		// 发送给指定来源服务器
5710 		// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
5711 		SendDataBridgeToServer(dwFromServerID,MSG_MATCH_DATE_SUBMSG,Match_SubMsg_LookWorldEquipResult,pMsg->dwFromPDBID,pMsg->dwFromWorldID,(DWORD)nGetLens,(const char *)pBufData,(DWORD)nGetLens);
5712 	}
5903 	}
5905 	SMsgMatchItemNode * pMatchItem = (SMsgMatchItemNode *)(pData+sizeof(SMsgMatchRequestInfo_CS));
5907 	// 跨区副本部件
5908 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
5909 	if (NULL==pEctypeAssistPart)
6093 				if (dwSendServerID>0)
6094 				{
6095 					// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
6096 					SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_SUBMSG,Match_SubMsg_RequestAddMatch,dwMatchTypeID,dwFindTeamID,0,obufData.data(),obufData.size());
6097 				}
6273 	}
6275 	SMsgMatchItemNode * pMatchItem = (SMsgMatchItemNode *)(pData+sizeof(SMsgMatchRequestInfo_CS));
6277 	// 跨区副本部件
6278 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
6279 	if (NULL==pEctypeAssistPart)
6499 				if (dwSendServerID>0)
6500 				{
6501 					// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
6502 					SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_SUBMSG,Match_SubMsg_RequestAddTeamMatch,dwMatchTypeID,dwMatchCaptain,dwTeamerCounts,obufData.data(),obufData.size());
6503 				}
6613 }
6615 //////////////////IBridgeMessageHandler////////////////////////////////////////////////////////
6617 /** 处理跨区桥服务器发过来的消息
6618 @name         : 处理其他服务器通过跨区桥服务器转发的消息
6619 @param actionId  : 消息码
6620 @param bridgeHead  : 桥消息头
6632 		}
6633 		break;
6634 	case MSG_MATCH_KQE:		// 跨区副本助手子消息
6635 		{
6636 			m_EctypeAssist.HandleBridgeMessage(actionId,bridgeHead, head, data, len);
6684 		}
6685 		break;
6686 	case MSG_MATCH_KQE:				// 跨区副本助手子消息
6687 		{
6688 			m_EctypeAssist.OnTransmit(server,actionId,head,data,len);
6748 		}
6749 		break;
6750 	case MSG_MATCH_KQE:		//  跨区副本助手子消息
6751 		{
6752 			m_EctypeAssist.OnMessage(pPerson, actionId, head, data,len);
6829 		}
6830 		break;
6831 	case Match_SubMsg_LookWorldEquipResult:		// 请求跨区查看玩家装备结果
6832 		{
6833 			if (nNewlen!=pMsg->dwUserData3 || pMsg->dwUserData1==0)
6967 							if (dwSendServerID>0)
6968 							{
6969 								// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
6970 								SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_SUBMSG,Match_SubMsg_FailAddTeamerMatch,pMsg->dwUserData1,pMsg->dwUserData2,pMsg->dwUserData3);
6971 							}
6976 		}
6977 		break;
6978 	case Match_SubMsg_RequestLookWorldEquip:		// 请求跨区查看玩家装备
6979 		{
6980 			if (nNewlen!=sizeof(SMsgActionWorldLookEquip_SC))
6985 			DWORD dwWorldID		= pMsg->dwUserData2;				// 信息来源游戏世界ID
6986 			DWORD dwServerID	= pMsg->dwUserData3;				// 信息来源服务器ID,用来回消息
6988 			// 请求跨区查看玩家装备
6989 			OnMsgRequestLookWorldEquip(dwActorID,dwWorldID,dwServerID,pMsgData,nNewlen);
6990 		}
8045 			DBREQ_PARAM_ADDSERVICES_CENTERDBUSER_UPDATE reqData;
8046 			reqData.dwWorldID	= dwDBWorldID;												//游戏世界ID
8047 			reqData.dwNewWorldID= dwNewDBWorldID;											//新游戏世界ID（漂移可以跨区移民）
8048 			reqData.dwUserID	= param.dwUserID;											//账号ID
8049 			reqData.dwActorID	= param.dwActorID;											//角色ID

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MatchServer\KqEctype.cpp 22 KB CPP 文件 2014/2/25 0:08:49 2018/10/23 20:06:23 2018/10/23 20:06:23 3
5 ** 日  期:	2010-7-15
6 ** 版  本:	1.0
7 ** 描  述:	跨区副本助手
8 ** 应  用:  	
9 ********************************************************************/
130 	if (nZoneID == 0)
131 	{
132 		ErrorLn("[CKqEctype::Create] 创建跨区副本失败 dwEctypeType=" << pEctypeTeam->dwEctypeType << "难度：" << nDifficulty);
134 		for (int i = 0; i < m_nMemberCount && i < ECTYPE_MEMBER_MAXCOUNT; i ++)
135 		{
577 		return;
578 	}
580 	// 无论本区还是跨区都通过桥服务器中转，方便统一消息流向
581 	SMsgKqeCallMember_GP call;
582 	call.dwPDBID = member.dwPDBID;

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MatchServer\EctypeAssistPart.cpp 33 KB CPP 文件 2014/2/25 0:08:47 2018/10/23 20:06:22 2018/10/23 20:06:22 7
5 ** 日  期:	2010-7-15
6 ** 版  本:	1.0
7 ** 描  述:	跨区副本部件
8 ** 应  用:  	
9 ********************************************************************/
124 			if (m_Context.dwSerialID > 0)
125 			{
126 				WarningLn("[跨区副本 玩家登陆] 验证副本状态，玩家：" << m_pMaster->GetName() << " 副本序号：" << m_Context.dwSerialID << " 副本世界：" << m_Context.dwWorldID << " 服务器序号：" << m_Context.dwServerSubID);
127 				DWORD dwPDBID = m_pMaster->GetNumProp(CREATURE_PROP_PDBID);
128 				DWORD dwSrcBriServerID = pBridgeConnector->GetGameServerIDByTypeSubID(m_Context.dwWorldID, MSG_ENDPOINT_ZONE, m_Context.dwServerSubID);
258 			if (m_Context.dwSerialID > 0)
259 			{
260 				WarningLn("[跨区副本 玩家登陆] 验证副本状态，玩家：" << m_pMaster->GetName() << " 副本序号：" << m_Context.dwSerialID << " 副本世界：" << m_Context.dwWorldID << " 服务器序号：" << m_Context.dwServerSubID);
261 				DWORD dwPDBID = m_pMaster->GetNumProp(CREATURE_PROP_PDBID);
262 				DWORD dwSrcBriServerID = pBridgeConnector->GetGameServerIDByTypeSubID(m_Context.dwWorldID, MSG_ENDPOINT_ZONE, m_Context.dwServerSubID);
415 	return true;
416 }
418 /// purpose: 是否正在进行跨区副本
419 bool CEctypeAssistPart::IsEctypeing()
420 {
421 	return (m_Context.dwSerialID > 0);
422 }
424 /// purpose: 取得跨区现场
425 const SKqEctypePartContext* CEctypeAssistPart::GetEctypeContext()
426 {
427 	return &m_Context;
428 }
430 /// purpose: 设置跨区现场
431 void CEctypeAssistPart::SetEctypeContext(SKqEctypePartContext* pContext)
432 {
1077 		TEctypeAssistPartPrivateContext *pOutContext = &pRoleContext->stEctypeAssistPart;
1078 		pOutContext->nState = m_nState;
1080 		//跨区现场
1081 		TEctypePartContextData* pEctypeData = &pOutContext->stEctypePartData;
1082 		pEctypeData->dwSerialID	= m_Context.dwSerialID	;

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MatchServer\EctypeAssist.cpp 78 KB CPP 文件 2014/2/25 0:08:47 2018/10/23 20:06:22 2018/10/23 20:06:22 34
5 ** 日  期:	2010-7-15
6 ** 版  本:	1.0
7 ** 描  述:	跨区副本助手
8 ** 应  用:  	
9 ********************************************************************/
39 bool CEctypeAssist::Create(void)
40 {
41 	kqe_trace("创建跨区副本模块");
43 	IEventEngine* pEventEngine = gZoneServiceProvider->GetEventEngine();
44 	if (pEventEngine == NULL)
69 	g_pEctypeAssist = this;
70 	
71 	kqe_trace("创建跨区副本模块 成功");
72 	return true;
73 }
98 	g_pEctypeAssist = NULL;
99 }
101 /** 取得跨区副本信息
102 */
103 const SKqEctypeScheme* CEctypeAssist::GetKqEctypeScheme(WORD wTypeID)
111 	return &(it->second);
112 }
114 /** 取得跨区副本配置信息
115 */
116 const SKqEctypeConfig* CEctypeAssist::GetKqEctypeConfig()
220 	}
221 	TraceLn(osb.c_str());
223 	// 这里需要做跨区均衡处理
224 	if (pEctypeConfig->bLocalEctype == true)
225 	{
291 	if (pKqEctype->Create(dwSerial, pEctypeTeam) == false)
292 	{
293 		ErrorLn("[CreateKqEctype] 创建跨区副本对象失败, dwMatchID=" << pEctypeTeam->dwEctypeType << " dwSerial=" << dwSerial);
294 		delete pKqEctype;
295 		return false;
617 	MyTransport(pPerson, pLocInfo->dwWorldID, pLocInfo->dwSrcZoneID, ptLoc, tStarTrek_Flag_RunOnDie|tStarTrek_Flag_RunOnEctype);
618 }
620 /** 处理跨区桥服务器发过来的消息
621 */
622 void CEctypeAssist::HandleBridgeMessage(unsigned long actionId, SMsgBridgeHead &bridgeHead, SGameMsgHead* head, LPSTR data, size_t len)
694 	default:
695 		{
696 			ErrorLn("跨区副本消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
697 			break;
698 		}
762 			break;
763 		}
765 		// 跨区通知
766 	case MSG_KQE_DIDANOTIFY:
767 		{
772 	default:
773 		{
774 			ErrorLn("跨区副本消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
775 		}
776 		break;
832 	default:
833 		{
834 			ErrorLn("跨区副本消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
835 			break;
836 		}
1054 		return false;
1055 	}
1057 	// 跨区副本配置脚本
1058 	string strPath;
1059 	if (isPublicGameWorld() == true)
1075 	return true;
1076 }
1078 /// purpose:  加载跨区副本配置脚本
1079 bool CEctypeAssist::LoadKqEctypeScheme(ICSVReader * pCSVReader)
1080 {
1107 		if (nCount != 2)
1108 		{
1109 			ErrorLn("跨区副本配置脚本" << "限制开始时间 配置错误");
1110 			return false;
1111 		}
1122 		if (nCount != 2)
1123 		{
1124 			ErrorLn("跨区副本配置脚本" << "限制结束时间 配置错误");
1125 			return false;
1126 		}
1295 	return dwServerID;
1296 }
1298 /** 创建一个跨区副本序号
1299 */
1300 DWORD CEctypeAssist::CreateSerialID()
1344 		}
1345 		const SKqEctypeContext* pEctypeContext = pKqEctype->GetContext();
1347 		// 玩家进入跨区副本
1348 		if (pEctypeContext->dwZoneID == pEvent->dwNewZoneID)
1349 		{
1348 		if (pEctypeContext->dwZoneID == pEvent->dwNewZoneID)
1349 		{
1350 			kqe_trace("[玩家进入跨区副本] 玩家：" << pPerson->GetName() << "副本序号：" << pEctypeContext->dwSerialID);
1352 			SKqEctypeMember* pMember = (SKqEctypeMember*)pKqEctype->GetMemberInfoByPDBID(dwPDBID);
1353 			if (pMember == NULL)
1353 			if (pMember == NULL)
1354 			{
1355 				WarningLn("[跨区副本 场景切换] 全局表和副本内的成员表不一致，玩家ID：" << dwPDBID);
1356 				return;
1357 			}
1360 			if (pMember->bEnter == false)
1361 			{
1362 				kqe_trace("[第一次进入跨区副本] 玩家：" << pPerson->GetName() << "副本序号：" << pEctypeContext->dwSerialID);
1364 				IEctype* pEctypeObj =  pEctypeManager->findEctype(pEctypeContext->dwZoneID);
1365 				CEctypeAssistPart* pEctypeAssistPart = (CEctypeAssistPart*)pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
1385 			else
1386 			{
1387 				kqe_trace("[重复进入跨区副本] 玩家：" << pPerson->GetName() << "副本序号：" << pEctypeContext->dwSerialID);
1389 				// KqReturnToEctype(ectypeType, actor)
1390 				CLuaParam param[3];
1399 		else if (pEctypeContext->dwZoneID == pEvent->dwOldZoneID)
1400 		{
1401 			kqe_trace("[从跨区副本出去] 玩家：" << pPerson->GetName() << "副本序号：" << pEctypeContext->dwSerialID << "场景ID：" << pEctypeContext->dwZoneID);
1403 			// KqGoOutEctype(ectypeType, actor, oldZoneID, newZoneID)
1404 			CLuaParam param[5];
1471 		return;
1472 	}
1473 	kqe_trace("[跨区副本 玩家登陆] 玩家：" << pPerson->GetName());
1474 	const SKqEctypePartContext*  pContext = pEctypeAssistPart->GetEctypeContext();	
1475 	// 如果玩家在副本状态，到副本所在的场景服验证是否有效
1486 			const SKqEctypeContext* pEctypeContext = pKqEctype->GetContext();
1487 			DWORD dwNewZoneID = pPerson->GetZoneID();
1489 			// 玩家进入跨区副本
1490 			if (pEctypeContext->dwZoneID == dwNewZoneID)
1491 			{
1490 			if (pEctypeContext->dwZoneID == dwNewZoneID)
1491 			{
1492 				kqe_trace("[登陆进入跨区副本] 玩家：" << pPerson->GetName() << "副本序号：" << pEctypeContext->dwSerialID << " 副本场景：" << dwNewZoneID);
1494 				SKqEctypeMember* pMember = (SKqEctypeMember*)pKqEctype->GetMemberInfoByPDBID(dwPDBID);
1495 				if (pMember == NULL)
1495 				if (pMember == NULL)
1496 				{
1497 					WarningLn("[登陆进入跨区副本 场景切换] 全局表和副本内的成员表不一致，玩家ID：" << dwPDBID);
1498 					return;
1499 				}
1502 				if (pMember->bEnter == false)
1503 				{
1504 					kqe_trace("[第一次进入跨区副本] 玩家：" << pPerson->GetName() << "副本序号：" << pEctypeContext->dwSerialID);
1506 					IEctype* pEctypeObj =  pEctypeManager->findEctype(pEctypeContext->dwZoneID);
1507 					CEctypeAssistPart* pEctypeAssistPart = (CEctypeAssistPart*)pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
1529 				else
1530 				{
1531 					kqe_trace("[重复进入跨区副本] 玩家：" << pPerson->GetName() << "副本序号：" << pEctypeContext->dwSerialID);
1533 					// KqReturnToEctype(ectypeType, actor, serialID)
1534 					CLuaParam param[3];
1597 		return;
1598 	}
1599 	// 跨区副本部件
1600 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
1601 	if (NULL==pEctypeAssistPart)
1661 void CEctypeAssist::OnClientGoEctype(IPerson* pPerson, SMsgMatchDataSubMsg* pSubMsg, LPSTR pszMsg, size_t nLen)
1662 {
1663 	kqe_trace("[前往跨区副本] 玩家：" << pPerson->GetName());
1665 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
1666 	if (pBridgeConnector == NULL)
1772 	}
1773 }
1775 // 创建一个跨区副本
1776 void CEctypeAssist::OnTransmitCreateEctype(DWORD dwServerID, SMsgMatchDataSubMsg* pSubMsg, LPSTR pszMsg, size_t nLen)
1777 {
1879 		return;
1880 	}
1882 	// 把玩家设置成跨区副本状态
1883 	SKqEctypePartContext context;
1884 	context.dwEctypeType = pCall->dwEctypeType;
2088 	}
2090 	// TODOTODO 提示下
2092 	// 把玩家设置成跨区副本状态
2093 	pEctypeAssistPart->SetEctypeContext(pContext);
2095 	// 传送到公共区的副本 TODOTODO

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MatchServer\DummyServer.cpp 23 KB CPP 文件 2014/2/25 0:08:46 2018/10/23 20:06:22 2018/10/23 20:06:22 4
448 		return;
449 	}
451 	// 跨区副本部件
452 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
453 	if (NULL==pEctypeAssistPart)
564 		return;
565 	}
567 	// 跨区副本部件
568 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
569 	if (NULL==pEctypeAssistPart)
741 }
743 //////////////////////////////////////////////////////////////////////////
745 /** 处理跨区桥服务器发过来的消息
746 @name         : 处理其他服务器通过跨区桥服务器转发的消息
747 @param actionId  : 消息码
748 @param bridgeHead  : 桥消息头

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MatchServer\Dummy.cpp 45 KB CPP 文件 2014/2/25 0:08:44 2018/10/23 20:06:22 2018/10/23 20:06:22 3
674 		return false;
675 	}
677 	// 跨区副本部件
678 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
679 	if (NULL==pEctypeAssistPart)
903 		return false;
904 	}
906 	// 跨区副本部件
907 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
908 	if (NULL==pEctypeAssistPart)
1512 		return;
1513 	}
1514 	// 跨区副本部件
1515 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
1516 	if (NULL==pEctypeAssistPart)

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MatchServer\CountryWar.cpp 208 KB CPP 文件 2014/2/25 0:08:44 2018/10/23 20:06:22 2018/10/23 20:06:22 1
5858 		return 0;
5859 	}
5860 	// 取得跨区竞技部件指针
5861 	IPersonStrikePart *pPersonStrikePart = (IPersonStrikePart *)pPerson->GetEntityPart(ENTITYPART_PERSON_STRIKE);
5862 	if (pPersonStrikePart == NULL)

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MatchServer\CGameMatchAPI.cpp 148 KB CPP 文件 2014/2/25 0:08:39 2018/10/23 20:06:21 2018/10/23 20:06:21 21
134 	return pMatchServer->GetWarConfigName(dwConfigNameType);
135 };
137 /**  取得跨区战争系统
138 @param   
138 @param   
139 @return  取得跨区战争系统
140 */
141 IWarServer * CGameMatchAPI::GetWarServer()
149 	return pMatchServer->GetWarServer();
151 }
155 //========================================================跨区副本API==================================================
157 /** 取得某个玩家的副本ID
158 @return 副本序号
167 	return g_pEctypeAssist->GetKqEctypeID(dwPDBID);
168 }
170 /** 取得跨区副本现场
171 @param dwSerialID 副本序号
172 */
186 	return pKqEctype->GetContext();
187 }
189 /** 取得跨区副本成员个数
190 @param dwSerialID 副本序号
191 */
205 	return pKqEctype->GetMemberCount();
206 }
208 /** 取得跨区副本成员信息
209 @param dwSerialID 副本序号
210 */
224 	return pKqEctype->GetMemberInfo(nIndex);
225 }
227 /** 取得跨区副本成员信息
228 @param dwSerialID 副本序号
229 */
243 	return pKqEctype->GetMemberInfoByPDBID(dwPDBID);
244 }
246 /** 跨区副本结束
247 @param dwSerialID 副本序号
248 */
263 	pKqEctype->Release();*/
264 }
266 /** 跨区副本结束
267 @param nActor		玩家序列号
268 @param wEctypeType	副本类型
283 	return g_pEctypeAssist->CanEctype(pPerson->GetUID(), wEctypeType);
284 }
286 /** 取得玩家跨区部件身上的副本序号
287 @param nActor		玩家序列号
288 @param wEctypeType	副本类型
319 	return 0;
320 }
322 /** 进入跨区副本
323 @param nActor		玩家序列号
324 */
333 	g_pEctypeAssist->GoEctype(pPerson);
334 }
336 /** 离开跨区副本
337 @param nActor		玩家序列号
338 */
394 SGlobalEctypeTeam g_GlobalEctypeTeam;
395 int g_nTestKqeMemberCount;
397 /** 创建跨区副本 开始
398 @param dwEctypeType	 副本类型
399 @param nDifficulty	 副本难度
411 	g_GlobalEctypeTeam.nTeamID = nTeamID;
412 }
414 /** 创建跨区副本 添加成员
415 @param dwPDBID	 副本类型
416 @param dwWorldID 副本难度
434 	}
435 }
437 /** 创建跨区副本 完成
438 */ 
439 int CGameMatchAPI::NewKqeEnd()
447 	return g_pEctypeAssist->AcceptEctypeTeam(&g_GlobalEctypeTeam);
449 }
451 /** 到社会服创建跨区副本 完成
452 */ 
453 int CGameMatchAPI::SocialNewKqeEnd()
1609 	return true;
1610 }
1612 ///////////// 跨区战场API /////////////////////////////////////////////////////////////
1614 /** 用现场创建跨服国战
1615 @param  DWORD dwWarTypeID		: 战场场类型 EMWarItemType
2065 		return 0;
2066 	}
2068 	// 判断是否是跨区国战类型
2069 	if (pWar->GetWarMode() != dwWaMode)
2070 	{
3832 		return false;
3833 	}
3834 	// 判断是否是跨区国战类型
3835 	if (!pWar->GetPVPClass()->IsWar())
3836 	{
3837 		return false;
3838 	}
3840 	// 判断是否是跨区国战类型
3841 	if (!pWar->GetWarMode() == WarMode_Country)
3842 	{
4014 		return 0;
4015 	}
4017 	// 判断是否是跨区国战类型
4018 	if (!pWar->GetWarMode() == WarMode_Country)
4019 	{

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MatchServer\BudoServer.cpp 52 KB CPP 文件 2014/2/25 0:08:37 2018/10/23 20:06:21 2018/10/23 20:06:21 4
242 		return;
243 	}
245 	// 跨区副本部件
246 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
247 	if (NULL==pEctypeAssistPart)
1143 }
1145 //////////////////////////////////////////////////////////////////////////
1147 /** 处理跨区桥服务器发过来的消息
1148 @name         : 处理其他服务器通过跨区桥服务器转发的消息
1149 @param actionId  : 消息码
1150 @param bridgeHead  : 桥消息头
1470 		return;
1471 	}
1473 	// 跨区副本部件
1474 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
1475 	if (NULL==pEctypeAssistPart)

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MatchServer\Budo.cpp 83 KB CPP 文件 2014/2/25 0:08:35 2018/10/23 20:06:21 2018/10/23 20:06:21 2
711 		return false;
712 	}
714 	// 跨区副本部件
715 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
716 	if (NULL==pEctypeAssistPart)
2667 		return;
2668 	}
2670 	// 跨区副本部件
2671 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
2672 	if (NULL==pEctypeAssistPart)

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MarryServer\TeachStudPart.cpp 30 KB CPP 文件 2014/2/25 0:08:29 2018/10/23 20:06:20 2018/10/23 20:06:20 2
395 // 	return true;
396 }
398 /** 跨区切换地图时，将部件数据导出带过去,　如果没有数据，将nLen设为0或返回false
399 @param   
400 @param   
432 	return true;
433 }
435 /** 跨区切换地图时，将部件数据现场导入
436 @param   
437 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MarryServer\StockPart.cpp 27 KB CPP 文件 2014/2/25 0:08:27 2018/10/23 20:06:20 2018/10/23 20:06:20 2
310 // 	return true;
311 }
313 /** 跨区切换地图时，将部件数据导出带过去,　如果没有数据，将nLen设为0或返回false
314 @param   
315 @param   
344 	return true;
345 }
347 /** 跨区切换地图时，将部件数据现场导入
348 @param   
349 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MarryServer\SecurityPart.cpp 55 KB CPP 文件 2014/2/25 0:08:25 2018/10/23 20:06:19 2018/10/23 20:06:19 2
718 // 	return true;
719 }
721 /** 跨区切换地图时，将部件数据导出带过去,　如果没有数据，将nLen设为0或返回false
722 @param   
723 @param   
748 	return true;
749 }
751 /** 跨区切换地图时，将部件数据现场导入
752 @param   
753 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MarryServer\RoleVendedPart.cpp 41 KB CPP 文件 2014/2/25 0:08:22 2018/10/23 20:06:19 2018/10/23 20:06:19 2
464 // 	return true;
465 }
467 /** 跨区切换地图时，将部件数据导出带过去,　如果没有数据，将nLen设为0或返回false
468 @param   
469 @param   
481 	return	ExportRenewContext(pszContext, nLen);
482 }
484 /** 跨区切换地图时，将部件数据现场导入
485 @param   
486 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MarryServer\ResAdjustPart.cpp 13 KB CPP 文件 2014/2/25 0:08:21 2018/10/23 20:06:18 2018/10/23 20:06:18 3
340 // 	return true;
341 }
343 /** 跨区切换地图时，将部件数据导出带过去,　如果没有数据，将nLen设为0或返回false
344 @param   
345 @param   
379 	return true;
380 }
382 /** 跨区切换地图时，将部件数据现场导入
383 @param   
384 @param   
531 	}
532 }
534 /** 设置跨区用值
535 @param   
536 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MarryServer\MiscPart.cpp 73 KB CPP 文件 2014/2/25 0:08:17 2018/10/23 20:06:17 2018/10/23 20:06:17 2
773 // 	return true;
774 }
776 /** 跨区切换地图时，将部件数据导出带过去,　如果没有数据，将nLen设为0或返回false
777 @param   
778 @param   
813 	return true;
814 }
816 /** 跨区切换地图时，将部件数据现场导入
817 @param   
818 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MarryServer\MarryPart.cpp 79 KB CPP 文件 2014/2/25 0:08:15 2018/10/23 20:06:17 2018/10/23 20:06:17 2
718 	return true;
719 }
721 /** 跨区切换地图时，将部件数据导出带过去,　如果没有数据，将nLen设为0或返回false
722 @param   
723 @param   
736 	return false; 
737 }
739 /** 跨区切换地图时，将部件数据现场导入
740 @param   
741 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MarryServer\InvitePart.cpp 64 KB CPP 文件 2014/2/25 0:08:13 2018/10/23 20:06:16 2018/10/23 20:06:16 2
633 // 	return true;
634 }
637 /** 跨区切换地图时，将部件数据导出带过去,　如果没有数据，将nLen设为0或返回false
638 @param   
639 @param   
704 	return true;
705 }
707 /** 跨区切换地图时，将部件数据现场导入
708 @param   
709 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MarryServer\CreditPart.cpp 39 KB CPP 文件 2014/2/25 0:08:06 2018/10/23 20:06:15 2018/10/23 20:06:15 2
447 	return true;
448 }
450 /** 跨区切换地图时，将部件数据导出带过去,　如果没有数据，将nLen设为0或返回false
451 @param   
452 @param   
465 	return false; 
466 }
468 /** 跨区切换地图时，将部件数据现场导入
469 @param   
470 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MarryServer\CardCollectPart.cpp 42 KB CPP 文件 2014/2/25 0:08:03 2018/10/23 20:06:14 2018/10/23 20:06:14 2
535 // 	return true;
536 }
538 /** 跨区切换地图时，将部件数据导出带过去,　如果没有数据，将nLen设为0或返回false
539 @param   
540 @param   
552 	return	ExportRenewContext(pszContext, nLen);
553 }
555 /** 跨区切换地图时，将部件数据现场导入
556 @param   
557 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\LuaServer\LuaServer.cpp 11 KB CPP 文件 2014/2/25 0:09:21 2018/10/23 20:06:05 2018/10/23 20:06:05 1
237 }
239 /**
240 @name         : 处理其他服务器通过跨区桥服务器转发的消息
241 @param actionId  : 消息码
242 @param bridgeHead  : 桥消息头

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\LuaServer\GameMatchAPI.cpp 68 KB CPP 文件 2014/2/25 0:09:17 2018/10/23 20:06:04 2018/10/23 20:06:04 17
123 	return pMatchServer->GetWarConfigName(dwConfigNameType);
124 };
126 /**  取得跨区战争系统
127 @param   
127 @param   
128 @return  取得跨区战争系统
129 */
130 IWarServer * GetWarServer()
138 	return pMatchServer->GetWarServer();
140 }
144 //========================================================跨区副本API==================================================
146 /** 取得某个玩家的副本ID
147 @return 副本序号
151 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->GetKqEctypeID(dwPDBID);
152 }
154 /** 取得跨区副本现场
155 @param dwSerialID 副本序号
156 */
159 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->GetKqeContext(dwSerialID);
160 }
162 /** 取得跨区副本成员个数
163 @param dwSerialID 副本序号
164 */
167 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->GetKqeMemberCount(dwSerialID) ;
168 }
170 /** 取得跨区副本成员信息
171 @param dwSerialID 副本序号
172 */
175 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->GetKqeMemberInfo(dwSerialID, nIndex) ;
176 }
178 /** 取得跨区副本成员信息
179 @param dwSerialID 副本序号
180 */
183 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->GetKqeMemberInfoByPDBID(dwSerialID, dwPDBID) ;
184 }
186 /** 跨区副本结束
187 @param dwSerialID 副本序号
188 */
191 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->KqEctypeEnd(dwSerialID);
192 }
194 /** 跨区副本结束
195 @param nActor		玩家序列号
196 @param wEctypeType	副本类型
200 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->CanKqEctype(nActor, wEctypeType);
201 }
203 /** 取得玩家跨区部件身上的副本序号
204 @param nActor		玩家序列号
205 @param wEctypeType	副本类型
209 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->GetKqEctypeIDByActor(nActor, wEctypeType);
210 }
212 /** 进入跨区副本
213 @param nActor		玩家序列号
214 */
217 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->EnterKqEctype(nActor);
218 }
220 /** 离开跨区副本
221 @param nActor		玩家序列号
222 */
233 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->KqeSetCurZoneID(dwSerialID, dwZoneID);
234 }
237 /** 创建跨区副本 开始
238 @param dwEctypeType	 副本类型
239 @param nDifficulty	 副本难度
245 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->NewKqeBegin(dwEctypeType, nDifficulty, nCaptainIndex, nTeamID);
246 }
248 /** 创建跨区副本 添加成员
249 @param dwPDBID	 副本类型
250 @param dwWorldID 副本难度
256 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->NewKqeAddMember(dwPDBID, dwWorldID,  nLevel, szName, bOnlyTransport);
257 }
259 /** 创建跨区副本 完成
260 */ 
261 int NewKqeEnd()
263 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->NewKqeEnd();
264 }
266 /** 到社会服创建跨区副本 完成
267 */ 
268 int SocialNewKqeEnd()
760 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->ActorStrikeUseXPSkill( dwActorID,  dwSkillID,  dwSkillSubID);
761 }
763 ///////////// 跨区战场API /////////////////////////////////////////////////////////////
765 /** 用现场创建跨服国战
766 @param  DWORD dwWarTypeID		: 战场场类型 EMWarItemType

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\LuaServer\GameEngineAPI.cpp 220 KB CPP 文件 2014/2/25 0:09:13 2018/10/23 20:06:04 2018/10/23 20:06:04 1
1251 }
1253 /**
1254 @name            : 创建人物完成跨区笑傲江湖任务
1255 @brief           : 
1256 @param szCallFunc: 回调函数名

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\GameResCreator\DropPrizeCreator.cpp 138 KB CPP 文件 2014/2/25 0:08:08 2018/10/23 20:05:06 2018/10/23 20:05:06 1
4378 				return;
4379 			}
4380 /* 由于现在跨区，资源等级从部件等地直接获取，所以这里要是没有了应该是没有问题的
4381 			SMsgResAdjustSyncCivil* pMsg = (SMsgResAdjustSyncCivil*)pszContext;
4382 			if (pMsg->nCivilGrade<=0 || pMsg->nCivilGrade>CIVIL_MAX_LEVEL)

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\EntityServer\PersonPropBank.cpp 192 KB CPP 文件 2014/2/25 0:07:37 2018/10/23 20:04:44 2018/10/23 20:04:44 2
3637 	return m_pGameZone;
3638 }
3640 /** 跨区切换地图时，将临时小型数据导出带过去, 如果没有数据，将nLen设为0或返回false
3641 @param   
3642 @param   
3648 	return false;
3649 }
3651 /** 跨区切换地图时，将临时小型数据导入
3652 @param   
3653 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\EntityServer\PersonMountingPart.cpp 15 KB CPP 文件 2014/2/25 0:07:33 2018/10/23 20:04:43 2018/10/23 20:04:43 2
441 // 	return false;
442 }
445 /** 跨区切换地图时，将部件数据导出带过去,　如果没有数据，将nLen设为0或返回false
446 @param   
447 @param   
459 	return ExportRenewContext(pszContext,nLen);
460 }
462 /** 跨区切换地图时，将部件数据现场导入
463 @param   
464 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\EntityServer\PersonBattleRidePart.cpp 224 KB CPP 文件 2014/2/25 0:07:30 2018/10/23 20:04:40 2018/10/23 20:04:40 2
3484 // 	return true;
3485 }
3488 /** 跨区切换地图时，将部件数据导出带过去,　如果没有数据，将nLen设为0或返回false
3489 @param   
3490 @param   
3502 	return ExportRenewContext(pszContext,nLen);
3503 }
3505 /** 跨区切换地图时，将部件数据现场导入
3506 @param   
3507 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\EntityServer\Person.cpp 54 KB CPP 文件 2014/2/25 0:07:28 2018/10/23 20:04:40 2018/10/23 20:04:40 2
745 	return m_PersonPropBank.ExportDetailContext(pszContext, nLen);
746 }
748 /** 跨区切换地图时，将临时小型数据导出带过去, 如果没有数据，将nLen设为0或返回false
749 @param   
750 @param   
755 	return m_PersonPropBank.ExportTrekContext(pszContext, nLen);
756 }
758 /** 跨区切换地图时，将临时小型数据导入
759 @param   
760 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\EntityServer\EntityServer.cpp 129 KB CPP 文件 2014/2/25 0:07:07 2018/10/23 20:04:32 2018/10/23 20:04:32 15
372 	return pNewEntity;	
373 }
375 /** 通过跨区数据构造实体(只限人物)
376 @param   
377 @param   
395 		buildproc[dwEntityClass] == NULL)
396 	{
397 		Error("通过跨区数据构造实体失败！场景ID = " << dwZoneID << "，EntityClass = " << dwEntityClass << endl);
398 		return NULL;
399 	}
411 	else
412 	{
413 		Error("通过跨区数据构造实体失败！场景ID = " << dwZoneID << "，EntityClass = " << dwEntityClass << endl);
414 		return NULL;
415 	}
1210 	}
1211 	pPerson->AddEntityPart(pArenaPart);
1213 	// 创建跨区副本部件
1214 	IEctypeAssistPart* pEctypeAssistPart = gZoneServiceProvider->GetMatchServer()->CreateEctypeAssistPart();
1215 	FiltPersonContext(nLoginMode, ENTITYPART_PERSON_ECTYPEASSIST, pszContext, nLen, pszDest, nDestLen);
1216 	if(!pEctypeAssistPart->Create(pPerson, pszDest, nDestLen, nLoginMode))
1217 	{
1218 		TRACE_NEWPERSON_FAILED("构建跨区副本部件");
1219 		pPerson->Clean();
1220 		SAFE_RELEASE(pEctypeAssistPart);
1932 		return NULL;
1933 	}
1935 	// 创建跨区副本部件
1936 	IEntityPart* pEctypeAssistPart = pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
1937 	FiltPersonContext(nLoginMode, ENTITYPART_PERSON_ECTYPEASSIST, pszContext, nLen, pszDest, nDestLen);
1938 	if(!pEctypeAssistPart->Create(pPerson, pszDest, nDestLen, nLoginMode))
1939 	{
1940 		TRACE_REUSERPERSON_FAILED("创建跨区副本部件");
1942 		pPerson->Restore();
1944 		return NULL;
3569 			}
3570 			break;
3571 		case ENTITYPART_PERSON_ECTYPEASSIST: // 跨区副本部件
3572 			{
3573 				pszDest = (LPSTR)pSrc->byKqEctypeData; nDestLen = sizeof(pSrc->byKqEctypeData);
3574 			}
3575 			break;
3576 		case ENTITYPART_PERSON_STRIKE: // 跨区竞技部件
3577 			{
3578 				pszDest = (LPSTR)pSrc->byStrikeData; nDestLen = sizeof(pSrc->byStrikeData);
3727 			}
3728 			break;
3729 		case ENTITYPART_PERSON_ECTYPEASSIST: // 跨区副本部件
3730 			{
3731 				pszDest = (LPSTR)pSrc->byKqEctypeData; nDestLen = sizeof(pSrc->byKqEctypeData);
3737 			}
3738 			break;
3739 		case ENTITYPART_PERSON_STRIKE: // 跨区竞技部件
3740 			{
3741 				pszDest = (LPSTR)pSrc->byStrikeData; nDestLen = sizeof(pSrc->byStrikeData);
4525 		return NULL;
4526 	}
4528 	// 创建跨区副本部件
4529 	IEntityPart* pEctypeAssistPart = pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
4530 	if(!pEctypeAssistPart->Create_ORM(pPerson, pszDest, nDestLen, nLoginMode))
4530 	if(!pEctypeAssistPart->Create_ORM(pPerson, pszDest, nDestLen, nLoginMode))
4531 	{
4532 		TRACE_REUSERPERSON_FAILED("创建跨区副本部件");
4534 		pPerson->Restore();
4536 		return NULL;
5078 	}
5079 	
5081 	// 创建跨区副本部件
5082 	IEctypeAssistPart* pEctypeAssistPart = gZoneServiceProvider->GetMatchServer()->CreateEctypeAssistPart();	
5083 	if(!pPerson->AddEntityPart(pEctypeAssistPart))
5083 	if(!pPerson->AddEntityPart(pEctypeAssistPart))
5084 	{
5085 		ErrorLn("构建跨区副本部件失败");		
5086 		SAFE_RELEASE(pPerson);
5087 		return NULL;

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\EntityServer\CreatureCommonPart.cpp 128 KB CPP 文件 2014/2/25 0:06:56 2018/10/23 20:04:27 2018/10/23 20:04:27 2
3203 					return;
3204 				}
3205 				// 跨区查看玩家装备
3206 				SMsgActionWorldLookEquip_SC sendData;
3207 				sendData.dwPDBID		= pMsg->dwPDBID;		// 看谁的PDBID
3322 				//	return;
3323 				//}
3324 				//// 跨区查看玩家装备
3325 				//SMsgActionWorldLookEquip_SC sendData;
3326 				//sendData.dwPDBID		= pMsg->dwPDBID;		// 看谁的PDBID

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\EnterManager\SaveActorToVan.cpp 55 KB CPP 文件 2014/2/25 0:06:42 2018/10/23 20:04:22 2018/10/23 20:04:22 15
119 		}
120 	}
124 	//     ORM改造, 目前不考虑跨区切换流程, 这个代码先屏蔽, 以后考虑跨区时再定详细方案
125 // 	如果跨区切换，此处要把人物坐标替换成迁入游戏世界的地图ID和位置，迁入游戏世界登陆服才能方读到相应的位置
126 // 		if(nType == ESaveToVan_Type_StarTrek && pContext != NULL && nContextLen == sizeof(SStarTrekContext))
127 // 		{
446 					 2：定时缓存、不存入数据库、不解锁
447 					 3：定时保存、要存入数据库、不解锁
448 @param   pContext   ：跨区用扩展数据
449 @param   nContextLen：跨区用扩展数据长度
450 @param   nOutContextLen：切换进程导出数据
451 @param   nOutLen    ：切换进程最大可导出数据长度
490 	else if(nType == ESaveToVan_Type_StarTrek)
491 	{
492 		sprintf_s(szLogoutDesc, "%s跨区切换，pdbid=%d，", pMaster->GetName(), dwPDBID);
493 	}
494 	else
562 		}
563 	}
565 	// 如果跨区切换，此处要把人物坐标替换成迁入游戏世界的地图ID和位置，迁入游戏世界登陆服才能方读到相应的位置
566 	if(nType == ESaveToVan_Type_StarTrek && pContext != NULL && nContextLen == sizeof(SStarTrekContext))
567 	{
750 		return -1;
751 	}
753 	// 跨区副本数据
754 	IEntityPart * pKqEctypePart = pMaster->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
755 	nSaveLen = sizeof(reqsaveactor.byKqEctypeData);
756 	if(!pKqEctypePart->ExportDBContext((LPSTR)reqsaveactor.byKqEctypeData, nSaveLen))
757 	{
758 		EmphasisLn(szLogoutDesc<<"导出跨区副本数据失败！");
759 		return false;
760 	}
759 		return false;
760 	}
762 	// 跨区竞技PK数据
763 	IEntityPart * pStrikePart = pMaster->GetEntityPart(ENTITYPART_PERSON_STRIKE);
764 	nSaveLen = sizeof(reqsaveactor.byStrikeData);
765 	if(!pStrikePart->ExportDBContext((LPSTR)reqsaveactor.byStrikeData, nSaveLen))
766 	{
767 		EmphasisLn(szLogoutDesc<<"导出跨区竞技PK数据失败！");
768 		return false;
769 	}
1485 	}
1486 }
1488 /** 获取跨区切换的现场
1489 @param   
1490 @param   
1555 		if(!ofixb.good())
1556 		{
1557 			ErrorLn("跨区切换场景失败...获取现场给出buffer太小! partid="<<iPart);
1558 			debugBreak;
1560 			return -1;
1564 	if(!ofixb.good())
1565 	{
1566 		ErrorLn("跨区切换场景失败...获取现场给出buffer太小!");
1567 		debugBreak;
1569 		return -1;
1693 	case ESaveToVan_Type_StarTrek:  // 距区切换、要存入数据库、解锁
1694 		{
1695 			ErrorLn("CSaveActorHelper::SaveToVan  跨区切换暂不支持   Actor:" << pMaster->GetName());
1696 			return DBSVR::INVALID_TRANSACTID;;
1697 		}

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\EnterManager\LoginTransmit.cpp 7 KB CPP 文件 2014/2/25 0:06:40 2018/10/23 20:04:22 2018/10/23 20:04:22 1
142 			else
143 			{
144 				TraceLn("[跨区]玩家登入场景服PDBID="<<pMsg->dwActorDBID<<" clientid="<<pMsg->dwClientID<<" UDBID="<<pMsg->dwUserID);
146 				CTerminalTunnel * pTerminalTunnel = new CTerminalTunnel();				
147 				pTerminalTunnel->Create(pMsg->dwClientID);

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\EnterManager\EnterManager.cpp 35 KB CPP 文件 2014/2/25 0:06:36 2018/10/23 20:04:20 2018/10/23 20:04:20 1
1059 	}
1061 }
1063 /** 获取跨区切换的现场
1064 @param   
1065 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\EnterManager\DBRetSinkSetUserLockForTrek.cpp 15 KB CPP 文件 2014/2/25 0:06:35 2018/10/23 20:04:20 2018/10/23 20:04:20 25
71 	if(nFromGameWorldID <= 0)
72 	{
73 		ErrorLn("[跨区]严重问题!加锁返回后取得的FromGameWorldID无效,UDBID="<<nQueueIndex);
74 	}
75 	g_CancelUserSolidLock.EraseFromGameWorldIDForShoot(nQueueIndex);
78 	if(pTerminalTunnel == NULL)
79 	{
80 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, m_nExecuteGameWorldID, "[跨区]TerminalTunnel返回时已无效");
81 		return;
82 	}
85 	{
86 		char szUnlockReason[1024] = { 0 };
87 		sprintf_s(szUnlockReason, "[跨区]加永久锁时DB返回失败, DBError Desc=%s", pszDBRetDesc);
88 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, m_nExecuteGameWorldID, szUnlockReason);
89 		pTerminalTunnel->Kickout(EKickoutClient_Reason_StarTrekFailed, pszDBRetDesc);
95 	{
96 		char szUnlockReason[1024] = { 0 };
97 		sprintf_s(szUnlockReason, "[跨区]StateSaveGameWorldID=%d, FromGameWorldID=%d, ExecuteGameWorldID=%d, ThisWorldID=%d", 
98 			nStateSaveGameWorldID, nFromGameWorldID, m_nExecuteGameWorldID, getThisGameWorldID()); 
99 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, m_nExecuteGameWorldID, szUnlockReason);
104 	if(nOutLen != sizeof(DBREQ_RESULT_SETUSERLOCK) || pOutData == NULL)
105 	{			
106 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, m_nExecuteGameWorldID, "[跨区]加永久锁时返回数据大小不合法");
107 		pTerminalTunnel->Kickout(EKickoutClient_Reason_StarTrekFailed, "请求异常,请向游戏管理员请求支持[0x1A9F].");
108 		return;
113 	{
114 		char szUnlockReason[1024] = { 0 };
115 		sprintf_s(szUnlockReason, "[跨区]数据库返回的UDBID校验失败. DBReturnUDBID=%d, QueueIndex=%d, TerminalUDBID=%d", 
116 				  pMsg->dwUserID, nQueueIndex, pTerminalTunnel->GetUDBID());
117 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, m_nExecuteGameWorldID, szUnlockReason);
123 	{
124 		char szTraceDesc[1024] = { 0 };
125 		sprintf_s(szTraceDesc, "[跨区]设置永久锁存在严重的流程控制问题, 需修正.UDBID=%d, 描述=%s", pMsg->dwUserID, pszDBRetDesc);
126 		ErrorLn(szTraceDesc); AlertError(MG_AlertSrcType_DataBase, szTraceDesc);
127 	}
133 	if(g_ExternalFacade.GetZoneSvrRunState() != EZoneServer_RunState_Running ||	pVanConnector == NULL || !pVanConnector->IsRunning())
134 	{			
135 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, m_nExecuteGameWorldID, "[跨区]服务器群停机维护期间禁止登陆");
136 		pTerminalTunnel->Kickout(EKickoutClient_Reason_StarTrekFailed, "服务器群停机维护期间禁止登陆..");
137 		return;
141 	if(pEnterGameWorldInfo == NULL)
142 	{
143 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, m_nExecuteGameWorldID, "[跨区]加永久锁返回时pEnterGameWorldInfo为空");
144 		pTerminalTunnel->Kickout(EKickoutClient_Reason_StarTrekFailed, "请求异常,请向游戏管理员请求支持[0x729F].");
145 		return;
150 	if(pNeedInObject == NULL)
151 	{
152 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, m_nExecuteGameWorldID, "[跨区]加永久锁返回时NeedInObject对像已不存在");
153 		pTerminalTunnel->Kickout(EKickoutClient_Reason_StarTrekFailed, "请求异常,请向游戏管理员请求支持[0x629F].");
154 		return;
206 	if(nFromGameWorldID <= 0)
207 	{
208 		ErrorLn("[跨区]严重问题!向公共区加锁返回后取得的FromGameWorldID无效,UDBID="<<nQueueIndex);
209 	}
210 	g_CancelUserSolidLock.EraseFromGameWorldIDForShoot(nQueueIndex);
213 	if(pTerminalTunnel == NULL)
214 	{
215 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, nFromGameWorldID, "[跨区]向公共区加锁返回时TerminalTunnel已无效.");
216 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, m_nExecuteGameWorldID, "[跨区]向公共区加锁返回时TerminalTunnel已无效.");
217 		return;
218 	}
222 	{
223 		char szUnlockReason[1024] = { 0 };
224 		sprintf_s(szUnlockReason, "[跨区]向公共区加锁返回时StateSaveGameWorldID=%d, FromGameWorldID=%d, ExecuteGameWorldID=%d, ThisWorldID=%d", 
225 			nStateSaveGameWorldID, nFromGameWorldID, m_nExecuteGameWorldID, getThisGameWorldID()); 
226 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, nFromGameWorldID,	  szUnlockReason);
233 	{
234 		char szUnlockReason[1024] = { 0 };
235 		sprintf_s(szUnlockReason, "[跨区]向公共区永久锁时DB返回失败, DBError Desc=%s", pszDBRetDesc);
236 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, nFromGameWorldID, szUnlockReason);
237 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, m_nExecuteGameWorldID, szUnlockReason);
242 	if(nOutLen != sizeof(DBREQ_RESULT_SETUSERLOCK) || pOutData == NULL)
243 	{
244 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, nFromGameWorldID, "[跨区]向公共区加锁返回数据大小不合法.");
245 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, m_nExecuteGameWorldID, "[跨区]向公共区加锁返回数据大小不合法.");
246 		pTerminalTunnel->Kickout(EKickoutClient_Reason_StarTrekFailed, "请求异常,请向游戏管理员请求支持[0x4CE5].");
247 		return;
252 	{			
253 		char szUnlockReason[1024] = { 0 };
254 		sprintf_s(szUnlockReason, "[跨区]向公共区加锁返回的UDBID校验失败. DBReturnUDBID=%d, QueueIndex=%d, TerminalUDBID=%d", 
255 			pMsg->dwUserID, nQueueIndex, pTerminalTunnel->GetUDBID());
256 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, nFromGameWorldID, szUnlockReason);
263 	{
264 		char szTraceDesc[1024] = { 0 };
265 		sprintf_s(szTraceDesc, "[跨区] 向公共区设置永久保护锁存在严重的流程控制问题, 需修正! UDBID=%d, 描述=%s", pMsg->dwUserID, pszDBRetDesc);
266 		ErrorLn(szTraceDesc); AlertError(MG_AlertSrcType_DataBase, szTraceDesc);
267 	}
270 	if(pEnterGameWorldInfo == NULL)
271 	{
272 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, nFromGameWorldID, "[跨区]向公共区加永久锁返回时pEnterGameWorldInfo为空");
273 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, m_nExecuteGameWorldID, "[跨区]向公共区加永久锁返回时pEnterGameWorldInfo为空");
274 		pTerminalTunnel->Kickout(EKickoutClient_Reason_StarTrekFailed, "请求异常,请向游戏管理员请求支持[0x7BBF].");
275 		return;
280 	if(pNeedInObject == NULL)
281 	{
282 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, nFromGameWorldID, "[跨区]向公共区加永久锁返回时NeedInObject对像已不存在");
283 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, m_nExecuteGameWorldID, "[跨区]向公共区加永久锁返回时NeedInObject对像已不存在");
284 		pTerminalTunnel->Kickout(EKickoutClient_Reason_StarTrekFailed, "请求异常,请向游戏管理员请求支持[0x6BCF].");
285 		return;
293 	if(g_ExternalFacade.GetZoneSvrRunState() != EZoneServer_RunState_Running ||	pVanConnector == NULL || !pVanConnector->IsRunning())
294 	{
295 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, nFromGameWorldID, "[跨区]向公共区加锁返回后服务器群停机维护.");
296 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, m_nExecuteGameWorldID, "[跨区]向公共区加锁返回后服务器群停机维护.");
297 		pTerminalTunnel->Kickout(EKickoutClient_Reason_StarTrekFailed, "服务器群停机维护期间禁止登陆...");
298 		return;

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\EnterManager\DBRetSinkSetSolidLockForTrek.cpp 4 KB CPP 文件 2014/2/25 0:06:34 2018/10/23 20:04:20 2018/10/23 20:04:20 1
5 ** 日  期:	2010/7/13 10:06
6 ** 版  本:	1.0
7 ** 描  述:	跨区加永久锁
8 ** 应  用:  	
10 **************************** 修改记录 ******************************

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\EnterManager\DBRetSinkSelectActorForTrek.cpp 9 KB CPP 文件 2014/2/25 0:06:34 2018/10/23 20:04:20 2018/10/23 20:04:20 12
5 ** 日  期:	2010/8/2 16:48
6 ** 版  本:	1.0
7 ** 描  述:	DBREQ_RESULT_SELECTACTOR 给跨区用的
8 ** 应  用:  	
10 **************************** 修改记录 ******************************
71 	if(nFromGameWorldID <= 0)
72 	{
73 		ErrorLn("[跨区]严重问题!读取角色数据返回后取到的FromGameWorldID无效,UDBID="<<nQueueIndex);
74 	}
75 	g_CancelUserSolidLock.EraseFromGameWorldIDForShoot(nQueueIndex);
78 	if(pTerminalTunnel == NULL)
79 	{
80 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, nFromGameWorldID, "[跨区]读取角色数据返回后TerminalTunnel已无效.");
81 		if(isPublicGameWorld()){
81 		if(isPublicGameWorld()){
82 			g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, getThisGameWorldID(), "[跨区]读取角色数据返回后TerminalTunnel已无效.");}			
83 		return;
84 	}
88 	{
89 		char szUnlockReason[1024] = { 0 };
90 		sprintf_s(szUnlockReason, "[跨区]读取角色数据时StateSaveGameWorldID=%d, FromGameWorldID=%d, ExecuteGameWorldID=%d, ThisWorldID=%d", 
91 			nStateSaveGameWorldID, nFromGameWorldID, m_nExecuteGameWorldID, getThisGameWorldID()); 
92 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, nStateSaveGameWorldID, szUnlockReason);
110 	if(nOutLen < sizeof(DBREQ_RESULT_SELECTACTOR) || pOutData == NULL)
111 	{
112 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, nFromGameWorldID, "[跨区]读取角色数据返回数据大小不合法.");
113 		if(isPublicGameWorld()){
113 		if(isPublicGameWorld()){
114 			g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, getThisGameWorldID(), "[跨区]读取角色数据返回数据大小不合法.");}
115 		pTerminalTunnel->Kickout(EKickoutClient_Reason_StarTrekFailed, "请求异常,请向游戏管理员寻求支持[0x4CED].");
116 		return;
121 	{
122 		char szUnlockReason[1024] = { 0 };
123 		sprintf_s(szUnlockReason, "[跨区]读取角色数据返回的UDBID校验失败. DBReturnUDBID=%d, QueueIndex=%d, TerminalUDBID=%d, DBReturnPDBID=%d, TerminalUDBID=%d", 
124 			pDBReq->dwUserID, nQueueIndex, pTerminalTunnel->GetUDBID(),  pDBReq->dwActorID, pTerminalTunnel->GetPDBID());
126 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, nFromGameWorldID, szUnlockReason);
134 	if(pEnterGameWorldInfo == NULL)
135 	{
136 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, nFromGameWorldID, "[跨区]读取角色数据返回时pEnterGameWorldInfo为空");			
137 		if(isPublicGameWorld()){
137 		if(isPublicGameWorld()){
138 			g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, getThisGameWorldID(), "[跨区]读取角色数据返回时pEnterGameWorldInfo为空");}			
139 		pTerminalTunnel->Kickout(EKickoutClient_Reason_StarTrekFailed, "请求异常,请向游戏管理员寻求支持[0x7DEF].");
140 		return;
145 	if(pNeedInObject == NULL)
146 	{
147 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, nFromGameWorldID, "[跨区]读取角色数据返回时NeedInObject对像已不存在");
148 		if(isPublicGameWorld()){
148 		if(isPublicGameWorld()){
149 			g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, getThisGameWorldID(), "[跨区]读取角色数据返回时NeedInObject对像已不存在");}			
150 		pTerminalTunnel->Kickout(EKickoutClient_Reason_StarTrekFailed, "请求异常,请向游戏管理员寻求支持[0x6DAF].");
151 		return;

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\EnterManager\ConnectStateTrek.cpp 7 KB CPP 文件 2014/2/25 0:06:33 2018/10/23 20:04:20 2018/10/23 20:04:20 1
5 ** 日  期:	2010/7/2 18:11
6 ** 版  本:	1.0
7 ** 描  述:	跨区切换态
8 ** 应  用:  	
10 **************************** 修改记录 ******************************

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\EnterManager\ConnectStateLoginForTrek.cpp 33 KB CPP 文件 2014/2/25 0:06:31 2018/10/23 20:04:19 2018/10/23 20:04:19 28
5 ** 日  期:	2010/7/11 19:10
6 ** 版  本:	1.0
7 ** 描  述:	跨区登陆态
8 ** 应  用:  	
10 **************************** 修改记录 ******************************
120 	default:
121 		{
122 			Error("[跨区登陆] 玩家登陆态未处理的消息 = " << dwMsgID << endl);
123 			break;
124 		}
194 	reqsetuserlock.dwUserID			= pMsg->dwUserID;
195 	reqsetuserlock.nLockFlag		= 2/*永久保护锁*/;	
196 	reqsetuserlock.OnOffLine		= 1/*因跨区切换而上线*/;
197 	reqsetuserlock.dwActorID		= pMsg->dwActorDBID;
198 	reqsetuserlock.nZoneSvrHardID	= (BYTE)nZoneServerID;
202 		sizeof(reqsetuserlock), &g_DBRetSinkSetUserLockForTrek_ToGeneralDB, pSTContext->nFromGameWorldID))
203 	{
204 		ErrorLn("[跨区]向角色源区请求GAMEDB_REQUEST_SETUSERLOCK失败,UDBID="<<pMsg->dwUserID);
205 		return;
206 	}
229 	if(pNeedInObject == NULL)
230 	{
231 		ErrorLn("[跨区]设置帐号锁请求返回后, NeedInObject对像已不存在, 前面已验证过. UDBID="<<pMsg->dwUserID);
232 		m_pTerminal->Kickout(EKickoutClient_Reason_StarTrekFailed, "请求异常,请向游戏管理员寻求支持[0x929F].");
233 		return;
250 	{
251 		char szUnlockReason[1024] = { 0 };
252 		sprintf_s(szUnlockReason, "[跨区]加永久锁时数据库返回的锁标志不对, LockFlag=%d.", pMsg->nLockFlag);
253 		g_CancelUserSolidLock.CancelSolidLock(m_pTerminal->GetUDBID(), nFromGameWorldID, szUnlockReason);
254 		m_pTerminal->Kickout(EKickoutClient_Reason_StarTrekFailed, "请求异常,请向游戏管理员寻求支持.[0x7F9F]");
267 		if(pDBEngine == NULL)
268 		{
269 			ErrorLn("[跨区]数据库引擎返回NULL, 肯定会锁号. UDBID="<<m_pTerminal->GetUDBID());
270 			return;
271 		}
274 		if(pSchemeCenter == NULL)
275 		{				
276 			ErrorLn("[跨区]SchemeCenter返回NULL, 肯定会锁号. UDBID="<<m_pTerminal->GetUDBID());
277 			return;
278 		}
290 			reqsetuserlock.dwUserID			= m_pTerminal->GetUDBID();
291 			reqsetuserlock.nLockFlag		= 2/*永久保护锁*/;	
292 			reqsetuserlock.OnOffLine		= 1/*因跨区切换而上线*/;
293 			reqsetuserlock.dwActorID		= m_pTerminal->GetPDBID();
294 			reqsetuserlock.nZoneSvrHardID	= (BYTE)nZoneServerID;
299 			{
300 				char szUnlockReason[1024] = { 0 };
301 				sprintf_s(szUnlockReason, "[跨区]向公共区调用GAMEDB_REQUEST_SETUSERLOCK失败, PDBID=%d", m_pTerminal->GetPDBID());
302 				g_CancelUserSolidLock.CancelSolidLock(m_pTerminal->GetUDBID(), nFromGameWorldID, szUnlockReason);
303 				m_pTerminal->Kickout(EKickoutClient_Reason_StarTrekFailed, "对不起,读取角色数据失败,切换失败.");
339 	if(pNeedInObject == NULL)
340 	{			
341 		ErrorLn("[跨区]向公共区设置永久锁请求返回后, NeedInObject对像已不存在, 前面已验证过. UDBID="<<pMsg->dwUserID);
342 		m_pTerminal->Kickout(EKickoutClient_Reason_StarTrekFailed, "请求异常,请向游戏管理员寻求支持[0xCD9F].");
343 		return;
355 	{
356 		char szUnlockReason[256] = { 0 };
357 		sprintf_s(szUnlockReason, "[跨区]向公共区加永久锁返回标志不对, LockFlag=%d.", pMsg->nLockFlag);
358 		g_CancelUserSolidLock.CancelSolidLock(m_pTerminal->GetUDBID(), nFromGameWorldID, szUnlockReason);
359 		g_CancelUserSolidLock.CancelSolidLock(m_pTerminal->GetUDBID(), getThisGameWorldID(), szUnlockReason);
391 	if(pGateway == NULL)
392 	{
393 		ErrorLn("[跨区] 取网关连接客理器出错.udbid="<<m_pTerminal->GetUDBID());
394 		return false;
395 	}
398 	if(pDBEngine == NULL)
399 	{
400 		ErrorLn("[跨区] 取数据库引擎方法出错.udbid="<<m_pTerminal->GetUDBID());
401 		return false;
402 	}
405 	if(pAccountInfo == NULL)
406 	{
407 		ErrorLn("[跨区] GetUserInfo失败.udbid="<<m_pTerminal->GetUDBID());
408 		return false;
409 	}
413 	if(pNeedInObject == NULL)
414 	{
415 		ErrorLn("[跨区] 取NeedInObject对像已不存在.udbid="<<m_pTerminal->GetUDBID());
416 		return false;
417 	}
448 							 sizeof(reqselectactor), &g_DBRetSinkSelectActorForTrek, nFromGameWorldID))
449 	{
450 		ErrorLn("[跨区]向公共区请求GAMEDB_REQUEST_SELECTACTOR失败,UDBID="<<m_pTerminal->GetUDBID());
451 		return false;
452 	}
478 	if(nLen < sizeof(DBREQ_RESULT_SELECTACTOR) || pDBEngine == NULL || pSchemeCenter == NULL || pStarTrekServer == NULL)
479 	{
480 		ErrorLn("[跨区]读取角色数据返回后, 数据大小非法或者一些接口指针为空, 前面已验证过. UDBID="<<m_pTerminal->GetUDBID());
481 		m_pTerminal->Kickout(EKickoutClient_Reason_StarTrekFailed, "请求异常,请向游戏管理员寻求支持[0x9B9F].");
482 		return;
487 	if(pNeedInObject == NULL)
488 	{
489 		ErrorLn("[跨区]读取角色数据返回后, NeedInObject已不存在, 前面已验证过. UDBID="<<m_pTerminal->GetUDBID());
490 		m_pTerminal->Kickout(EKickoutClient_Reason_StarTrekFailed, "对不起，切换超时失败，请联系游戏管理员.");
491 		return;
496 	if(pMsg->dwActorID != m_pTerminal->GetPDBID() || pMsg->dwUserID != pNeedInObject->GetContext()->UDBID)
497 	{
498 		ErrorLn("[跨区]读取角色数据请求异常, PDBID不一致.pdbid="<<pMsg->dwActorID<<" 源pdbid="<<m_pTerminal->GetPDBID());
499 		m_pTerminal->Kickout(EKickoutClient_Reason_StarTrekFailed, "角色数据校验出错，请联系游戏管理员.");
500 		return;
505 		int nHeadFileSize = sizeof(DBREQ_RESULT_SELECTACTOR) + pMsg->nGoodsQty * sizeof(DBREQ_TABLE_GOODS);
506 		char szUnlockReason[1024] = { 0 };
507 		sprintf_s(szUnlockReason, "[跨区]角色数据校验出错, 数据库读出大小=%d, 头定义文件大小=%d", nLen, nHeadFileSize);
508 		g_CancelUserSolidLock.CancelSolidLock(pMsg->dwUserID, nFromGameWorldID, szUnlockReason);
509 		if(isPublicGameWorld()){
512 		return;
513 	}
514 	TraceLn("[跨区登陆] "<<pMsg->szActorName<<"(pdbid="<<pMsg->dwActorID<<")从数据库内读出"<<pMsg->nGoodsQty<<"个物品.");
516 	//////////////////////////////////////////////////// 找到可进入的地图 //////////////////////////////////////////////////
517 	POINT ptDirectEnterTile = { 0, 0};
566 	{
567 		char szUnlockReason[1024] = { 0 };
568 		sprintf_s(szUnlockReason, "[跨区] 竟然无法找到登陆地图, pdbid=%d", pMsg->dwActorID);
569 		g_CancelUserSolidLock.CancelSolidLock(pMsg->dwUserID, nFromGameWorldID, szUnlockReason);
570 		if(isPublicGameWorld()){
581 		{
582 			char szUnlockReason[1024] = { 0 };
583 			sprintf_s(szUnlockReason, "[跨区]竟然无法找到登陆位置, pdbid=%d", pMsg->dwActorID);
584 			g_CancelUserSolidLock.CancelSolidLock(pMsg->dwUserID, nFromGameWorldID, szUnlockReason);
585 			if(isPublicGameWorld()){
606 	{			
607 		char szUnlockReason[1024] = { 0 };
608 		sprintf_s(szUnlockReason, "[跨区]创建人物实体失败, pdbid=%d", pMsg->dwActorID);
609 		g_CancelUserSolidLock.CancelSolidLock(pMsg->dwUserID, nFromGameWorldID, szUnlockReason);
610 		if(isPublicGameWorld()){
697 	{
698 		char szUnlockReason[1024] = { 0 };
699 		sprintf_s(szUnlockReason, "[跨区]ExportDetailContext导出失败, pdbid=%d", pMsg->dwActorID);
700 		g_CancelUserSolidLock.CancelSolidLock(pMsg->dwUserID, nFromGameWorldID, szUnlockReason);
701 		if(isPublicGameWorld()){
722 	{
723 		char szUnlockReason[1024] = { 0 };
724 		sprintf_s(szUnlockReason, "[跨区]通知客户端创建人物失败, pdbid=%d", pMsg->dwActorID);
725 		g_CancelUserSolidLock.CancelSolidLock(pMsg->dwUserID, nFromGameWorldID, szUnlockReason);
726 		if(isPublicGameWorld()){
796 		pTaskServer->ImportBuffData(PDBID, (LPSTR)pMsg->byIntDatas, sizeof(pMsg->byIntDatas), (LPSTR)pMsg->byByteDatas, sizeof(pMsg->byByteDatas));
797 	}
799 	//////////////////////////////////////////////// 释放跨区迁入对像 ///////////////////////////////////////////////////
800 	pStarTrekServer->ReleaseTreakObject(tStarTrek_MsgDir_In, m_pTerminal->GetUserInfo()->stid, tReleaseTreak_Reason_Succeed, false);
801 }

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\CountryServer\CountryServerAPI.cpp 83 KB CPP 文件 2014/2/25 0:05:39 2018/10/23 20:04:04 2018/10/23 20:04:04 13
424 		}
425 	}
427 	// 公共区取跨区国家名称
428 	if (bLocal)
429 	{
449 	else
450 	{
451 		// 取得跨区桥服务器连接器接口
452 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
453 		if (NULL != pBridgeConnector)
590 		}
591 	}
593 	// 公共区取跨区国家名称
594 	if (bLocal)
595 	{
603 	else
604 	{
605 		// 取得跨区桥服务器连接器接口
606 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
607 		if (NULL != pBridgeConnector)
653 		}
654 	}
656 	// 公共区取跨区国家名称
657 	if (bLocalName)
658 	{
666 	else
667 	{
668 		// 取得跨区桥服务器连接器接口
669 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
670 		if (NULL != pBridgeConnector)
742 		}
743 	}
745 	// 公共区取跨区国家名称
746 	if (bLocal)
747 	{
760 	else
761 	{
762 		// 取得跨区桥服务器连接器接口
763 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
764 		if (NULL != pBridgeConnector)
826 	else
827 	{
828 		// 通过跨区桥服务器连接器接口取得国家群组号
829 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
830 		if (NULL != pBridgeConnector)
906 	else
907 	{
908 		// 通过跨区桥服务器连接器接口取得国家群组号
909 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
910 		if (NULL != pBridgeConnector)
995 	else
996 	{
997 		// 通过跨区桥服务器连接器接口取得国家群组号
998 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
999 		if (NULL != pBridgeConnector)
1095 	else
1096 	{
1097 		// 通过跨区桥服务器连接器接口取得国家群组号
1098 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
1099 		if (NULL != pBridgeConnector)
1197 	else
1198 	{
1199 		// 通过跨区桥服务器连接器接口取得国家群组号
1200 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
1201 		if (NULL != pBridgeConnector)

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\CountryServer\BasePart.cpp 44 KB CPP 文件 2014/2/25 0:05:34 2018/10/23 20:04:03 2018/10/23 20:04:03 2
341 	}
343 	pStrData = pszMsg + sizeof(SMsgCountryBaseAnswerBuildServer_OS) + pMsg->nNameLen + pMsg->nTitleLen + pMsg->nLocalNameLen;
344 	// 取得跨区国家名称
345 	if (pMsg->nWorldNameLen>0 && pMsg->nWorldNameLen<sizeof(m_CountryBaseInfo.szWorldName))
346 	{
375 	// 调式代码
376 	char szBuf[512]={0};
377 	sprintf_s(szBuf,sizeof(szBuf), "CBasePart::OnUpdateSelfInfo() 更新国家基础数据: 国家ID=%d,国家名称=%s,等级=%d,等级名=%s,强大程度=%d,文明点数=%d,金钱=%d,木材=%d,粮草=%d,交易税收=%d,官员俸禄=%d,军队俸禄=%d,功勋兑换=%d,文官上限=%d,将军上限=%d,巡捕上限=%d,诸侯上限=%d,侯相上限=%d,国王ID=%d,本区国家短名称=%s,跨区国家名称=%s,所属数据库游戏世界名称=%s",
378 		m_CountryBaseInfo.dwID,m_CountryBaseInfo.szName,m_CountryBaseInfo.nLevel,m_CountryBaseInfo.szLevelName,
379 		m_CountryBaseInfo.dwPower,m_CountryBaseInfo.dwPiont,m_CountryBaseInfo.dwMoney,m_CountryBaseInfo.dwWood,m_CountryBaseInfo.dwFood,

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\ClanServer\ExternalHelper.cpp 31 KB CPP 文件 2014/2/25 0:05:29 2018/10/23 20:04:02 2018/10/23 20:04:02 2
1223 		}
1224 	}
1226 	// 公共区取跨区国家名称
1227 	if (bLocal)
1228 	{
1241 	else
1242 	{
1243 		// 取得跨区桥服务器连接器接口
1244 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
1245 		if (NULL != pBridgeConnector)

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\ChatServer\ChatSystemCommand.cpp 12 KB CPP 文件 2014/2/25 0:05:22 2018/10/23 20:04:01 2018/10/23 20:04:01 1
205 	else if (StringHelper::casecmpn(cmd, ":move ", 6) == 0) // cmd=":mvoe gm'dbid, player'name"
206 	{
207 		// 取得跨区桥服务器连接器接口
208 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
209 		if (pBridgeConnector == NULL)

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\ChatServer\ChatServer.cpp 40 KB CPP 文件 2014/2/25 0:05:21 2018/10/23 20:04:00 2018/10/23 20:04:00 1
1221 }
1223 /**
1224 @name         : 处理其他服务器通过跨区桥服务器转发的消息
1225 @param actionId  : 消息码
1226 @param bridgeHead  : 桥消息头

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Cluster\VoiceServer\GlobalVoiceServer.cpp 183 KB CPP 文件 2014/2/25 0:03:16 2018/10/23 20:03:44 2018/10/23 20:03:44 3
2760 	head->wKeyModule  = MSG_MODULEID_VOICE;
2761 	head->wKeyAction  = MSG_VOICE_SENDDATA;
2763 	// 通过跨区桥服务器中转消息必须加入此消息体
2764 	SMsgVoiceHead * pBhead =(SMsgVoiceHead *)data;
2765 	pBhead->dwWorldID	= server.m_dwWorldID;		// 游戏世界ID
2833 	pHead->wKeyModule  = MSG_MODULEID_VOICE;
2834 	pHead->wKeyAction  = MSG_VOICE_SENDDATA;
2836 	// 通过跨区桥服务器中转消息必须加入此消息体
2837 	SMsgVoiceHead * pBhead =(SMsgVoiceHead*)(pSendData - sizeof(SMsgVoiceHead));
2838 	pBhead->dwWorldID	= server.m_dwWorldID;		// 游戏世界ID
6006 		_T("验证码服务器"),
6007 		_T("Tracker服务器"),
6008 		_T("跨区桥服务器"),
6009 		_T("DB应用服务器"),
6010 		_T("通行证服务器"),

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Cluster\VoiceGateway\GlobalVoiceGateway.cpp 60 KB CPP 文件 2014/2/25 0:03:01 2018/10/23 20:03:43 2018/10/23 20:03:43 3
1558 	//	head->wKeyAction  = MSG_VOICE_SENDDATA;
1559 	//
1560 	//	// 通过跨区桥客户端中转消息必须加入此消息体
1561 	//	SMsgVoiceHead * pBhead =(SMsgVoiceHead *)data;
1562 	//	pBhead->dwWorldID	= client.m_dwWorldID;		// 游戏世界ID
1631 	//	pHead->wKeyAction  = MSG_VOICE_SENDDATA;
1632 	//
1633 	//	// 通过跨区桥客户端中转消息必须加入此消息体
1634 	//	SMsgVoiceHead * pBhead =(SMsgVoiceHead*)(pSendData - sizeof(SMsgVoiceHead));
1635 	//	pBhead->dwWorldID	= client.m_dwWorldID;		// 游戏世界ID
2148 		_T("验证码服务器"),
2149 		_T("Tracker服务器"),
2150 		_T("跨区桥服务器"),
2151 		_T("DB应用服务器"),
2152 		_T("通行证服务器"),

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Cluster\VoiceConnector\VoiceConnector.cpp 42 KB CPP 文件 2014/2/25 0:02:56 2018/10/23 20:03:42 2018/10/23 20:03:42 2
408 	if (moduleId >= 0 && moduleId < MSG_MODULEID_MAXID)
409 	{
410 		// 通过跨区语音服务器中转消息必须加入此消息体
411 		SMsgVoiceHead voiceHead;
412 		// 处理中转数据,把附加数据去掉
426 			if (moduleId >= MSG_MODULEID_MAXID)
427 			{
428 				Error("跨区语音服务器连接器:中转消息moduleId("<<moduleId<<") 超出范围！"<<endl);
429 				return;
430 			}

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Cluster\PassportServer\GlobalPassportServer.cpp 47 KB CPP 文件 2014/2/25 0:02:37 2018/10/23 20:03:41 2018/10/23 20:03:41 3
1006 		_T("验证码服务器"),
1007 		_T("Tracker服务器"),
1008 		_T("跨区桥服务器"),
1009 		_T("DB应用服务器"),
1010 		_T("通行证服务器"),
1213 	head->wKeyModule  = MSG_MODULEID_PASSPORT;
1214 	head->wKeyAction  = MSG_PASSPORT_SENDDATA;
1216 	// 通过跨区桥服务器中转消息必须加入此消息体
1217 	SMsgPassportHead * pBhead =(SMsgPassportHead *)data;
1218 	pBhead->dwWorldID	= server.m_dwWorldID;		// 游戏世界ID
1285 	pHead->wKeyModule  = MSG_MODULEID_PASSPORT;
1286 	pHead->wKeyAction  = MSG_PASSPORT_SENDDATA;
1288 	// 通过跨区桥服务器中转消息必须加入此消息体
1289 	SMsgPassportHead * pBhead =(SMsgPassportHead*)(pSendData - sizeof(SMsgPassportHead));
1290 	pBhead->dwWorldID	= server.m_dwWorldID;		// 游戏世界ID

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Cluster\PassportConnector\PassportConnector.cpp 38 KB CPP 文件 2014/2/25 0:02:34 2018/10/23 20:03:40 2018/10/23 20:03:40 3
408 	if (moduleId >= 0 && moduleId < MSG_MODULEID_MAXID)
409 	{
410 		// 通过跨区通行证服务器中转消息必须加入此消息体
411 		SMsgPassportHead passportHead;
412 		// 处理中转数据,把附加数据去掉
426 			if (moduleId >= MSG_MODULEID_MAXID)
427 			{
428 				Error("跨区通行证服务器连接器:中转消息moduleId("<<moduleId<<") 超出范围！"<<endl);
429 				return;
430 			}
1212 		_T("验证码服务器"),
1213 		_T("Tracker服务器"),
1214 		_T("跨区桥服务器"),
1215 		_T("DB应用服务器"),
1216 		_T("通行证服务器"),

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Cluster\PassportConnector\PassportCommonPart.cpp 3 KB CPP 文件 2014/2/25 0:02:33 2018/10/23 20:03:40 2018/10/23 20:03:40 2
5 ** 日  期:	2010-6-28
6 ** 版  本:	1.0
7 ** 描  述:	通用 跨区桥连接器扩展信息类
8 ** 应  用:  	
10 **************************** 修改记录 ******************************
18 #include "PassportCommonPart.h"
20 /**
21 @name : 跨区桥连接器扩展信息类
22 @brief:
23 */

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Cluster\LoginServer\LoginServerImp.cpp 91 KB CPP 文件 2014/2/25 0:01:38 2018/10/23 20:03:37 2018/10/23 20:03:37 19
44 // 向中心服同步玩家人数定时器时长
45 #define DLOGIN_UPDATEPERSONNUM 30000
47 // 跨区请求数据维护定时器ID
48 #define DLOGIN_TIMER_AREASWITCH 2
48 #define DLOGIN_TIMER_AREASWITCH 2
50 // 跨区请求数据维护定时器时长
51 #define DLOGIN_AREASWITCH 5000
51 #define DLOGIN_AREASWITCH 5000
53 // 跨区请求数据队伍存活时长(秒)
54 #define DLOGIN_AREASWITCHQUEUE_LIVETIME 120
57 // 名称最小数量 需再从数据库中批量读取
219 	}
220 }
224 /// 启动跨区桥服务器连接器
225 void LoginServerImp::CreateBridgeConnector(void)
226 {
225 void LoginServerImp::CreateBridgeConnector(void)
226 {
227 	// 加载跨区桥服务器连接器设定
228 	Ini ini("Bridge.ini");
229 	std::string strBridgeServerIP = ini.getString("Setting","BridgeServerIP","127.0.0.1");
243 	if (nOpenBridge!=1)
244 	{
245 		WarningLn("跨区桥服务器连接禁用!");
246 		return;
247 	}
246 		return;
247 	}
249 	// 跨区桥服务器连接器连接
250 	TraceLn("连接跨区桥服务器:游戏世界ID="<<dwGameWorldID<<":"<<strWorldName.c_str()<<","<<strBridgeServerIP.c_str()<<":"<<nBridgeServerPort);
251 	if(!m_BridgeConnector->Connect(strBridgeServerIP.data(),nBridgeServerPort))
252 	{
251 	if(!m_BridgeConnector->Connect(strBridgeServerIP.data(),nBridgeServerPort))
252 	{
253 		TraceLn("连接跨区桥服务器失败!");
254 		return;
255 	}
254 		return;
255 	}
256 	//TraceLn("连接跨区桥服务器成功!");
258 	// 注册桥服务器消息
259 	m_BridgeConnector->registerMessageHandler(MSG_MODULEID_LOGIN, this);
259 	m_BridgeConnector->registerMessageHandler(MSG_MODULEID_LOGIN, this);
260 }
261 /// 关闭跨区桥服务器连接器
262 void LoginServerImp::ReleaseBridgeConnector(void)
263 {
266 		// 注销桥服务器消息
267 		m_BridgeConnector->unregisterMessageHandler(MSG_MODULEID_LOGIN);
269 		// 关闭跨区桥服务器连接器
270 		TraceLn("关闭跨区桥服务器连接器!");
271 		m_BridgeConnector->Release();
272 		m_BridgeConnector = NULL;
564 			case MG_SoftControl_SetServerUID:	// 设定软件服务器的UID
565 				{
566 					// 连接器连接跨区桥服务器
567 					if (NULL != m_ManagerConnector && m_ManagerConnector->GetWorldID()!=0)
568 					{
570 						if (NULL==m_BridgeConnector)
571 						{
572 							// 启动跨区桥服务器连接器
573 							CreateBridgeConnector();
574 						}
851 	// 关闭通行证服务器连接器
852 	ReleasePassportConnector();
854 	// 关闭跨区桥服务器连接器
855 	ReleaseBridgeConnector();
857 	// 关闭管理连接器
1632 //end add
1634 /**
1635 @name         : 处理其他服务器通过跨区桥服务器转发的消息
1636 @param actionId  : 消息码
1637 @param bridgeHead  : 桥消息头
1781 	m_BridgeConnector->SendDataToServer(pMsg->context.serverID, buf.data(), buf.size());
1782 }
1785 /** 取跨区登陆临时数据
1786 @param   
1787 @param   
1798 	return &(Iter->second);
1799 }
1801 /** 删除跨区登陆临时数据
1802 @param   
1803 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Cluster\LoginServer\ClientState_Queue.cpp 19 KB CPP 文件 2014/2/25 0:01:24 2018/10/23 20:03:36 2018/10/23 20:03:36 2
367 bool ClientState_Queue::GetZoneServerID(CGID &nServerID, int &nMapID, POINT &ptTile)
368 {
369 	// 换区操作时，不随机选择场景服务器，因为有可能随机到的场影服务器上没有跨区数据
370 	STATE_SWITCH_CONTEXT &switchContext = m_pClient->GetSwitchContext();
371 	if (switchContext.stid != 0)
419 		return true;
420 	}
422 	// 在非跨区登陆时，如果找不到指定的地图，就在青龙城与云中界随机一个与国家对应的地图
423 	{
424 		DWORD dwLevel = switchContext.actorInfo.dwLevel;

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Cluster\LoginServer\ClientState_Login.cpp 73 KB CPP 文件 2014/2/25 0:01:22 2018/10/23 20:03:36 2018/10/23 20:03:36 3
733 		}
734 	}
736 	// 六国登陆 取得跨区桥服务器连接器接口
737 	if(SendCountryInfo(std::string(data.szEnterWorldName)) == false)
738 	{
1005 	}
1006 }
1009 /** 处理用户跨区登陆请求
1010 @param   
1011 @param   
1335 		}
1336 #endif
1338 		// 六国登陆 取得跨区桥服务器连接器接口
1339 		if(SendCountryInfo(std::string(pMsg->szEnterWorldName)) == false)
1340 		{

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Cluster\LoginServer\ClientState_Game.cpp 20 KB CPP 文件 2014/2/25 0:01:20 2018/10/23 20:03:36 2018/10/23 20:03:36 1
207 	//// 是否检查锁
208 	//switchContext.bCheckLock = false;
209 	//// 跨区时的STID
210 	//switchContext.stid = 0;
212 	//switchContext.dwOtherFlag=1;								

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Cluster\LoginServer\ClientState_AreaSwitch.cpp 13 KB CPP 文件 2014/2/25 0:01:19 2018/10/23 20:03:36 2018/10/23 20:03:36 6
130 	GameDatabaseAccessor::getInstance().RemoveDBRetSink(this);
131 }
134 /** 处理用户跨区登陆请求
135 @param   
136 @param   
147 	m_bDBRequester = GameDatabaseAccessor::getInstance().ExecuteSP(GAMEDB_REQUEST_QUERYUSERLOGIN,rand(),(LPCSTR)&userLogin,sizeof(userLogin),this, switchContext.dwGameWorldID);
148 }
150 /** 处理用户跨区登陆请求 数据库返回
151 @param   
152 @param   
196 	HandleUserSwitchAreaQueryActorInfo(result->dwPDBID);	
197 }
200 // 处理用户跨区选角色请求
201 void ClientState_AreaSwitch::HandleUserSwitchAreaQueryActorInfo(DWORD dwPDBID)
202 {
208 	m_bDBRequester = GameDatabaseAccessor::getInstance().ExecuteSP(GAMEDB_REQUEST_QUERYACTORLOGIN, rand(), (LPCSTR)&data, sizeof(data), this, switchContext.dwGameWorldID);
209 }
211 // 处理用户跨区选角色请求 数据库返回
212 void ClientState_AreaSwitch::HandleDBResult_SwitchAreaQueryActorInfo(DBREQ_RESULT_QUERYACTORLOGIN * result,DWORD dwResultLen)
213 {
232 	m_pClient->GotoState(CLIENT_CONN_STATE_QUEUE,(const char *)&switchContext,sizeof(switchContext));
233 }
235 // 处理用户跨区登陆请求(在区库中查询)
236 void ClientState_AreaSwitch::HandleUserSwitchAreaQueryUserAreaInfo(LPCSTR pData, int nLen)
237 {
321 	m_bDBRequester = GameDatabaseAccessor::getInstance().ExecuteSP(GAMEDB_REQUEST_QUERYUSERLOGINAREA,rand(),(LPCSTR)&userLogin,sizeof(userLogin),this, switchContext.dwGameWorldID);
322 }
324 // 处理用户跨区登陆请求 数据库返回
325 void ClientState_AreaSwitch::HandleDBResult_SwitchAreaQueryUserAreaInfo(DBREQ_RESULT_QUERYUSERLOGINAREA * result,DWORD dwResultLen)
326 {

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Cluster\LoginServer2\LoginServerImp.cpp 91 KB CPP 文件 2014/2/25 0:02:15 2018/10/23 20:03:39 2018/10/23 20:03:39 19
44 // 向中心服同步玩家人数定时器时长
45 #define DLOGIN_UPDATEPERSONNUM 30000
47 // 跨区请求数据维护定时器ID
48 #define DLOGIN_TIMER_AREASWITCH 2
48 #define DLOGIN_TIMER_AREASWITCH 2
50 // 跨区请求数据维护定时器时长
51 #define DLOGIN_AREASWITCH 5000
51 #define DLOGIN_AREASWITCH 5000
53 // 跨区请求数据队伍存活时长(秒)
54 #define DLOGIN_AREASWITCHQUEUE_LIVETIME 120
57 // 名称最小数量 需再从数据库中批量读取
219 	}
220 }
224 /// 启动跨区桥服务器连接器
225 void LoginServerImp::CreateBridgeConnector(void)
226 {
225 void LoginServerImp::CreateBridgeConnector(void)
226 {
227 	// 加载跨区桥服务器连接器设定
228 	Ini ini("Bridge.ini");
229 	std::string strBridgeServerIP = ini.getString("Setting","BridgeServerIP","127.0.0.1");
243 	if (nOpenBridge!=1)
244 	{
245 		WarningLn("跨区桥服务器连接禁用!");
246 		return;
247 	}
246 		return;
247 	}
249 	// 跨区桥服务器连接器连接
250 	TraceLn("连接跨区桥服务器:游戏世界ID="<<dwGameWorldID<<":"<<strWorldName.c_str()<<","<<strBridgeServerIP.c_str()<<":"<<nBridgeServerPort);
251 	if(!m_BridgeConnector->Connect(strBridgeServerIP.data(),nBridgeServerPort))
252 	{
251 	if(!m_BridgeConnector->Connect(strBridgeServerIP.data(),nBridgeServerPort))
252 	{
253 		TraceLn("连接跨区桥服务器失败!");
254 		return;
255 	}
254 		return;
255 	}
256 	//TraceLn("连接跨区桥服务器成功!");
258 	// 注册桥服务器消息
259 	m_BridgeConnector->registerMessageHandler(MSG_MODULEID_LOGIN, this);
259 	m_BridgeConnector->registerMessageHandler(MSG_MODULEID_LOGIN, this);
260 }
261 /// 关闭跨区桥服务器连接器
262 void LoginServerImp::ReleaseBridgeConnector(void)
263 {
266 		// 注销桥服务器消息
267 		m_BridgeConnector->unregisterMessageHandler(MSG_MODULEID_LOGIN);
269 		// 关闭跨区桥服务器连接器
270 		TraceLn("关闭跨区桥服务器连接器!");
271 		m_BridgeConnector->Release();
272 		m_BridgeConnector = NULL;
564 			case MG_SoftControl_SetServerUID:	// 设定软件服务器的UID
565 				{
566 					// 连接器连接跨区桥服务器
567 					if (NULL != m_ManagerConnector && m_ManagerConnector->GetWorldID()!=0)
568 					{
570 						if (NULL==m_BridgeConnector)
571 						{
572 							// 启动跨区桥服务器连接器
573 							CreateBridgeConnector();
574 						}
851 	// 关闭通行证服务器连接器
852 	ReleasePassportConnector();
854 	// 关闭跨区桥服务器连接器
855 	ReleaseBridgeConnector();
857 	// 关闭管理连接器
1632 //end add
1634 /**
1635 @name         : 处理其他服务器通过跨区桥服务器转发的消息
1636 @param actionId  : 消息码
1637 @param bridgeHead  : 桥消息头
1781 	m_BridgeConnector->SendDataToServer(pMsg->context.serverID, buf.data(), buf.size());
1782 }
1785 /** 取跨区登陆临时数据
1786 @param   
1787 @param   
1798 	return &(Iter->second);
1799 }
1801 /** 删除跨区登陆临时数据
1802 @param   
1803 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Cluster\LoginServer2\ClientState_Queue.cpp 19 KB CPP 文件 2014/2/25 0:02:04 2018/10/23 20:03:38 2018/10/23 20:03:38 2
367 bool ClientState_Queue::GetZoneServerID(CGID &nServerID, int &nMapID, POINT &ptTile)
368 {
369 	// 换区操作时，不随机选择场景服务器，因为有可能随机到的场影服务器上没有跨区数据
370 	STATE_SWITCH_CONTEXT &switchContext = m_pClient->GetSwitchContext();
371 	if (switchContext.stid != 0)
419 		return true;
420 	}
422 	// 在非跨区登陆时，如果找不到指定的地图，就在青龙城与云中界随机一个与国家对应的地图
423 	{
424 		DWORD dwLevel = switchContext.actorInfo.dwLevel;

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Cluster\LoginServer2\ClientState_Login.cpp 78 KB CPP 文件 2014/2/25 0:02:01 2018/10/23 20:03:38 2018/10/23 20:03:38 3
738 		}
739 	}
741 	// 六国登陆 取得跨区桥服务器连接器接口
742 	if(SendCountryInfo(std::string(data.szEnterWorldName)) == false)
743 	{
1011 	}
1012 }
1015 /** 处理用户跨区登陆请求
1016 @param   
1017 @param   
1341 		}
1342 #endif
1344 		// 六国登陆 取得跨区桥服务器连接器接口
1345 		if(SendCountryInfo(std::string(pMsg->szEnterWorldName)) == false)
1346 		{

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Cluster\LoginServer2\ClientState_Game.cpp 20 KB CPP 文件 2014/2/25 0:01:59 2018/10/23 20:03:38 2018/10/23 20:03:38 1
207 	//// 是否检查锁
208 	//switchContext.bCheckLock = false;
209 	//// 跨区时的STID
210 	//switchContext.stid = 0;
212 	//switchContext.dwOtherFlag=1;								

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Cluster\LoginServer2\ClientState_AreaSwitch.cpp 13 KB CPP 文件 2014/2/25 0:01:58 2018/10/23 20:03:38 2018/10/23 20:03:38 6
130 	GameDatabaseAccessor::getInstance().RemoveDBRetSink(this);
131 }
134 /** 处理用户跨区登陆请求
135 @param   
136 @param   
147 	m_bDBRequester = GameDatabaseAccessor::getInstance().ExecuteSP(GAMEDB_REQUEST_QUERYUSERLOGIN,rand(),(LPCSTR)&userLogin,sizeof(userLogin),this, switchContext.dwGameWorldID);
148 }
150 /** 处理用户跨区登陆请求 数据库返回
151 @param   
152 @param   
196 	HandleUserSwitchAreaQueryActorInfo(result->dwPDBID);	
197 }
200 // 处理用户跨区选角色请求
201 void ClientState_AreaSwitch::HandleUserSwitchAreaQueryActorInfo(DWORD dwPDBID)
202 {
208 	m_bDBRequester = GameDatabaseAccessor::getInstance().ExecuteSP(GAMEDB_REQUEST_QUERYACTORLOGIN, rand(), (LPCSTR)&data, sizeof(data), this, switchContext.dwGameWorldID);
209 }
211 // 处理用户跨区选角色请求 数据库返回
212 void ClientState_AreaSwitch::HandleDBResult_SwitchAreaQueryActorInfo(DBREQ_RESULT_QUERYACTORLOGIN * result,DWORD dwResultLen)
213 {
232 	m_pClient->GotoState(CLIENT_CONN_STATE_QUEUE,(const char *)&switchContext,sizeof(switchContext));
233 }
235 // 处理用户跨区登陆请求(在区库中查询)
236 void ClientState_AreaSwitch::HandleUserSwitchAreaQueryUserAreaInfo(LPCSTR pData, int nLen)
237 {
321 	m_bDBRequester = GameDatabaseAccessor::getInstance().ExecuteSP(GAMEDB_REQUEST_QUERYUSERLOGINAREA,rand(),(LPCSTR)&userLogin,sizeof(userLogin),this, switchContext.dwGameWorldID);
322 }
324 // 处理用户跨区登陆请求 数据库返回
325 void ClientState_AreaSwitch::HandleDBResult_SwitchAreaQueryUserAreaInfo(DBREQ_RESULT_QUERYUSERLOGINAREA * result,DWORD dwResultLen)
326 {

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Cluster\Include\BridgeFun.cpp 7 KB CPP 文件 2014/2/25 0:01:08 2018/10/23 20:03:36 2018/10/23 20:03:36 2
5 ** 日  期:	2010-6-25
6 ** 版  本:	1.0
7 ** 描  述:	跨区桥服务器共用函数
8 ** 应  用:  	
10 **************************** 修改记录 ******************************
188 		_T("验证码服务器"),
189 		_T("Tracker服务器"),
190 		_T("跨区桥服务器"),
191 		_T("DB应用服务器"),
192 		_T("通行证服务器"),

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Cluster\BridgeServer\ServerUser.cpp 7 KB CPP 文件 2014/2/25 0:00:12 2018/10/23 20:03:24 2018/10/23 20:03:24 1
5 ** 日  期:	2010-6-24
6 ** 版  本:	1.0
7 ** 描  述:	跨区桥服务器用户
8 ** 应  用:  	
10 **************************** 修改记录 ******************************

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Cluster\BridgeServer\ServerList.cpp 2 KB CPP 文件 2014/2/25 0:00:11 2018/10/23 20:03:24 2018/10/23 20:03:24 1
5 ** 日  期:	2010-6-24
6 ** 版  本:	1.0
7 ** 描  述:	跨区桥服务器用户列表
8 ** 应  用:  		
10 **************************** 修改记录 ******************************

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Cluster\BridgeServer\ListInfoDlg.cpp 8 KB CPP 文件 2014/2/25 0:00:10 2018/10/23 20:03:24 2018/10/23 20:03:24 1
162 	CBridgeServerDlg * pServerDlg =(CBridgeServerDlg *) AfxGetApp()->m_pMainWnd;
164 	CListCtrl& ListCtrl = m_InfoList;
166 	GlobalBridgeServer& mainServer = pServerDlg->m_BridgeServer;	//跨区桥服务器服务
168 	char szBuf[256]={0};
170 	// 防止闪

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Cluster\BridgeServer\GlobalBridgeServer.cpp 42 KB CPP 文件 2014/2/25 0:00:10 2018/10/23 20:03:24 2018/10/23 20:03:24 10
5 ** 日  期:	2010-6-24
6 ** 版  本:	1.0
7 ** 描  述:	跨区桥服务器
8 ** 应  用:  	
10 **************************** 修改记录 ******************************
84 	TraceLn("连接子服务器管理器:"<<strManagerServerIP.data()<<":"<<nManagerServerPort);
85 	m_ManagerConnector = CreateManagerConnectorProc(this,&m_TimerAxis);
86 	m_ManagerConnector->Create(MSG_MG_ENDPOINT_BRIDGE,0,_NGT"跨区桥服务器");
87 	if(!m_ManagerConnector->Connect(strManagerServerIP.data(),nManagerServerPort))
88 	{
327 			if(Create(wServerListenPort))
328 			{
329 				Trace("启动跨区桥服务器 OK ！"<<endl);
330 			}
331 			else
331 			else
332 			{
333 				Error("启动跨区桥服务器 失败！"<<endl);
334 			}
335 		}
339 			if(Close())
340 			{
341 				Trace("停止跨区桥服务器 OK ！"<<endl);
342 			}
343 			else
343 			else
344 			{
345 				Error("停止跨区桥服务器 失败！"<<endl);
346 			}
347 		}
351 			if(Close())
352 			{
353 				Trace("停止跨区桥服务器 OK ！"<<endl);
354 			}
355 			else
355 			else
356 			{
357 				Error("停止跨区桥服务器 失败！"<<endl);
358 			}
359 			// 通知服务器关闭
1023 	head->wKeyModule  = MSG_MODULEID_BRIDGE;
1024 	head->wKeyAction  = MSG_BRIDGE_SENDDATA;
1026 	// 通过跨区桥服务器中转消息必须加入此消息体
1027 	SMsgBridgeHead * pBhead =(SMsgBridgeHead *)data;
1028 	pBhead->dwWorldID	= server.m_dwWorldID;		// 游戏世界ID
1095 	pHead->wKeyModule  = MSG_MODULEID_BRIDGE;
1096 	pHead->wKeyAction  = MSG_BRIDGE_SENDDATA;
1098 	// 通过跨区桥服务器中转消息必须加入此消息体
1099 	SMsgBridgeHead * pBhead =(SMsgBridgeHead*)(pSendData - sizeof(SMsgBridgeHead));
1100 	pBhead->dwWorldID	= server.m_dwWorldID;		// 游戏世界ID

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Cluster\BridgeServer\BridgeServerDlg.cpp 18 KB CPP 文件 2014/2/25 0:00:09 2018/10/23 20:03:24 2018/10/23 20:03:24 6
5 ** 日  期:	2010-6-24
6 ** 版  本:	1.0
7 ** 描  述:	跨区桥服务器主程序界面
8 ** 应  用:  	
9 	
427 	if (m_BridgeServer.IsStart())
428 	{
429 		CString strAlert="跨区桥服务器正在运行中，你确定要停止服务并退出程序吗？";
430 		if(MessageBox(strAlert,"操作确认",MB_YESNO|MB_ICONQUESTION)!=IDYES) 
431 		{
432 			return;
433 		}
435 		Trace("停止跨区桥服务器 ..."<<endl);
437 		// 关闭程序,停止服务后要关闭进程
438 		m_BridgeServer.SetControlCode(BS_ControlCode_ShutDown);
477 	//更新修改的中心服务器ＩＰ,端口到m_BridgeServer.m_strCenterServerIP,m_BridgeServer.m_nPort
478 	UpdateCenterServerConfig();
480 	Trace("启动跨区桥服务器 ..."<<endl);
482 	// 启动服务
483 	m_BridgeServer.SetControlCode(BS_ControlCode_StartService);
513 		return false;
514 	}
516 	CString strAlert="跨区桥服务器正在运行中，你确定要停止服务并退出程序吗？";
517 	if(MessageBox(strAlert,"操作确认",MB_YESNO|MB_ICONQUESTION)!=IDYES) 
518 	{
519 		return false;
520 	}
522 	Trace("停止跨区桥服务器 ..."<<endl);
524 	// 停止服务
525 	m_BridgeServer.SetControlCode(BS_ControlCode_StopService);

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Cluster\BridgeServer\BridgeServer.cpp 4 KB CPP 文件 2014/2/25 0:00:07 2018/10/23 20:03:23 2018/10/23 20:03:23 4
5 ** 日  期:	2010-6-24
6 ** 版  本:	1.0
7 ** 描  述:	跨区桥服务器主程序
8 ** 应  用:  	
9 	
69 	if(GetLastError()==ERROR_ALREADY_EXISTS)	
70 	{
71 		//::MessageBox(NULL,"跨区桥服务器已经在运行!","跨区桥服务器",MB_ICONINFORMATION);
72 		//AfxMessageBox("跨区桥服务器已经在运行!",MB_ICONINFORMATION);	
73 		return FALSE;
74 	}

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Cluster\BridgeConnector\ServerCapabilityTest.cpp 11 KB CPP 文件 2014/2/25 0:00:05 2018/10/23 20:03:23 2018/10/23 20:03:23 1
138 		nCheckInterval = 5;	
139 	}
141 	EmphasisLn("=============== 启动跨区服务器性能测试 间隔时长为" << nCheckInterval << "秒 ===============");
142 	pTimerAxis->SetTimer(DTIMER_ID_TESTSTART, 1, this);
144 	pTimerAxis->SetTimer(DTIMER_ID_SERVERCHECK, nCheckInterval*1000, this);

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Cluster\BridgeConnector\BridgeZonePart.cpp 9 KB CPP 文件 2014/2/25 0:00:04 2018/10/23 20:03:23 2018/10/23 20:03:23 3
5 ** 日  期:	2010-6-28
6 ** 版  本:	1.0
7 ** 描  述:	场景服 跨区桥连接器扩展信息类
8 ** 应  用:  	
10 **************************** 修改记录 ******************************
17 #include "BridgeZonePart.h"
20 /**
21 @name : 场景服 跨区桥连接器扩展信息类
22 @brief:
23 */
297 	default:
298 		{
299 			ErrorLn("尚有一个跨区桥服务器扩展信息消息未处理，dwMsgCode = "<<dwMsgCode);
300 		}
301 	}

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Cluster\BridgeConnector\BridgeSocialPart.cpp 9 KB CPP 文件 2014/2/25 0:00:03 2018/10/23 20:03:23 2018/10/23 20:03:23 5
5 ** 日  期:	2010-6-28
6 ** 版  本:	1.0
7 ** 描  述:	社会服 跨区桥连接器扩展信息类
8 ** 应  用:  	
10 **************************** 修改记录 ******************************
17 #include "BridgeSocialPart.h"
19 /**
20 @name : 社会服 跨区桥连接器扩展信息类
21 @brief:
22 */
181 #ifdef BRIDGE_PRINT_DEBUG_INF
182 				// 调式代码
183 				sprintf_s(szBuf, _countof(szBuf),_NGT"更新全部国家信息:国家ID=%d,发展等级=%d,强大程度=%d,文明点数=%d,金钱=%d,木材=%d,粮草=%d,攻击=%d,防御=%d,赢次数=%d,国王=%d,世界文明等级=%d,世界文明点数=%d,所属数据库游戏世界ID=%d,群组号=%d,国家基础数据标识=%d,本区国家名称=%s,跨区国家名称=%s",
184 					node.dwID,node.nLevel,node.dwPower,node.dwPiont,node.dwMoney,node.dwWood,node.dwFood,
185 					node.dwWorldAttack,node.dwWorldDefend,node.dwLastWinTimes,node.dwKingPlayerID,node.dwCivilGrade,node.dwCivilDot,node.dwDBWorldID,node.dwGroupID,node.dwFlag,node.szName,node.szWorldName);
218 #ifdef BRIDGE_PRINT_DEBUG_INF
219 			// 调式代码
220 			sprintf_s(szBuf, _countof(szBuf),_NGT"更新国家信息:国家ID=%d,发展等级=%d,强大程度=%d,文明点数=%d,金钱=%d,木材=%d,粮草=%d,攻击=%d,防御=%d,赢次数=%d,国王=%d,世界文明等级=%d,世界文明点数=%d,所属数据库游戏世界ID=%d,群组号=%d,国家基础数据标识=%d,本区国家名称=%s,跨区国家名称=%s",
221 				node.dwID,node.nLevel,node.dwPower,node.dwPiont,node.dwMoney,node.dwWood,node.dwFood,
222 				node.dwWorldAttack,node.dwWorldDefend,node.dwLastWinTimes,node.dwKingPlayerID,node.dwCivilGrade,node.dwCivilDot,node.dwDBWorldID,node.dwGroupID,node.dwFlag,node.szName,node.szWorldName);
249 	default:
250 		{
251 			ErrorLn("尚有一个跨区桥服务器扩展信息消息未处理，dwMsgCode = "<<dwMsgCode);
252 		}
253 	}

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Cluster\BridgeConnector\BridgeConnector.cpp 49 KB CPP 文件 2014/2/25 0:00:02 2018/10/23 20:03:23 2018/10/23 20:03:23 30
5 ** 日  期:	2009/8/25
6 ** 版  本:	1.0
7 ** 描  述:	跨区桥服务器连接器
8 ** 应  用:  	
10 **************************** 修改记录 ******************************
58 	if (NULL!=g_hBridgeConnector)
59 	{
60 		ErrorLn("跨区桥服务器连接器被重复创建，会导致服务器管理功能出问题，请检查相关代码并修正！");
61 	}
62 	g_hBridgeConnector = this;
213 	return m_dwPublicWorldID;	// 公共游戏世界ID
214 }
217 // 发给跨区桥服务器数据
218 void  BridgeConnector::SendData(const char * pData,DWORD dwLen)
219 {
270 {
271 	Close();
272 	WarningLn("主动重连 跨区桥服务器 " << m_szRemoteIP.c_str() <<":" << m_wRemotePort);
274 	return Connect(m_szRemoteIP.c_str(),m_wRemotePort);
275 }
296 						Close();
297 						m_pTimerAxis->SetTimer(ETimerEventID_ReconnectNet,BRIDGE_RECONNECT_INTERVAL,this,1);
299 						WarningLn("与跨区桥服务器连接超过"<<BRIDGE_KEEPALIVE_MAXTIMEOUT<<"毫秒没有心跳,重连跨区桥服务器：  " << m_szRemoteIP.c_str() <<":" << m_wRemotePort);
300 					}
301 				}
348 	if (NULL==handler || wEventID>=EVENT_BRIDGE_MAXID)
349 	{
350 		Error("注册跨区桥服务器连接器事件处理者无效,wEventID="<<wEventID<<" "<<endl);
351 		return false;
352 	}
364 	if (NULL==handler|| wEventID>=EVENT_BRIDGE_MAXID)
365 	{
366 		Error("注销跨区桥服务器连接器事件处理者无效,wEventID="<<wEventID<<" "<<endl);
367 		return false;
368 	}
380 	if (wEventID>=EVENT_BRIDGE_MAXID)
381 	{
382 		Error("触发跨区桥服务器连接器事件ID无效,wEventID="<<wEventID<<" "<<endl);
383 		return false;
384 	}
406 		if (m_MsgHandlers[moduleId] != NULL)
407 		{
408 			Warning("跨区桥服务器连接器 moduleId("<<moduleId<<") already registered"<<endl);
409 		}
410 		m_MsgHandlers[moduleId] = handler;
413 	else
414 	{
415 		Error("跨区桥服务器连接器 moduleId("<<moduleId<<") range error"<<endl);
416 		return false;
417 	}
427 	{
428 		if (m_MsgHandlers[moduleId] == NULL)
429 			Warning("跨区桥服务器连接器 moduleId("<<moduleId<<") already unregistered"<<endl);
430 		m_MsgHandlers[moduleId] = 0;
431 		return true;
433 	else
434 	{
435 		Error("跨区桥服务器连接器 moduleId("<<moduleId<<") range error"<<endl);
436 		return false;
437 	}
450 	if (moduleId >= 0 && moduleId < MSG_MODULEID_MAXID)
451 	{
452 		// 通过跨区桥服务器中转消息必须加入此消息体
453 		SMsgBridgeHead bridgeHead;
454 		// 处理中转数据,把附加数据去掉
468 			if (moduleId >= MSG_MODULEID_MAXID)
469 			{
470 				Error("跨区桥服务器连接器:中转消息moduleId("<<moduleId<<") 超出范围！"<<endl);
471 				return;
472 			}
497 			{
498 				dwLastAlertTimes = dwNowTimes;
499 				Error("跨区桥服务器连接器 moduleId("<<moduleId<<") Handler not registered"<<endl);
500 			}
501 		}
504 	else
505 	{
506 		Error("跨区桥服务器连接器:消息moduleId("<<moduleId<<") 超出范围！"<<endl);
507 	}
508 }
550 	if (m_bIsConnected==false || m_pConnection==0 || m_ID==0)
551 	{
552 		WarningLn("桥服务器连接器还没有连上跨区桥服务器，请求设定服务器状态失败!");
553 		return false;
554 	}
553 		return false;
554 	}
556 	WarningLn("向跨区桥服务器设定服务器状态["<<dwStateFlag);
558 	return true;
559 }
563 {
564 	ostrstream buffer;
565 	buffer << " 跨区桥服务器[" << m_szRemoteIP <<":" << m_wRemotePort <<"][ID=" << m_ID << ",dwWorldID="<<m_dwWorldID<<",ServerType="<<m_wServerType<<",SubID="<<m_wSubID<<":"<<m_szName<<"]" << std::ends;
566 	return buffer.str();
567 }
566 	return buffer.str();
567 }
569 // 跨区桥服务器连接器接口
570 IBridgeConnector* GetGlobalBridgeConnector()
571 {
664 	}
666 }
669 // 发服务器扩展信息消息 dwServerID:服务器ID 为0时广播给所有桥服务器连接器,跨区桥服务器连接器同步服务器扩展信息专用
670 bool BridgeConnector::SendExtDataToServer(DWORD dwServerID,DWORD dwMsgCode,DWORD dwUserData1,DWORD dwUserData2,DWORD dwUserData3,const char * pData,DWORD dwLen)
671 {
990 	m_mapPartList.clear();
992 }
994 ///////////////////////// IBridgeMessageHandler 处理跨区桥服务器发过来的消息 /////////////////////////
995 void BridgeConnector::HandleBridgeMessage(ulong actionId, SMsgBridgeHead &bridgeHead, SGameMsgHead* head, LPSTR data, size_t len)
996 {
1041 	default:
1042 		{
1043 			ErrorLn("尚有一个跨区桥服务器发过来的消息未处理，actionId = "<<actionId);
1044 		}
1045 	}
1045 	}
1046 }
1049 ///////////////////////// 处理跨区桥服务器发过来的消息 /////////////////////////
1051 // 中转消息
1052 void BridgeConnector::OnMsgTransitData(unsigned long actionId,SMsgBridgeHead &bridgeHead, SGameMsgHead* head, LPSTR data, size_t len)
1054 	if(data==NULL|| len < sizeof(SMsgBridgeTransitData))
1055 	{
1056 		ErrorLn("跨区桥服务器中转消息数据大小非法!");
1057 		return;
1058 	}
1064 	if (0==pMsg->dwServerID || 0==new_len || pMsg->dwDataLens!=new_len)
1065 	{
1066 		ErrorLn("跨区桥服务器中转消息数据大小校验非法!");
1067 		return;
1068 	}
1076 	if( len != sizeof(SMsgBridgeHandshakeResponse))
1077 	{
1078 		ErrorLn("跨区桥服务器回应握手消息数据大小非法!");
1079 		return;
1080 	}
1084 	m_ID = pMsg->dwID;
1085 	m_dwPublicWorldID = pMsg->dwPublicWorldID;
1087 	TraceLn("与跨区桥服务器握手成功! ID="<<m_ID<<",公共游戏世界ID="<<m_dwPublicWorldID);
1089 	// 设置公共区游戏世界ID
1090 	setPublicGameWorldID((int)m_dwPublicWorldID);
1089 	// 设置公共区游戏世界ID
1090 	setPublicGameWorldID((int)m_dwPublicWorldID);
1092 	// 触发与跨区桥服务器握手成功事件
1093 	SEventBridgeHandshake evenData;
1094 	evenData.dwServerID = m_ID;

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Cluster\BridgeConnector\BridgCommonPart.cpp 3 KB CPP 文件 2014/2/25 0:00:01 2018/10/23 20:03:23 2018/10/23 20:03:23 2
5 ** 日  期:	2010-6-28
6 ** 版  本:	1.0
7 ** 描  述:	通用 跨区桥连接器扩展信息类
8 ** 应  用:  	
10 **************************** 修改记录 ******************************
18 #include "BridgCommonPart.h"
20 /**
21 @name : 社会服 跨区桥连接器扩展信息类
22 @brief:
23 */

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcClient\Client\MatchClient\WarClient.cpp 8 KB CPP 文件 2014/2/25 8:34:48 2018/10/23 19:52:18 2018/10/23 19:52:18 2
5 ** 日  期:	2011-03-19
6 ** 版  本:	1.0
7 ** 描  述:	跨区战场
8 ** 应  用:  	
9 	
278 	default:
279 		{
280 			ErrorLn("跨区战场客户端系统有一个服务器战场信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
281 		}
282 		break;

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcClient\Client\MatchClient\War.cpp 16 KB CPP 文件 2014/2/25 8:34:48 2018/10/23 19:52:18 2018/10/23 19:52:18 1
5 ** 日  期:	2011-03-19
6 ** 版  本:	1.0
7 ** 描  述:	跨区战场
8 ** 应  用:  	
9 	

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcClient\Client\MatchClient\StrikeClient.cpp 54 KB CPP 文件 2014/2/25 8:34:47 2018/10/23 19:52:18 2018/10/23 19:52:18 2
5 ** 日  期:	2010-10-29
6 ** 版  本:	1.0
7 ** 描  述:	跨区竞技
8 ** 应  用:  	
9 	
1707 	default:
1708 		{
1709 			ErrorLn("跨区竞技客户端系统有一个服务器竞技信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
1710 		}
1711 		break;

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcClient\Client\MatchClient\MatchClient.cpp 134 KB CPP 文件 2014/2/25 8:34:44 2018/10/23 19:52:18 2018/10/23 19:52:18 13
85 		return false;
86 	}
88 	// 创建跨区副本助手
89 	if (m_EctypeAssist.Create() == false)
90 	{
96 		return false;
97 	}
98 	// 创建跨区竞技客户端系统
99 	if (m_StrikeClient.Create() == false)
100 	{
101 		return false;
102 	}
103 	// 创建跨区战争客户端系统
104 	if (m_WarClient.Create() == false)
105 	{
157 	// 关闭挑战假人系统客户端系统
158 	m_DummyClient.Release();
160 	// 关闭跨区战争客户端系统
161 	m_WarClient.Release();
161 	m_WarClient.Release();
163 	// 关闭跨区竞技客户端系统
164 	m_StrikeClient.Release();
166 	// 关闭服竞技撮合系统客户端
166 	// 关闭服竞技撮合系统客户端
167 	m_StrikeMatch.Release();
169 	// 关闭跨区副本助手
170 	m_EctypeAssist.Close();
172 	delete this;
172 	delete this;
173 }
175 /** 创建跨区助手部件
176 */
177 IEctypeAssistPart* CMatchClient::CreateEctypeAssistPart()
194 	return &m_StrikeMatch;
195 }
197 /** 取得跨区竞技系统接口
198 */
199 IStrikeClient* CMatchClient::GetStrikeClient()
201 	return &m_StrikeClient;
202 }
203 /** 取得跨区战场客户端系统接口定义
204 */
205 IWarClient* CMatchClient::GetWarClient()
220 }
222 //////////////////////////////////////////////////////////////////////////
224 // 取得跨区副本助手
225 CEctypeAssist& CMatchClient::GetCEctypeAssistInstance()
226 {
233 	return m_StrikeMatch;
234 }
235 // 取得跨区竞技系统
236 CStrikeClient& CMatchClient::GetStrikeClientInstance()
237 {
238 	return m_StrikeClient;
239 }
240 // 取得跨区战场客户端系统接口定义
241 CWarClient& CMatchClient::GetWarClientInstance()
242 {
3488 		}
3489 		break;
3490 	case MSG_MATCH_KQE:				//  跨区副本助手子消息
3491 		{
3492 			m_EctypeAssist.OnMessage(head, data, len);

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcClient\Client\MatchClient\EctypeAssistPart.cpp 8 KB CPP 文件 2014/2/25 8:34:42 2018/10/23 19:52:17 2018/10/23 19:52:17 2
5 ** 日  期:	2010-7-15
6 ** 版  本:	1.0
7 ** 描  述:	跨区副本助手部件
8 ** 应  用:  	
9 ********************************************************************/
102 	if (nLen != sizeof(SKqEctypePartContext) + sizeof(BYTE)+sizeof(SDummyDBInfo))
103 	{
104 		ErrorLn("[跨区副本部件 现场长度不对]");
105 		return false;
106 	}

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcClient\Client\MatchClient\EctypeAssist.cpp 2 KB CPP 文件 2014/2/25 8:34:42 2018/10/23 19:52:17 2018/10/23 19:52:17 1
5 ** 日  期:	2010-7-15
6 ** 版  本:	1.0
7 ** 描  述:	跨区副本助手
8 ** 应  用:  	
9 ********************************************************************/

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcClient\Client\MatchClient\CountryWar.cpp 13 KB CPP 文件 2014/2/25 8:34:41 2018/10/23 19:52:17 2018/10/23 19:52:17 2
5 ** 日  期:	2011-03-31
6 ** 版  本:	1.0
7 ** 描  述:	跨区国战
8 ** 应  用:  	
9 	
543 		{
544 			bHasDone = true;
546 			ErrorLn("跨区国战战场客户端系统有一个服务器战场信息子消息未处理，dwMsgCode = "<< dwMsgCode);
547 		}
548 		break;

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcClient\Client\MarryClient\TeachStudClient.cpp 33 KB CPP 文件 2014/2/25 8:34:37 2018/10/23 19:52:17 2018/10/23 19:52:17 2
350 	for (Iter=m_funcMap.begin(); Iter!=m_funcMap.end(); Iter++)
351 	{
352 		if (Iter->second.nType == EMST_FUNCT_TINFO && Iter->second.data == funcName && Iter->first>=0)// 只有序号大于0的才删（适应跨区作此修改）
353 		{
355 			if (nCurTime - Iter->second.nTime < 60)
396 	for (Iter=m_funcMap.begin(); Iter!=m_funcMap.end(); Iter++)
397 	{
398 		if (Iter->second.nType == EMST_FUNCT_SINFO && Iter->second.data == funcName && Iter->first>=0)// 只有序号大于0的才删（适应跨区作此修改）
399 		{
401 			if (nCurTime - Iter->second.nTime < 60)

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcClient\Client\EntityClient\SchemeZoneMatron.cpp 7 KB CPP 文件 2014/2/25 8:26:37 2018/10/23 19:51:20 2018/10/23 19:51:20 1
201 		// 禁止双人坐骑进入
202 		schemeInfo.bForbidBWM = pCSVReader->GetBool(i, 17, 0);
204 		// 不允许跨区传送
205 		schemeInfo.bForbidStarTrek = pCSVReader->GetBool(i, 18, 0);
207 		// 标志位

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcClient\Client\EntityClient\EntityClient.cpp 54 KB CPP 文件 2014/2/25 8:26:04 2018/10/23 19:51:14 2018/10/23 19:51:14 2
1048 	}
1049 	pHero->AddEntityPart(pSuitPart);
1051 	// 跨区副本部件
1052 	IEctypeAssistPart* pEctypeAssistPart = gGlobalClient->getMatchClient()->CreateEctypeAssistPart();
1053 	if(!pEctypeAssistPart->Create(pHero, NULL, 0))
1053 	if(!pEctypeAssistPart->Create(pHero, NULL, 0))
1054 	{
1055 		Error("通过默认数据构造Hero实体失败！-- 创建跨区副本部件" << endl);
1057 		SAFE_RELEASE(pEctypeAssistPart);
1059 		SAFE_RELEASE(pHero);

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcClient\Client\CountryClient\GameCountryAPI.cpp 42 KB CPP 文件 2014/2/25 8:25:21 2018/10/23 19:51:05 2018/10/23 19:51:05 3
600 			if (pBridgeCountry != NULL)
601 			{
602 				// 取跨区国家名称
603 				pBridgeCountry->GetWorldCountryName();
604 			}
633 		if (isPublicGameWorld())
634 		{
635 			// 跨区国家名称
636 			return pInfo->szWorldName;
637 		}
652 			if (pBridgeCountry != NULL)
653 			{
654 				// 取跨区国家名称
655 				return pBridgeCountry->GetWorldCountryName();
656 			}

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcClient\Client\CountryClient\BasePart.cpp 36 KB CPP 文件 2014/2/25 8:25:15 2018/10/23 19:51:03 2018/10/23 19:51:03 1
336 	}
338 	pStrData = pszMsg + sizeof(SMsgCountryBaseAnswerBuildClient_OC) + pMsg->nNameLen + pMsg->nTitleLen + pMsg->nLocalNameLen;
339 	// 取得跨区国家名称
340 	if (pMsg->nWorldNameLen>0)
341 	{

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcClient\Client\controller\SwitchAreaForm.cpp 6 KB CPP 文件 2014/2/25 8:37:10 2018/10/23 19:50:59 2018/10/23 19:50:59 1
5 ** 日  期:	2010-07-02
6 ** 版  本:	1.0
7 ** 描  述:	用于跨区切换过渡界面，（暂时没有启用）
8 ** 应  用:  
9 ******************************************************************/

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcClient\Client\controller\MH_MSG_LOGIN_LOADMAPNTF_PROCESSOR.cpp 3 KB CPP 文件 2014/2/25 8:37:04 2018/10/23 19:50:55 2018/10/23 19:50:55 1
74 	{			
75 		gGlobalClient->getSoundManager()->fading(1009, false);	//停止播放登入背景音乐		
77 		//跨区状态下发消息
78 		if (swtichAreaForm==eType)
79 		{

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcClient\Client\controller\GameForm.cpp 65 KB CPP 文件 2014/2/25 8:37:01 2018/10/23 19:50:53 2018/10/23 19:50:53 5
228 void GameForm::release()
229 {
230 	// 清除跨区数据
231 	memset(&m_switchAreaBuf, 0, sizeof(m_switchAreaBuf));
232 	m_bSwitchArea = false;
248 bool GameForm::create()
249 {
250 	// 清除跨区数据
251 	memset(&m_switchAreaBuf, 0, sizeof(m_switchAreaBuf));
252 	m_bSwitchArea = false;
1415 					}
1416 					SMsgLoginServer_AreaSwitchRes * pRes = (SMsgLoginServer_AreaSwitchRes *)data;
1418 					// 清除跨区数据
1419 					m_switchAreaBuf = *pRes;
1420 					m_bSwitchArea = true;
1451 					ISchemeCenter* pSchemeCenter = gGlobalClient->getEntityClient()->GetSchemeCenter();
1452 					if (pSchemeCenter != NULL && pSchemeCenter->GetGameBaseConfig(EGameConfig_Area)==EGameArea_StressTest)
1453 					{/* 压测区不启用跨区，所以先关闭
1454 						//char szCurRemoteIp[20] = {0};
1455 						LPCSTR szCurRemoteIp = NULL;
1841 }
1842 //end add
1845 // 重新连跨区网关
1846 void GameForm::ConnectNewAreaGateway()
1847 {

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcClient\Client\ChatClient\GMCommandManager.cpp 15 KB CPP 文件 2014/2/25 8:24:46 2018/10/23 19:50:39 2018/10/23 19:50:39 1
141 	REG_GM_CMD(GMCommand_Simple,				"prison",				4,	":prison 角色名,理由,显示给玩家的理由,分钟",		"蹲监牢",					RightFlag_Mute, true);
142 	REG_GM_CMD(GMCommand_Simple,				"checkzone",			1,	":checkzone 角色名",	 "查询玩家在公共区还是普通区",							RightFlag_ChangePos_Myself, true);
143 	REG_GM_CMD(GMCommand_Simple,				"hang",					0,	":hang",				 "跨区传送到默认位置",									RightFlag_ChangePos_Myself, true);
144 	REG_GM_CMD(GMCommand_ScanModeMd5,			"spex",					3,	":spex type,文件路径,flag",	 "扫描玩家是否具有指定对应md5码的进程，主要用于检测外挂，文件指定md5列表",			RightFlag_TrackUserPC, true);
145 	REG_GM_CMD(GMCommand_FileMd5,				"md5",					2,	":md5 角色名,文件路径",	 "扫描玩家是否具有指定对应md5码的进程，主要用于检测外挂，文件指定md5列表",			RightFlag_TrackUserPC, true);

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\TeachService\ResAdjustService.cpp 18 KB CPP 文件 2014/2/25 14:32:14 2018/10/23 19:46:52 2018/10/23 19:46:52 1
169 }
171 /**
172 @name         : 处理其他服务器通过跨区桥服务器转发的消息
173 @param actionId  : 消息码
174 @param bridgeHead  : 桥消息头

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\SocialServer\VoiceService.cpp 86 KB CPP 文件 2014/2/25 14:32:09 2018/10/23 19:46:51 2018/10/23 19:46:51 2
476 			}
477 			break;
479 		case MSG_VOICE_BRIDGEDATA:		// 发送消息到其他服务器，可跨区
480 			{
481 				OnMsgZoneBridgeData( actionId, head, data, len );
529 		}
530 		break;
532 	case MSG_VOICE_BRIDGEDATA:	// 发送消息到其他服务器，可跨区
533 		{
534 			OnVoiceBridgeData( actionId, voiceHead, head, data, len );

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\SocialServer\SchemeZoneMatron.cpp 7 KB CPP 文件 2014/2/25 14:32:07 2018/10/23 19:46:51 2018/10/23 19:46:51 1
201 		// 禁止双人坐骑进入
202 		schemeInfo.bForbidBWM = pCSVReader->GetBool(i, 17, 0);
204 		// 不允许跨区传送
205 		schemeInfo.bForbidStarTrek = pCSVReader->GetBool(i, 18, 0);
207 		// 标志位

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\SocialServer\GlobalSocialServer.cpp 64 KB CPP 文件 2014/2/25 14:32:01 2018/10/23 19:46:48 2018/10/23 19:46:48 22
166 	}
167 }
170 /// 启动跨区桥服务器连接器
171 void GlobalSocialServer::CreateBridgeConnector(void)
172 {
171 void GlobalSocialServer::CreateBridgeConnector(void)
172 {
173 	// 加载跨区桥服务器连接器设定
174 	Ini ini("Bridge.ini");
175 	std::string strBridgeServerIP = ini.getString("Setting","BridgeServerIP","127.0.0.1");
189 	if (nOpenBridge!=1)
190 	{
191 		WarningLn("跨区桥服务器连接禁用!");
192 		return;
193 	}
192 		return;
193 	}
194 	// 跨区桥服务器连接器连接
195 	TraceLn("连接跨区桥服务器:游戏世界ID="<<dwGameWorldID<<":"<<strWorldName.c_str()<<","<<strBridgeServerIP.c_str()<<":"<<nBridgeServerPort);
196 	if(!m_BridgeConnector->Connect(strBridgeServerIP.data(),nBridgeServerPort))
197 	{
196 	if(!m_BridgeConnector->Connect(strBridgeServerIP.data(),nBridgeServerPort))
197 	{
198 		TraceLn("连接跨区桥服务器失败!");
199 		return;
200 	}
199 		return;
200 	}
201 	//TraceLn("连接跨区桥服务器成功!");
203 	// 全部游戏世界加入事件
204 	m_BridgeConnector->registerEventHandler(EVENT_BRIDGE_WORLDLIST_ALL,static_cast<IBridgeEventHandler *>(this));
208 	m_BridgeConnector->registerEventHandler(EVENT_BRIDGE_WORLDLIST_EDIT,static_cast<IBridgeEventHandler *>(this));
209 }
210 /// 关闭跨区桥服务器连接器
211 void GlobalSocialServer::ReleaseBridgeConnector(void)
212 {
219 		// 修改游戏世界事件
220 		m_BridgeConnector->unregisterEventHandler(EVENT_BRIDGE_WORLDLIST_EDIT,static_cast<IBridgeEventHandler *>(this));
222 		// 关闭跨区桥服务器连接器
223 		TraceLn("关闭跨区桥服务器连接器!");
224 		m_BridgeConnector->Release();
225 		m_BridgeConnector = NULL;
384 	}
385 }
388 ////////// IBridgeEventHandler 处理处理跨区桥服务器执行事件 //////////////////
389 /** 
390 @param   wEventID ：事件ID
399 		return;
400 	}
401 	// 取得跨区桥服务器连接器接口
402 	if (NULL==m_BridgeConnector)
403 	{
437 	default:
438 		{
439 			ErrorLn("社会服务器尚有一个跨区桥服务器执行事件订阅了但未处理，wEventID = "<<wEventID);
440 		}
441 		break;
1159 			vanServerIP = DEFAULT_IP_ADDRESS;
1160 		int vanServerPort = ini.getInt("Network", "vanport", 8990);	
1162 		// 连接器连接跨区桥服务器
1163 		CREATE_BEGIN("CreateBridgeConnector......");
1164 		bool bBridgeConnectorOK = false;
1165 		if (NULL==m_BridgeConnector && NULL != m_ManagerConnector && m_ManagerConnector->GetWorldID()!=0)
1166 		{
1167 			// 启动跨区桥服务器连接器
1168 			CreateBridgeConnector();
1169 			if (NULL != m_BridgeConnector)
1526 		if ( NULL==m_pVoiceConnector && NULL != m_ManagerConnector && m_ManagerConnector->GetWorldID()!=0 )
1527 		{
1528 			// 启动跨区桥服务器连接器
1529 			CreateVoiceConnector();
1530 			if (NULL != m_pVoiceConnector)
1812 		/// 关闭语音服连接器
1813 		ReleaseVoiceConnector();
1815 		/// 关闭跨区桥服务器连接器
1816 		ReleaseBridgeConnector();
1818 		// 关闭管理连接器
1975 			dbParam.nOnlineAvgNum		= 0;					// 本区一分钟内平均在线人数
1976 			dbParam.nOnlineMinNum		= MAX_INT_VALUE;		// 本区一分钟内最小在线人数
1977 			dbParam.nOnlineAreaMaxNum	= 0;					// 跨区一分钟内最高在线人数 
1978 			dbParam.nOnlineAreaAvgNum	= 0;					// 跨区一分钟内平均在线人数 
1979 			dbParam.nOnlineAreaMinNum	= MAX_INT_VALUE;		// 跨区一分钟内最小在线人数
1981 			// 计算数据
1982 			DWORD dwRecCounts			= 0;			// 记录数
1982 			DWORD dwRecCounts			= 0;			// 记录数
1983 			double fTotalOnline			= 0.0;			// 本区在线人数汇总
1984 			double fTotalAreaOnline		= 0.0;			// 跨区在线人数汇总
1985 			for (TLIST_OnlineUserCountsInfo::iterator it=m_OnlineUserInfoList.begin();it!=m_OnlineUserInfoList.end();it++)
1986 			{
2012 			{
2013 				dbParam.nOnlineAvgNum		= (int)(fTotalOnline/(double)dwRecCounts);					// 本区一分钟内平均在线人数
2014 				dbParam.nOnlineAreaAvgNum	= (int)(fTotalAreaOnline/(double)dwRecCounts);				// 跨区一分钟内平均在线人数 
2015 			}
2017 			// 调整一下,最小无效情况

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\MiscService\BattleRideCampService.cpp 71 KB CPP 文件 2014/2/25 14:31:46 2018/10/23 19:46:43 2018/10/23 19:46:43 3
95 	if (pBridgeConnector != NULL)
96 	{
97 		// 订阅  跨区桥服务器连接器 MSG_MODULEID_BATTLERIDE_CAMP 消息
98 		pBridgeConnector->registerMessageHandler(MSG_MODULEID_BATTLERIDE_CAMP,this);
100 		pBridgeConnector->registerEventHandler(EVENT_BRIDGE_SERVERLIST_ADD, static_cast<IBridgeEventHandler*>(this));
152 	if (pBridgeConnector != NULL)
153 	{
154 		// 订阅  跨区桥服务器连接器 MSG_MODULEID_BATTLERIDE_CAMP 消息
155 		pBridgeConnector->unregisterMessageHandler(MSG_MODULEID_BATTLERIDE_CAMP);
157 		// 取消桥服务器事件订阅
654 }
656 /**
657 @name         : 处理其他服务器通过跨区桥服务器转发的消息
658 @param actionId  : 消息码
659 @param bridgeHead  : 桥消息头

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\MatchService\WarService.cpp 152 KB CPP 文件 2014/2/25 14:31:44 2018/10/23 19:46:42 2018/10/23 19:46:42 27
5 ** 日  期:	2011-03-19
6 ** 版  本:	1.0
7 ** 描  述:	跨区战场系统
8 ** 应  用:  	
9 	
49 }
51 /**
52 @name   : 创建跨区战场系统
53 */
54 bool CWarService::Create()
83 }
85 /**
86 @name   : 关闭跨区战场系统
87 */
88 void CWarService::Release()
731 	}
733 	// 所有的客户端更新Trackter信息
734 	// 遍历所有玩家 找出和发起者国家ID 相同 要求等级达到条件的玩家 通知其进入跨区国战战场
735 	UserInfo* pUserInfo = pUserManager->findFirstUser();
736 	while (pUserInfo != NULL)
836 		return;
837 	}
838 	// 取得跨区桥服务器连接器接口
839 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
840 	if (NULL == pBridgeConnector)
957 			if (dwSendServerID>0)
958 			{
959 				// 本区发送已存国战信息给公共区社会服消息 dwServerID:服务器ID ,跨区信息专用
960 				g_pMatchService->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_ExistCountryWarData,node.warInfo.dwID, dwClashCampID);
961 			}
1028 {
1029 	bool bAltered = false;
1031 	// 取得跨区桥服务器连接器接口
1032 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
1033 	if (NULL == pBridgeConnector)
1052 void CWarService::OnBridgeMsgExistCountryWarData(DWORD dwWarID, DWORD dwClashCampID)
1053 {
1054 	// 取得跨区桥服务器连接器接口
1055 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
1056 	if (NULL == pBridgeConnector)
1444 	default:
1445 		{
1446 			ErrorLn("跨区战场系统有一个子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
1447 		}
1448 		break;
1449 	}
1450 }
1452 //  处理跨区桥服务器发过来的消息
1453 void CWarService::HandleBridgeMessage(unsigned long actionId, SMsgBridgeHead &bridgeHead, SGameMsgHead* head, LPSTR data, size_t len)
1454 {
1618 		}
1619 		break;
1620 	case Match_WarMsg_RequestCountryInfo:		// 请求更新跨区共享国家信息
1621 		{
1622 			if (nNewlen>0)
1786 					sendData.dwPlayerID		= pOfficerInfo->dwPlayerID;			// 国王角色ID
1787 					sstrcpyn( sendData.szName, pOfficerInfo->szPlayerName, sizeof(sendData.szName));	// 玩家角色名称,由 玩家ID：dwPlayerID 关联取得
1789 					// 发跨区信息消息 dwServerID:服务器ID ,跨区信息专用
1790 					g_pMatchService->SendDataBridgeToServer(bridgeHead.dwServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_RequestKingInfo,dwWarID,0,0,(const char *)&sendData,sizeof(sendData));
1792 					break;
1889 	default:
1890 		{
1891 			ErrorLn("跨区战场系统有一个桥服务器发过来的子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
1892 		}
1893 		break;
1909 	//		if (dwSendServerID>0)
1910 	//		{
1911 	//			// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
1912 	//			return g_pMatchService->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_RequestNewCountryWar,node.dwType,0,0,(const char *)&node,sizeof(node));
1913 	//		}
2535 		sendData.dwCountryID		= dwCountryID;				// 目标国家ID
2536 		sendData.dwFlag				= dwFlag;					// 操作标识
2538 		//  请求检查跨服国战对方是否本区有国战 dwServerID:服务器ID ,跨区信息专用
2539 		g_pMatchService->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_RequestCheckCountryWar,0,0,0,(const char *)&sendData,sizeof(sendData));
2540 	}
2607 	if (dwSendServerID>0)
2608 	{
2609 		//  请求检查跨服国战对方是否本区有国战结果 dwServerID:服务器ID ,跨区信息专用
2610 		g_pMatchService->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_CheckCountryWarResult,dwResultFlag,0,0,(const char *)&node,sizeof(node));
2611 	}
2633 			if (dwSendServerID>0)
2634 			{
2635 				// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
2636 				g_pMatchService->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_RequestAddCountryWar,0,0,0,(const char *)&node,sizeof(node));
2637 			}
2643 	}
2644 }
2648 /*/ 跨区国战召集 功能
2649 @param	unsigned long actionId		: 消息ID
2650 @param	SMsgBridgeHead &bridgeHead	: 桥消息的消息头
2666 	}
2668 	SMsgMatchRequestRequestKqWarCall_SS * pMsg = (SMsgMatchRequestRequestKqWarCall_SS *)(data);
2670 	// 遍历所有玩家 找出和发起者国家ID 相同 要求等级达到条件的玩家 通知其进入跨区国战战场
2671 	UserInfo* pUserInfo = pUserManager->findFirstUser();
2672 	while (pUserInfo != NULL)
2706 		return false;
2707 	}
2709 	// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
2710 	return g_pMatchService->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_RequestAddCountryWarResult,dwWorldID,dwCountryID,dwFlag);
2711 }
3195 			if (dwSendServerID>0)
3196 			{
3197 				// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
3198 				return g_pMatchService->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_RequestAddClanBossWar,0,0,0,data,len);
3199 			}
3984 	}
3986 	//////////////////////////////////////////////////////////////////////////
3987 	// 按算法重连所有跨区国家连接
3989 	// 要连接的战场配置项定义
3990 	static DWORD dwMatchLinkTypeList[1] =

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\MatchService\StrikeService.cpp 39 KB CPP 文件 2014/2/25 14:31:43 2018/10/23 19:46:42 2018/10/23 19:46:42 8
5 ** 日  期:	2010-10-29
6 ** 版  本:	1.0
7 ** 描  述:	跨区竞技系统
8 ** 应  用:  	
9 	
32 }
34 /**
35 @name   : 创建跨区竞技系统
36 */
37 bool CStrikeService::Create()
47 }
49 /**
50 @name   : 关闭跨区竞技系统
51 */
52 void CStrikeService::Release()
364 			continue;
365 		}
366 		// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
367 		g_pMatchService->SendDataBridgeToServer(dwServerArray[i],MSG_MATCH_DATE_PKMSG,Match_PKMsg_UpdatePubIdleRate,dwStrikeServerIdleRate,0,0);
368 	}
1097 	default:
1098 		{
1099 			ErrorLn("跨区竞技系统有一个子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
1100 		}
1101 		break;
1102 	}
1103 }
1105 //  处理跨区桥服务器发过来的消息
1106 void CStrikeService::HandleBridgeMessage(unsigned long actionId, SMsgBridgeHead &bridgeHead, SGameMsgHead* head, LPSTR data, size_t len)
1107 {
1149 	default:
1150 		{
1151 			ErrorLn("跨区竞技系统有一个桥服务器发过来的子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
1152 		}
1153 		break;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\MatchService\StrikeMatch.cpp 73 KB CPP 文件 2014/2/25 14:31:42 2018/10/23 19:46:42 2018/10/23 19:46:42 5
575 	}
577 }
579 //  处理跨区桥服务器发过来的消息
580 void CStrikeMatch::HandleBridgeMessage(unsigned long actionId, SMsgBridgeHead &bridgeHead, SGameMsgHead* head, LPSTR data, size_t len)
581 {
912 		if (iter==m_mapMatchRequest.end())
913 		{
914 			// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
915 			g_pMatchService->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_CSMSG,Match_CSMsg_RequestCheckCancelMatch,dwActorID,dwWorldID,1);
916 		}
1026 				if (dwSendServerID>0)
1027 				{
1028 					// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
1029 					return g_pMatchService->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_CSMSG,Match_CSMsg_RequestAddMatch,dwMatchTypeID,0,0,data,len);
1030 				}

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\MatchService\MatchService.cpp 284 KB CPP 文件 2014/2/25 14:31:40 2018/10/23 19:46:42 2018/10/23 19:46:42 50
176 		return false;
177 	}
179 	// 创建跨区副本保姆
180 	if (m_EctypeAssist.Create() == false)
181 	{
188 		return false;
189 	}
190 	// 创建跨区竞技系统
191 	if (m_StrikeService.Create() == false)
192 	{
193 		return false;
194 	}
195 	// 跨区战场系统
196 	if (m_WarService.Create() == false)
197 	{
213 		return false;
214 	}
216 	// 订阅  跨区桥服务器连接器 MSG_MODULEID_MATCH 消息
217 	pBridgeConnector->registerMessageHandler(MSG_MODULEID_MATCH,static_cast<IBridgeMessageHandler*>(this));
218 	pBridgeConnector->registerEventHandler(EVENT_BRIDGE_SERVERLIST_ADD, static_cast<IBridgeEventHandler*>(this));
259 void CMatchService::Release()
260 {
262 	// 取消订阅 取得跨区桥服务器连接器MSG_MODULEID_MATCH消息
263 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
264 	if (pBridgeConnector != NULL)
315 	// 关闭挑战系统
316 	m_DummyService.Release();
317 	// 关闭跨区战场系统
318 	m_WarService.Release();
318 	m_WarService.Release();
319 	// 关闭跨区竞技系统
320 	m_StrikeService.Release();
321 	// 关闭跨服竞技撮合系统
321 	// 关闭跨服竞技撮合系统
322 	m_StrikeMatch.Release();
323 	// 关闭跨区副本保姆
324 	m_EctypeAssist.Close();
327 	delete this;
2680 	return bIsOpen;
2681 }
2683 /** 取得跨区副本接口
2684 */
2685 IEctypeAssist* CMatchService::GetEctypeAssist()
2694 	return &m_StrikeMatch;
2695 }
2697 /** 取得跨区竞技系统接口
2698 */
2699 IStrikeService* CMatchService::GetStrikeService()
2701 	return &m_StrikeService;
2702 }
2704 /** 取得跨区战场系统接口
2705 */
2706 IWarService* CMatchService::GetWarService()
2721 }
2723 //////////////////////////////////////////////////////////////////////////
2724 // 取得跨区副本
2725 CEctypeAssist& CMatchService::GetEctypeAssistInstance()
2726 {
2732 	return m_StrikeMatch;
2733 }
2734 // 取得跨区竞技系统
2735 CStrikeService& CMatchService::GetStrikeServiceInstance()
2736 {
2737 	return m_StrikeService;
2738 }
2739 // 取得跨区战争系统
2740 CWarService& CMatchService::GetWarServiceInstance()
2741 {
2794 		return;
2795 	}
2796 	// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
2797 	g_pMatchService->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_SUBMSG,Match_SubMsg_WorldOnlineUserAdd,info.id,info.worldId,(DWORD)nMode);
2800 }
2829 		return;
2830 	}
2831 	// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
2832 	g_pMatchService->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_SUBMSG,Match_SubMsg_WorldOnlineUserRemove,info.id,info.worldId,(DWORD)nMode);
2833 }
2840 }
2842 //////////////////////////////////////////////////////////////////////////
2844 // 发跨区信息消息 dwServerID:服务器ID ,跨区信息专用
2845 bool CMatchService::SendDataBridgeToServer(DWORD dwServerID,WORD wKeyAction,DWORD dwMsgCode,DWORD dwUserData1,DWORD dwUserData2,DWORD dwUserData3,const char * pData,DWORD dwLen)
2846 {
3024 					OnMsgMatchSubMsg(header.DestEndPoint,wKeyAction,&header,obufData.data(),obufData.size());
3025 				}
3026 				else if (MSG_MATCH_KQE==wKeyAction)			// 跨区副本保姆子消息
3027 				{
3028 					m_EctypeAssist.OnMessage(header.DestEndPoint,wKeyAction,&header,obufData.data(),obufData.size());
3074 		header.DestEndPoint= MSG_ENDPOINT_BRIDGE;
3075 		header.wKeyModule  = MSG_MODULEID_MATCH;
3076 		header.wKeyAction  = MSG_MATCH_BRIDGE_DATA;			// 跨区中转消息
3078 		DWORD nDataLens = sizeof(SMsgMatchDataSubMsg)+dwLen;
3080 		SMsgMatchBridgeData headData;
3497 				if (pUserInfo->worldId==dwSendInfWorldID)
3498 				{
3499 					// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
3500 					g_pMatchService->SendDataBridgeToServer(pData->dwID,MSG_MATCH_DATE_SUBMSG,Match_SubMsg_WorldOnlineUserAdd,pUserInfo->id,pUserInfo->worldId,loginXlogout_Mode_Offline);
3501 				}
3563 }
3566 //////////////////IBridgeMessageHandler////////////////////////////////////////////////////////
3568 /** 处理跨区桥服务器发过来的消息
3569 @name         : 处理其他服务器通过跨区桥服务器转发的消息
3570 @param actionId  : 消息码
3571 @param bridgeHead  : 桥消息头
3583 		}
3584 		break;
3585 	case MSG_MATCH_KQE:	// 跨区副本保姆子消息
3586 		{
3587 			m_EctypeAssist.HandleBridgeMessage(actionId,bridgeHead, head, data, len);
3588 		}
3589 		break;
3590 	case MSG_MATCH_BRIDGE_DATA: // 跨区中转消息
3591 		{
3592 			OnBridgeMsgMatchBridgeData(actionId,bridgeHead, head, data, len);
3643 		}
3644 		break;
3645 	case MSG_MATCH_KQE:		// 跨区副本保姆子消息
3646 		{
3647 			m_EctypeAssist.OnMessage(endpointId,actionId,head,data,len);
3976 				break;
3977 			}
3978 			// 跨区撮合,不是跨区不处理 ,|| bridgeHead.dwWorldID!=pRequestHead->dwWorldID
3979 			if (MatchTypeID_PublicFuBen!=pMsg->dwUserData1 )
3980 			{
4000 				break;
4001 			}
4002 			// 跨区撮合,不是跨区不处理 ,|| bridgeHead.dwWorldID!=pRequestHead->dwWorldID
4003 			if (MatchTypeID_PublicFuBen!=pMsg->dwUserData1 )
4004 			{
4053 		}
4054 		break;
4055 	case Match_SubMsg_RequestLookWorldEquip:		// 请求跨区查看玩家装备
4056 		{
4057 			if (nNewlen!=sizeof(SMsgActionWorldLookEquip_SC))
4061 			DWORD dwActorID		= pMsg->dwUserData1;				// 要查看装备角色ID
4062 			DWORD dwWorldID		= pMsg->dwUserData2;				// 信息来源游戏世界ID
4064 			// 请求跨区查看玩家装备
4065 			RequestLookWorldEquip(dwActorID,dwWorldID,bridgeHead.dwServerID,pMsgData,nNewlen);
4066 		}
4081 		}
4082 		break;
4083 	case Match_SubMsg_WorldOnlineUserAdd:		//  跨区用户上线
4084 		{
4085 			if (nNewlen>0)
4090 			DWORD dwWorldID			= pMsg->dwUserData2;				// 游戏世界ID
4091 			DWORD dwUserData		= pMsg->dwUserData3;				// 数据
4093 			// 跨区用户上线
4094 			OnMsgWorldOnlineUserAdd(dwActorID,dwWorldID,dwUserData);
4095 		}
4095 		}
4096 		break;
4097 	case Match_SubMsg_WorldOnlineUserRemove:		//  跨区用户下线
4098 		{
4099 			if (nNewlen>0)
4104 			DWORD dwWorldID			= pMsg->dwUserData2;				// 游戏世界ID
4105 			DWORD dwUserData		= pMsg->dwUserData3;				// 数据
4107 			// 跨区用户上线
4108 			OnMsgWorldOnlineUserRemove(dwActorID,dwWorldID,dwUserData);
4109 		}
4151 	}	
4152 }
4155 // 跨服 跨区中转消息
4156 void CMatchService::OnBridgeMsgMatchBridgeData(unsigned long actionId, SMsgBridgeHead &bridgeHead, SGameMsgHead* head, LPSTR data, size_t len)
4157 {
4167 	// 调式代码
4168 	char szBuf[512]={0};
4169 	sprintf_s(szBuf, _countof(szBuf),_NGT"CMatchService::OnBridgeMsgMatchBridgeData()  跨服  跨区中转消息:目标端点码=%d,角色来自游戏世界ID=%d,角色ID=%d,行为消息码=%d,数据长度=%d",
4170 		pMsg->nDestEndPoint,pMsg->dwFromWorldID,pMsg->dwActorID,pMsg->wKeyAction,pMsg->nDataLens);
4171 	TraceLn(szBuf);
4177 	if (nNewlen!=pMsg->nDataLens)
4178 	{
4179 		ErrorLn(" 跨区中转消息信息数据与大小不符，nDataLens="<<pMsg->nDataLens<<" ,nLen = "<<nNewlen);
4180 		return;
4181 	}
4183 	if (nNewlen<sizeof(SMsgMatchDataSubMsg))
4184 	{
4185 		ErrorLn(" 跨区中转消息信息数据与大小不符，nDataLens="<<pMsg->nDataLens<<" ,nLen = "<<nNewlen);
4186 		return;
4187 	}
4237 				OnMsgMatchSubMsg(header.DestEndPoint,pMsg->wKeyAction,&header,pMsgData,nNewlen);
4238 			}
4239 			else if (MSG_MATCH_KQE==pMsg->wKeyAction)			// 跨区副本保姆子消息
4240 			{
4241 				m_EctypeAssist.OnMessage(header.DestEndPoint,pMsg->wKeyAction,&header,pMsgData,nNewlen);
4250 }
4251 //////////////////////////////////////////////////////////////////////////
4252 // 跨区用户上线
4253 void CMatchService::OnMsgWorldOnlineUserAdd(DWORD dwActorID,DWORD dwWorldID,DWORD dwUserData)
4254 {
4277 	// 调式代码
4278 	char szBuf[512]={0};
4279 	sprintf_s(szBuf, _countof(szBuf),_NGT"CMatchService::OnMsgWorldOnlineUserAdd() 跨区用户上线:角色来自游戏世界ID=%d,角色ID=%d,上线类型=%d",
4280 		dwWorldID,dwActorID,dwUserData);
4281 	TraceLn(szBuf);
4282 #endif
4284 }
4285 // 跨区用户下线
4286 void CMatchService::OnMsgWorldOnlineUserRemove(DWORD dwActorID,DWORD dwWorldID,DWORD dwUserData)
4287 {
4305 	// 调式代码
4306 	char szBuf[512]={0};
4307 	sprintf_s(szBuf, _countof(szBuf),_NGT"CMatchService::OnMsgWorldOnlineUserRemove() 跨区用户下线:角色来自游戏世界ID=%d,角色ID=%d,下线类型=%d",
4308 		dwWorldID,dwActorID,dwUserData);
4309 	TraceLn(szBuf);
5466 	return true;
5467 }
5470 // 请求跨区查看玩家装备
5471 bool CMatchService::RequestLookWorldEquip(DWORD dwActorID,DWORD dwWorldID,DWORD dwFromServerID,const char * pData,DWORD dwLen)
5472 {
5475 		return false;
5476 	}
5477 	// 跨区查看玩家装备
5478 	SMsgActionWorldLookEquip_SC *pMsg = (SMsgActionWorldLookEquip_SC *)pData;
5480 	// 查找用户

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\MatchService\ExternalFacade.cpp 34 KB CPP 文件 2014/2/25 14:31:38 2018/10/23 19:46:42 2018/10/23 19:46:42 2
1231 		}
1232 	}
1234 	// 公共区取跨区国家名称
1235 	if (bLocal)
1236 	{
1253 	else
1254 	{
1255 		// 取得跨区桥服务器连接器接口
1256 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
1257 		if (NULL != pBridgeConnector)

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\MatchService\EctypeAssist.cpp 22 KB CPP 文件 2014/2/25 14:31:37 2018/10/23 19:46:42 2018/10/23 19:46:42 16
5 ** 日  期:	2010/07/14
6 ** 版  本:	1.0
7 ** 描  述:	跨区副本助手
8 ** 应  用:  
9 ********************************************************************/
26 }
28 /**
29 @name   : 创建跨区副本保姆
30 */
31 bool CEctypeAssist::Create()
39 }
41 /**
42 @name   : 关闭跨区副本保姆
43 */
44 void CEctypeAssist::Close()
243 	return emCreateKqe_ok;
244 }
246 /** 取得跨区副本信息
247 */
248 const SKqEctypeScheme* CEctypeAssist::GetKqEctypeScheme(WORD wTypeID)
256 	return &(it->second);
257 }
259 /** 取得跨区副本配置信息
260 */
261 const SKqEctypeConfig* CEctypeAssist::GetKqEctypeConfig()
361 		default:
362 			{
363 				ErrorLn("跨区副本保姆有一个服务器撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
364 			}
365 			break;
367 	}
368 }
370 /** 解析跨区桥服务器来的消息，子消息码为MSG_MATCH_GLOBALECTYPE
371 */
372 void CEctypeAssist::HandleBridgeMessage(unsigned long actionId, SMsgBridgeHead &bridgeHead, SGameMsgHead* head, LPSTR data, size_t len)
382 	// 调式代码
383 	char szBuf[512]={0};
384 	sprintf_s(szBuf, _countof(szBuf),_NGT"CEctypeAssist::HandleBridgeMessage()  解析跨区桥服务器来的消息:来源游戏世界ID=%d,来源服务器ID=%d,子消息代码=%d,len=%d,用户数据=%d,%d,%d",
385 		bridgeHead.dwWorldID,bridgeHead.dwServerID,pMsg->dwMsgCode,len,pMsg->dwUserData1,pMsg->dwUserData2,pMsg->dwUserData3);
386 	TraceLn(szBuf);
416 	default:
417 		{
418 			ErrorLn("跨区副本保姆有一个跨服撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
419 		}
420 		break;
432 		return false;
433 	}
435 	// 跨区副本配置脚本
436 	string strPath;
437 	if (isPublicGameWorld() == true)
453 	return true;
454 }
456 /// purpose:  加载跨区副本配置脚本
457 bool CEctypeAssist::LoadKqEctypeScheme(ICSVReader * pCSVReader)
458 {
485 		if (nCount != 2)
486 		{
487 			ErrorLn("跨区副本配置脚本" << "限制开始时间 配置错误");
488 			return false;
489 		}
500 		if (nCount != 2)
501 		{
502 			ErrorLn("跨区副本配置脚本" << "限制结束时间 配置错误");
503 			return false;
504 		}
708 	pTeam->DoLeave(dwPDBID);
709 }
711 /** 创建一个跨区副本
712 */
713 void CEctypeAssist::OnBridgePersonZone(SMsgBridgeHead &bridgeHead, SMsgMatchDataSubMsg* pSubMsg, LPSTR pszMsg, size_t nLen)
755 				if (pCall->bDeleteOffLine == true)
756 				{
757 					// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
758 					g_pMatchService->SendDataBridgeToServer(dwSrcBriServerID, MSG_MATCH_KQE, MSG_KQE_CALL_CANCEL, pTransMsg->dwPDBID, pCall->dwSerialID, 1, NULL, 0);
759 				}

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\MatchService\DummyService.cpp 45 KB CPP 文件 2014/2/25 14:31:36 2018/10/23 19:46:41 2018/10/23 19:46:41 4
40 }
42 /**
43 @name   : 创建跨区竞技系统
44 */
45 bool CDummyService::Create()
50 }
52 /**
53 @name   : 关闭跨区竞技系统
54 */
55 void CDummyService::Release()
1336 }
1338 //////////////////////////////////////////////////////////////////////////
1339 //  处理跨区桥服务器发过来的消息
1340 void CDummyService::HandleBridgeMessage(unsigned long actionId, SMsgBridgeHead &bridgeHead, SGameMsgHead* head, LPSTR data, size_t len)
1341 {
1366 	default:
1367 		{
1368 			ErrorLn("跨区竞技系统有一个桥服务器发过来的子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
1369 		}
1370 		break;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\MatchService\BudoService.cpp 87 KB CPP 文件 2014/2/25 14:31:35 2018/10/23 19:46:41 2018/10/23 19:46:41 4
68 }
70 /**
71 @name   : 创建跨区竞技系统
72 */
73 bool CBudoService::Create()
76 }
78 /**
79 @name   : 关闭跨区竞技系统
80 */
81 void CBudoService::Release()
1626 }
1628 //////////////////////////////////////////////////////////////////////////
1629 //  处理跨区桥服务器发过来的消息
1630 void CBudoService::HandleBridgeMessage(unsigned long actionId, SMsgBridgeHead &bridgeHead, SGameMsgHead* head, LPSTR data, size_t len)
1631 {
1656 	default:
1657 		{
1658 			ErrorLn("跨区竞技系统有一个桥服务器发过来的子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
1659 		}
1660 		break;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\LuaService\LuaAPI.cpp 97 KB CPP 文件 2014/2/25 14:31:26 2018/10/23 19:46:39 2018/10/23 19:46:39 5
1526 }
1528 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
1529 /**************************************  跨区相关 ***********************************************************/
1530 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
1531 /** 是否是公共区
2233 		return false;
2234 	}
2235 	// 取得跨区战场系统接口
2236 	IWarService* pWarService = pMatchService->GetWarService();
2237 	if (NULL==pWarService)
2293 		return false;
2294 	}
2295 	// 取得跨区战场系统接口
2296 	IWarService * pWarService = pMatchService->GetWarService();
2297 	if(pWarService==NULL)
2346 		return false;
2347 	}
2348 	// 取得跨区战场系统接口
2349 	IWarService * pWarService = pMatchService->GetWarService();
2350 	if(pWarService==NULL)
2396 		return false;
2397 	}
2398 	// 取得跨区战场系统接口
2399 	IWarService * pWarService = pMatchService->GetWarService();
2400 	if(pWarService==NULL)

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\KinService\KinService.cpp 141 KB CPP 文件 2014/2/25 14:31:18 2018/10/23 19:46:37 2018/10/23 19:46:37 5
1469 		if (pEvent->dwWorldID == pBridgeConnector->GetPublicWorldID() && pEvent->wServerType == MSG_ENDPOINT_SOCIAL)
1470 		{
1471 			// TraceLn("[跨区家族] 公共区连接桥服务器：dwWorldID=" << pEvent->dwWorldID);
1473 			// 把本地的所有家族信息都发给公共区
1474 			TMap_Kin::iterator it;
1477 				CKin* pKin = it->second;
1478 				
1479 				// TraceLn("[跨区家族] 向公共区同步家族信息：kinID=" << pKin->GetNumProp(emKinProp_ID));
1481 				pKin->SynchToPublicServer();
1482 			}
1484 	}
1485 }
1487 /// purpose: 处理其他服务器通过跨区桥服务器转发的消息
1488 //@ param: actionId 消息码
1489 //@ param: bridgeHead 桥消息头
2794 	// 把数据同步到公共区
2795 	pKin->SynchToPublicServer();
2797 	// TraceLn("[跨区家族] 向公共区同步家族信息：kinID=" << pKin->GetNumProp(emKinProp_ID));
2798 }
2800 /// purpose: 成员上线
3005 	{
3006 		CKin* pKin = itKin->second;
3008 		// TraceLn("[跨区家族] 向公共区同步家族最基本信息：kinID=" << pKin->GetNumProp(emKinProp_ID));
3010 		pKin->SynchKinHeadToPublic();
3011 	}

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\KinService\Kin.cpp 195 KB CPP 文件 2014/2/25 14:31:16 2018/10/23 19:46:37 2018/10/23 19:46:37 1
4150 void CKin::OnClientKinLargess(UserInfo* pUserInfo, LPCSTR pszData, size_t nLen)
4151 {
4153 	// 取得跨区桥服务器连接器接口
4154 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
4155 	

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\KinService\ComKinService.cpp 22 KB CPP 文件 2014/2/25 14:31:13 2018/10/23 19:46:36 2018/10/23 19:46:36 4
227 	}
228 }
230 /// purpose: 处理其他服务器通过跨区桥服务器转发的消息
231 //@ param: actionId 消息码
232 //@ param: bridgeHead 桥消息头
236 void CComKinService::HandleBridgeMessage(unsigned long actionId, SMsgBridgeHead &bridgeHead, SGameMsgHead* head, LPSTR data, size_t len)
237 {
238 	// TraceLn("[跨区家族] 收到桥服务器来的消息：actionId=" << actionId);
240 	switch (actionId)
241 	{
541 		return;
542 	}
544 	// TraceLn("[跨区家族 公共区] 收到家族信息： 家族ID=" << pUpdateKin->dwID);
545 	CKin* pKin = FindKin(pUpdateKin->dwID);
546 	if (pKin != NULL)
627 		return;
628 	}
630 	// TraceLn("[跨区家族 公共区] 家族最基本信息： 家族ID=" << pUpdateKin->dwID);
632 	CKin* pKin = FindKin(pUpdateKin->dwID);
633 	if (pKin != NULL)

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\FriendService\FriendService.cpp 42 KB CPP 文件 2014/2/25 14:31:06 2018/10/23 19:46:35 2018/10/23 19:46:35 1
1333 	return static_cast<IFriendService*>(impl);
1334 }
1337 /// purpose: 处理其他服务器通过跨区桥服务器转发的消息
1338 //@ param: actionId 消息码
1339 //@ param: bridgeHead 桥消息头

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\FriendService\Friend.cpp 39 KB CPP 文件 2014/2/25 14:31:05 2018/10/23 19:46:35 2018/10/23 19:46:35 1
228 		if (pComFriendService == NULL || pComFriendService->IsStressTestArea() == true)
229 		{
230 			// 压测目前暂时不支持跨区好友聊天
231 			return;
232 		}

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\FriendService\ComFriendService.cpp 6 KB CPP 文件 2014/2/25 14:31:03 2018/10/23 19:46:35 2018/10/23 19:46:35 1
169 	return true;
170 }
172 /// purpose: 处理其他服务器通过跨区桥服务器转发的消息
173 //@ param: actionId 消息码
174 //@ param: bridgeHead 桥消息头

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\CountryService\GameCountryAPI.cpp 69 KB CPP 文件 2014/2/25 14:30:54 2018/10/23 19:46:34 2018/10/23 19:46:34 13
432 		}
433 	}
435 	// 公共区取跨区国家名称
436 	if (bLocal)
437 	{
457 	else
458 	{
459 		// 取得跨区桥服务器连接器接口
460 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
461 		if (NULL != pBridgeConnector)
598 		}
599 	}
601 	// 公共区取跨区国家名称
602 	if (bLocal)
603 	{
611 	else
612 	{
613 		// 取得跨区桥服务器连接器接口
614 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
615 		if (NULL != pBridgeConnector)
661 		}
662 	}
664 	// 公共区取跨区国家名称
665 	if (bLocalName)
666 	{
674 	else
675 	{
676 		// 取得跨区桥服务器连接器接口
677 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
678 		if (NULL != pBridgeConnector)
750 		}
751 	}
753 	// 公共区取跨区国家名称
754 	if (bLocal)
755 	{
768 	else
769 	{
770 		// 取得跨区桥服务器连接器接口
771 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
772 		if (NULL != pBridgeConnector)
834 	else
835 	{
836 		// 通过跨区桥服务器连接器接口取得国家群组号
837 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
838 		if (NULL != pBridgeConnector)
914 	else
915 	{
916 		// 通过跨区桥服务器连接器接口取得国家群组号
917 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
918 		if (NULL != pBridgeConnector)
1003 	else
1004 	{
1005 		// 通过跨区桥服务器连接器接口取得国家群组号
1006 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
1007 		if (NULL != pBridgeConnector)
1103 	else
1104 	{
1105 		// 通过跨区桥服务器连接器接口取得国家群组号
1106 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
1107 		if (NULL != pBridgeConnector)
1205 	else
1206 	{
1207 		// 通过跨区桥服务器连接器接口取得国家群组号
1208 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
1209 		if (NULL != pBridgeConnector)

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\CountryService\CountryService.cpp 199 KB CPP 文件 2014/2/25 14:30:51 2018/10/23 19:46:33 2018/10/23 19:46:33 12
170 	// 添加观察者
171 	pUserManager->addObserver(static_cast<IUserManagerObserver *>(this));
173 	// 取得跨区桥服务器连接器接口
174 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
175 	if (NULL==pBridgeConnector)
177 		return false;
178 	}
179 	// 订阅  跨区桥服务器连接器 MSG_MODULEID_COUNTRY 消息
180 	pBridgeConnector->registerMessageHandler(MSG_MODULEID_COUNTRY,this);
182 	// 全部游戏世界加入事件
277 		pUserManager->removeObserver(static_cast<IUserManagerObserver *>(this));
278 	}
280 	// 取得跨区桥服务器连接器接口
281 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
282 	if (NULL!=pBridgeConnector)
690 	return bRet;
691 }
694 ////////////// IBridgeEventHandler 处理处理跨区桥服务器执行事件 ////////////////////////////////////////////////////////////
696 /** 处理处理跨区桥服务器执行事件
697 @param   wEventID ：事件ID
698 @param   pszContext : 上下文
706 		return;
707 	}
708 	// 取得跨区桥服务器连接器接口
709 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
710 	if (NULL==pBridgeConnector)
759 	default:
760 		{
761 			ErrorLn("国家社会服务器尚有一个跨区桥服务器执行事件订阅了但未处理，wEventID = "<<wEventID);
762 		}
763 		break;
765 }
768 //////////////////IBridgeMessageHandler////////////////////////////////////////////////////////
770 /** 处理跨区桥服务器发过来的消息
771 @name         : 处理其他服务器通过跨区桥服务器转发的消息
772 @param actionId  : 消息码
773 @param bridgeHead  : 桥消息头
4167 void CCountryService::UpdateWorldListToClient(DWORD dwClientID,BYTE nUpdateType,DWORD dwUpdateWorldID)
4168 {
4169 	// 取得跨区桥服务器连接器接口
4170 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
4171 	if (NULL==pBridgeConnector)
4300 void CCountryService::UpdateWorldCountryToClient(DWORD dwClientID,BYTE nUpdateType,DWORD dwWorldID,DWORD dwServerID,DWORD dwCountryID)
4301 {
4302 	// 取得跨区桥服务器连接器接口
4303 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
4304 	if (NULL==pBridgeConnector)
4419 void CCountryService::SendWorldCountryToBridgeServer(DWORD dwServerID,DWORD dwCountryID)
4420 {
4421 	// 取得跨区桥服务器连接器接口
4422 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
4423 	if (NULL==pBridgeConnector)

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\CountryService\BasePart.cpp 133 KB CPP 文件 2014/2/25 14:30:49 2018/10/23 19:46:33 2018/10/23 19:46:33 24
1114 	sstrcpyn(saveParam.szLocalName, m_CountryBaseInfo.szLocalName, sizeof(saveParam.szLocalName));
1115 	
1116 	// 跨区国家名称
1117 	sstrcpyn(saveParam.szWorldName, m_CountryBaseInfo.szWorldName, sizeof(saveParam.szWorldName));
1119 	// 修改
2152 	// 本区国家短名称
2153 	sstrcpyn(m_CountryBaseInfo.szLocalName, m_CountryBaseInfo.szName, sizeof(m_CountryBaseInfo.szLocalName));
2154 	// 跨区国家名称
2155 	sprintf_s(m_CountryBaseInfo.szWorldName, sizeof(m_CountryBaseInfo.szWorldName), "%s%s", g_ExternalFacade.GetWorldName(dwWorldID), m_CountryBaseInfo.szName);
2157 	AddCountry(addparam);
2250 	// 本区国家短名称
2251 	sstrcpyn(stSaveParam.szLocalName, m_CountryBaseInfo.szLocalName, sizeof(stSaveParam.szLocalName));
2253 	// 跨区国家名称
2254 	sstrcpyn(stSaveParam.szWorldName, m_CountryBaseInfo.szWorldName, sizeof(stSaveParam.szWorldName));
2255 	//
2483 	// 本区国家短名称
2484 	sstrcpyn(m_CountryBaseInfo.szLocalName, pDBReqCountryBase->szLocalName, sizeof(m_CountryBaseInfo.szLocalName));
2486 	// 跨区国家名称
2487 	sstrcpyn(m_CountryBaseInfo.szWorldName, pDBReqCountryBase->szWorldName, sizeof(m_CountryBaseInfo.szWorldName));
2489 	// 所属数据库游戏世界名称
2498 #ifdef COUNTRY_PRINT_DEBUG_INF
2499 	// 调式代码
2500 	sprintf_s(szBuf, _countof(szBuf),_NGT" 读取国家数据:国家ID=%d,国家名称=%s,等级=%d,等级名=%s,强大程度=%d,文明点数=%d,金钱=%d,木材=%d,粮草=%d,交易税收=%d,官员俸禄=%d,军队俸禄=%d,功勋兑换=%d,文官上限=%d,将军上限=%d,巡捕上限=%d,诸侯上限=%d,候相上限=%d,国王ID=%d,本区国家短名称=%s,跨区国家名称=%s,所属数据库游戏世界名称=%s",
2501 		m_CountryBaseInfo.dwID,m_CountryBaseInfo.szName,m_CountryBaseInfo.nLevel,m_CountryBaseInfo.szLevelName,
2502 		m_CountryBaseInfo.dwPower,m_CountryBaseInfo.dwPiont,m_CountryBaseInfo.dwMoney,m_CountryBaseInfo.dwWood,m_CountryBaseInfo.dwFood,
2801 	// 调式代码
2802 	char szBuf[512]={0};
2803 	sprintf_s(szBuf, _countof(szBuf),_NGT"CBasePart::SendBaseToServer() 社会服务器发送场景服数据:dwZoneServerID=%d,国家ID=%d,国家名称=%s,等级=%d,等级名=%s,强大程度=%d,文明点数=%d,金钱=%d,木材=%d,粮草=%d,交易税收=%d,官员俸禄=%d,军队俸禄=%d,功勋兑换=%d,文官上限=%d,将军上限=%d,巡捕上限=%d,诸侯上限=%d,侯相上限=%d,国王ID=%d,本区国家短名称=%s,跨区国家名称=%s",
2804 		dwZoneServerID,m_CountryBaseInfo.dwID,m_CountryBaseInfo.szName,m_CountryBaseInfo.nLevel,m_CountryBaseInfo.szLevelName,
2805 		m_CountryBaseInfo.dwPower,m_CountryBaseInfo.dwPiont,m_CountryBaseInfo.dwMoney,m_CountryBaseInfo.dwWood,m_CountryBaseInfo.dwFood,
2841 	sendData.nTitleLen				= strlen(m_CountryBaseInfo.szTitle);				// 国家公告长度
2842 	sendData.nLocalNameLen			= strlen(m_CountryBaseInfo.szLocalName);			// 本区国家短名称长度
2843 	sendData.nWorldNameLen			= strlen(m_CountryBaseInfo.szWorldName);			// 跨区国家名称长度
2844 	sendData.nDBWorldNameLen		= strlen(m_CountryBaseInfo.szDBWorldName);			// 所属数据库游戏世界名称长度
2846 	if (sendData.nNameLen>=COUNTRY_NAME_MAXSIZE)
2857 		sendData.nLocalNameLen = COUNTRY_NAME_MAXSIZE-1;
2858 	}
2859 	// 跨区国家名称长度
2860 	if (sendData.nWorldNameLen>=COUNTRY_NAME_MAXSIZE)
2861 	{
2870 	//char szTitle[COUNTRY_LONGSTR_MAXSIZE];					// 国家公告
2871 	//char szLocalName[COUNTRY_NAME_MAXSIZE];					// 本区国家短名称长度
2872 	//char szWorldName[COUNTRY_NAME_MAXSIZE];					// 跨区国家名称长度
2873 	//char szDBWorldName[COUNTRY_NAME_MAXSIZE];					// 所属数据库游戏世界名称
2874 	obuf1024 obuf;
2890 		obuf.push_back(m_CountryBaseInfo.szLocalName, sendData.nLocalNameLen);
2891 	}
2892 	// 跨区国家名称长度
2893 	if (sendData.nWorldNameLen>0)
2894 	{
2979 	sendData.nTitleLen				= strlen(m_CountryBaseInfo.szTitle);				// 国家公告长度
2980 	sendData.nLocalNameLen			= strlen(m_CountryBaseInfo.szLocalName);			// 本区国家短名称长度
2981 	sendData.nWorldNameLen			= strlen(m_CountryBaseInfo.szWorldName);			// 跨区国家名称长度
2982 	sendData.nDBWorldNameLen		= strlen(m_CountryBaseInfo.szDBWorldName);			// 所属数据库游戏世界名称长度
2984 	if (sendData.nNameLen>=COUNTRY_NAME_MAXSIZE)
2995 		sendData.nLocalNameLen = COUNTRY_NAME_MAXSIZE-1;
2996 	}
2997 	// 跨区国家名称长度
2998 	if (sendData.nWorldNameLen>=COUNTRY_NAME_MAXSIZE)
2999 	{
3008 	//char szTitle[COUNTRY_LONGSTR_MAXSIZE];					// 国家公告
3009 	//char szLocalName[COUNTRY_NAME_MAXSIZE];					// 本区国家短名称长度
3010 	//char szWorldName[COUNTRY_NAME_MAXSIZE];					// 跨区国家名称长度
3011 	//char szDBWorldName[COUNTRY_NAME_MAXSIZE];					// 所属数据库游戏世界名称
3013 	obuf1024 obuf;
3029 		obuf.push_back(m_CountryBaseInfo.szLocalName, sendData.nLocalNameLen);
3030 	}
3031 	// 跨区国家名称长度
3032 	if (sendData.nWorldNameLen>0)
3033 	{
3116 	sendData.nTitleLen				= strlen(m_CountryBaseInfo.szTitle);				// 国家公告长度
3117 	sendData.nLocalNameLen			= strlen(m_CountryBaseInfo.szLocalName);			// 本区国家短名称长度
3118 	sendData.nWorldNameLen			= strlen(m_CountryBaseInfo.szWorldName);			// 跨区国家名称长度
3119 	sendData.nDBWorldNameLen		= strlen(m_CountryBaseInfo.szDBWorldName);			// 所属数据库游戏世界名称长度
3121 	if (sendData.nNameLen>=COUNTRY_NAME_MAXSIZE)
3132 		sendData.nLocalNameLen = COUNTRY_NAME_MAXSIZE-1;
3133 	}
3134 	// 跨区国家名称长度
3135 	if (sendData.nWorldNameLen>=COUNTRY_NAME_MAXSIZE)
3136 	{
3145 	//char szTitle[COUNTRY_LONGSTR_MAXSIZE];					// 国家公告
3146 	//char szLocalName[COUNTRY_NAME_MAXSIZE];					// 本区国家短名称长度
3147 	//char szWorldName[COUNTRY_NAME_MAXSIZE];					// 跨区国家名称长度
3148 	//char szDBWorldName[COUNTRY_NAME_MAXSIZE];					// 所属数据库游戏世界名称
3149 	obuf1024 obuf;
3165 		obuf.push_back(m_CountryBaseInfo.szLocalName, sendData.nLocalNameLen);
3166 	}
3167 	// 跨区国家名称长度
3168 	if (sendData.nWorldNameLen>0)
3169 	{
3374 		return;
3375 	}
3377 	// 取得跨区桥服务器连接器接口
3378 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
3379 	if (NULL==pBridgeConnector)
3491 		return;
3492 	}
3494 	/////// 跨区桥服务器连接器  ////////////////////////////////////////
3495 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
3496 	if (NULL==pBridgeConnector)
3549 	// 本区国家名称
3550 	sstrcpyn(sendData.data.szName, m_CountryBaseInfo.szName, sizeof(sendData.data.szName));
3551 	// 跨区国家名称
3552 	sstrcpyn(sendData.data.szWorldName, m_CountryBaseInfo.szWorldName, sizeof(sendData.data.szWorldName));
3553 	// 所属数据库游戏世界名称
3688 	// 本区国家短名称
3689 	sstrcpyn(m_CountryBaseInfo.szLocalName, stCountryBase.szLocalName, sizeof(m_CountryBaseInfo.szLocalName));
3691 	// 跨区国家名称
3692 	sstrcpyn(m_CountryBaseInfo.szWorldName, stCountryBase.szWorldName, sizeof(m_CountryBaseInfo.szWorldName));
3694 	// 所属数据库游戏世界名称
3703 #ifdef TRACE_COUNTRY_DETAIL
3704 	// 调式代码
3705 	sprintf_s(szBuf, _countof(szBuf),_NGT" 读取国家数据:国家ID=%d,国家名称=%s,等级=%d,等级名=%s,强大程度=%d,文明点数=%d,金钱=%d,木材=%d,粮草=%d,交易税收=%d,官员俸禄=%d,军队俸禄=%d,功勋兑换=%d,文官上限=%d,将军上限=%d,巡捕上限=%d,诸侯上限=%d,候相上限=%d,国王ID=%d,本区国家短名称=%s,跨区国家名称=%s,所属数据库游戏世界名称=%s",
3706 		m_CountryBaseInfo.dwID,m_CountryBaseInfo.szName,m_CountryBaseInfo.nLevel,m_CountryBaseInfo.szLevelName,
3707 		m_CountryBaseInfo.dwPower,m_CountryBaseInfo.dwPiont,m_CountryBaseInfo.dwMoney,m_CountryBaseInfo.dwWood,m_CountryBaseInfo.dwFood,
3832 	// 本区国家短名称
3833 	sstrcpyn(stSaveParam.szLocalName, m_CountryBaseInfo.szLocalName, sizeof(stSaveParam.szLocalName));
3835 	// 跨区国家名称
3836 	sstrcpyn(stSaveParam.szWorldName, m_CountryBaseInfo.szWorldName, sizeof(stSaveParam.szWorldName));
3837 	//

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\ClanService\ComClanService.cpp 18 KB CPP 文件 2014/2/25 14:30:46 2018/10/23 19:46:33 2018/10/23 19:46:33 2
227 	}
228 }
230 /// purpose: 处理其他服务器通过跨区桥服务器转发的消息
231 //@ param: actionId 消息码
232 //@ param: bridgeHead 桥消息头
453 	}
454 	SPuMsgClan_UpdateClan* pUpdateClan = (SPuMsgClan_UpdateClan*)pData;
456 	TraceLn("[跨区帮会 公共区] 收到帮会信息： 家族ID=" << pUpdateClan->dwID);
458 	if (nLen != sizeof(SPuMsgClan_UpdateClan) + pUpdateClan->nMemberCount * sizeof(int))
459 	{

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\ClanService\ClanService.cpp 113 KB CPP 文件 2014/2/25 14:30:43 2018/10/23 19:46:32 2018/10/23 19:46:32 3
1154 			{
1155 				CClan* pClan = it->second;
1157 				TraceLn("[跨区帮会 OnBridgeEventExecute] 向公共区同步帮会信息：clanID=" << pClan->GetNumProp(emClanProp_ID));
1158 				pClan->SynchToPublicServer();
1159 			}
2558 	// 同步到公共区
2559 	pClan->SynchToPublicServer();
2561 	TraceLn("[跨区帮会 OnReadDBFinish] 向公共区同步帮会信息：clanID=" << pClan->GetNumProp(emClanProp_ID));
2562 }
2564 /// purpose: 成员上线
2744 	{
2745 		CClan* pClan = it->second;
2747 		//TraceLn("[跨区帮会] 向公共区同步帮会信息：clanID=" << pClan->GetNumProp(emClanProp_ID));
2748 		pClan->SynchToPublicServer();
2749 	}

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\ChatService\GMCommandManager.cpp 19 KB CPP 文件 2014/2/25 14:30:37 2018/10/23 19:46:31 2018/10/23 19:46:31 1
365 	REG_GM_CMD(GMCommand_CheckZone,	"checkzone",		":checkzone 角色名",					"查询玩家在公共区还是普通区",	
366 		RightFlag_ChangePos_Myself, true, false);
368 	REG_GM_CMD(GMCommand_Hang,		"hang",				":hang",								"跨区传送到默认位置",	
369 		RightFlag_ChangePos_Myself, true, false);
370 	//

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\ChatService\ChatService.cpp 91 KB CPP 文件 2014/2/25 14:30:35 2018/10/23 19:46:31 2018/10/23 19:46:31 5
152 	if (pBridgeConnector != NULL)
153 	{
154 		// 订阅  跨区桥服务器连接器 MSG_MODULEID_CHAT 消息
155 		pBridgeConnector->registerMessageHandler(MSG_MODULEID_CHAT,this);
156 	}
166 void ChatService::close()
167 {
168 	// 取消订阅 取得跨区桥服务器连接器MSG_MODULEID_CHAT消息
169 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
170 	if (pBridgeConnector != NULL)
540 	SendReportToGMClient(dwClientID, repInfo);	
541 }
543 // 跨区聊天
544 void ChatService::KuaquBroadcastChatMessage(UserInfoEx* infoex, ulong senderRank, ulong channel, const char* text, int orderSet)
545 {
1366 }
1368 //////////////////IBridgeMessageHandler////////////////////////////////////////////////////////
1370 /** 处理跨区桥服务器发过来的消息
1371 @name         : 处理其他服务器通过跨区桥服务器转发的消息
1372 @param actionId  : 消息码
1373 @param bridgeHead  : 桥消息头

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\ServerManager\ManagerServer\Src\GlobalManagerServer.cpp 77 KB CPP 文件 2014/2/25 14:34:56 2018/10/23 19:46:28 2018/10/23 19:46:28 1
40 	{ 10,MSG_MG_ENDPOINT_VERIFY,	true,false,	"验证码服务器",	"\\Social",		"\\Social\\VerifyService.exe",			"",						"VerifyService.exe",		1000,	0,	0,	0},
41 	{ 11,MSG_MG_ENDPOINT_TRACKER,	true,false,	"Tracker服务器","\\Cluster",	"\\Cluster\\TrackerServer.exe",			"",						"TrackerServer.exe",		1000,	0,	0,	0},
42 	{ 12,MSG_MG_ENDPOINT_BRIDGE,	true,false,	"跨区桥服务器",	"\\Cluster",	"\\Cluster\\BridgeServer.exe",			"",						"BridgeServer.exe",			1000,	0,	0,	0},
43 	{ 13,MSG_MG_ENDPOINT_DBHTTP,	true,false,	"DB应用服务器",	"\\Cluster",	"\\Cluster\\DBHttpServer.exe",			"",						"DBHttpServer.exe",			1000,	0,	0,	0},
44 	{ 14,MSG_MG_ENDPOINT_PASSPORT,	true,false,	"通行证服务器",	"\\Cluster",	"\\Cluster\\PassportServer.exe",		"",						"PassportServer.exe",		1000,	0,	0,	0},

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\ServerManager\ManagerClient\Src\RealTimeDataDraw.cpp 146 KB CPP 文件 2014/2/25 14:34:35 2018/10/23 19:46:19 2018/10/23 19:46:19 1
54 	static const SRTDrawTypeConfigInfo _gRTDrawTypeConfigInfoList[MG_RTDrawType_MaxID] = {
55 		//                                                                                          {   0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,  16,  17,  18,  19,  20,  21 } 
56 		// 实时数据绘图类型ID,					是否启用,	绘图类型名称,服务器类型是否支持			{  无,场景,网关,登录,世界,客户,输入,中心,社会,前端,验证,  Tk,跨区,  DB,通行,语音,语关,  根,  主,  子,管客,  空 }
57 		{ MG_RTDrawType_None,							0,	"未支持",	"显示未支持文字",			{   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   0 }	},	// 无曲线图,只显示文字
58 		{ MG_RTDrawType_OnlineCountsCurve,				1,	"在线",		"在线数曲线图",				{   0,   1,   1,   1,   0,   0,   0,   0,   1,   0,   0,   0,   0,   0,   0,   1,   1,   0,   0,   0,   0,   0 }	},	// 在线数曲线图

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\ServerManager\ManagerClient\Src\MainFrm.cpp 212 KB CPP 文件 2014/2/25 14:34:30 2018/10/23 19:46:18 2018/10/23 19:46:18 2
65 	IDI_ICON_VERIFY,	// 验证码服务器
66 	IDI_ICON_TRACKER,	// Tracker服务器
67 	IDI_ICON_BRIDGE,	// 跨区桥服务器
68 	IDI_ICON_DBHTTP,	// DB应用服务器
69 	IDI_ICON_PASSPORT,	// 通行证服务器
88 	IDI_ICON_VERIFY0,	// 验证码服务器
89 	IDI_ICON_TRACKER0,	// Tracker服务器
90 	IDI_ICON_BRIDGE0,	// 跨区桥服务器
91 	IDI_ICON_DBHTTP0,	// DB应用服务器
92 	IDI_ICON_PASSPORT0,	// 通行证服务器

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\ServerManager\Common\RealTimeDataSrc.cpp 12 KB CPP 文件 2014/2/25 14:30:23 2018/10/23 19:46:15 2018/10/23 19:46:15 1
41 		0,		// 验证码服务器
42 		0,		// Tracker服务器
43 		0,		// 跨区桥服务器
44 		0,		// DB应用服务器
45 		0,		// 通行证服务器

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\ServerManager\Common\ManagerFun.cpp 17 KB CPP 文件 2014/2/25 14:30:23 2018/10/23 19:46:15 2018/10/23 19:46:15 1
188 		_T("验证码服务器"),
189 		_T("Tracker服务器"),
190 		_T("跨区桥服务器"),
191 		_T("DB应用服务器"),
192 		_T("通行证服务器"),

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\ZoneServerLogic\ZoneServiceProvider.cpp 77 KB CPP 文件 2014/2/25 14:30:21 2018/10/23 19:46:15 2018/10/23 19:46:15 7
401 }
402 //////////////////////////////////////////////////////////////////////////
404 /// 关闭跨区桥服务器连接器
405 void CZoneServiceProvider::ReleaseBridgeConnector(void)
406 {
440 @retval buffer 
441 */
443 ////////// IBridgeEventHandler 处理处理跨区桥服务器执行事件 //////////////////
444 /** 
445 @param   wEventID ：事件ID
485 	default:
486 		{
487 			ErrorLn("场景服务器尚有一个跨区桥服务器执行事件订阅了但未处理，wEventID = "<<wEventID);
488 		}
489 		break;
2031 	CALCULATE_RELEASEMODULE("LUA引擎");
2033 	EmphasisLn("完成释放场景服的各个模块.....总耗时="<<::GetTickCount()-nTotalTick<<"ms");
2035 	/// 关闭跨区桥服务器连接器
2036 	ReleaseBridgeConnector();
2036 	ReleaseBridgeConnector();
2037 	EmphasisLn("已关闭跨区桥服务器连接器");
2041 	// 停止逻辑线程
2042 	m_LogicThread.StopThread();
2781 	return m_ManagerConnector;
2782 }
2784 // 获得跨区桥服务器连接器
2785 IBridgeConnector* CZoneServiceProvider::GetBridgeConnector(void)
2786 {
2797 	return m_nCurAreaLoadMapMode;
2798 }
2800 /** 取得跨区服务器
2801 @param   
2802 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\ZoneServerLogic\SchemeZoneMatron.cpp 7 KB CPP 文件 2014/2/25 14:30:10 2018/10/23 19:46:13 2018/10/23 19:46:13 1
202 		// 禁止双人坐骑进入
203 		schemeInfo.bForbidBWM = pCSVReader->GetBool(i, 17, 0);
205 		// 不允许跨区传送
206 		schemeInfo.bForbidStarTrek = pCSVReader->GetBool(i, 18, 0);
208 		// 标志位

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\ZoneServerLogic\MiscServerWrap.cpp 15 KB CPP 文件 2014/2/25 14:29:53 2018/10/23 19:46:09 2018/10/23 19:46:09 1
540 		if (dwNowTicks>dwLastTimes+60000)
541 		{
542 			ErrorLn("难道开了多台登陆服务器？这样会导致跨区的模块无法使用！台数 = " << count);
543 		}
544 		return;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\ZoneServer\ZoneServiceProvider.cpp 101 KB CPP 文件 2014/2/25 14:29:39 2018/10/23 19:46:00 2018/10/23 19:46:00 20
461 	}
462 }
464 /// 启动跨区桥服务器连接器
465 void CZoneServiceProvider::CreateBridgeConnector(void)
466 {
465 void CZoneServiceProvider::CreateBridgeConnector(void)
466 {
467 	// 加载跨区桥服务器连接器设定
468 	Ini ini("Bridge.ini");
469 	std::string strBridgeServerIP = ini.getString("Setting","BridgeServerIP","127.0.0.1");
490 	if (nOpenBridge!=1)
491 	{
492 		WarningLn("跨区桥服务器连接禁用!");
493 		return;
494 	}
493 		return;
494 	}
495 	// 跨区桥服务器连接器连接
496 	TraceLn("连接跨区桥服务器:游戏世界ID="<<dwGameWorldID<<":"<<strWorldName.c_str()<<","<<strBridgeServerIP.c_str()<<":"<<nBridgeServerPort);
497 	if(!m_BridgeConnector->Connect(strBridgeServerIP.data(),nBridgeServerPort))
498 	{
497 	if(!m_BridgeConnector->Connect(strBridgeServerIP.data(),nBridgeServerPort))
498 	{
499 		TraceLn("连接跨区桥服务器失败!");
500 		return;
501 	}
500 		return;
501 	}
502 	//TraceLn("连接跨区桥服务器成功!");
504 	// 全部游戏世界加入事件
505 	m_BridgeConnector->registerEventHandler(EVENT_BRIDGE_WORLDLIST_ALL,static_cast<IBridgeEventHandler *>(this));
509 	m_BridgeConnector->registerEventHandler(EVENT_BRIDGE_WORLDLIST_EDIT,static_cast<IBridgeEventHandler *>(this));
510 }
511 /// 关闭跨区桥服务器连接器
512 void CZoneServiceProvider::ReleaseBridgeConnector(void)
513 {
520 		// 修改游戏世界事件
521 		m_BridgeConnector->unregisterEventHandler(EVENT_BRIDGE_WORLDLIST_EDIT,static_cast<IBridgeEventHandler *>(this));
523 		// 关闭跨区桥服务器连接器
524 		EmphasisLn("关闭跨区桥服务器连接器!");
525 		m_BridgeConnector->Release();
526 		m_BridgeConnector = NULL;
603 	}
604 }
606 ////////// IBridgeEventHandler 处理处理跨区桥服务器执行事件 //////////////////
607 /** 
608 @param   wEventID ：事件ID
648 	default:
649 		{
650 			ErrorLn("场景服务器尚有一个跨区桥服务器执行事件订阅了但未处理，wEventID = "<<wEventID);
651 		}
652 		break;
1438 #	define      START_SERVICE(name)                   GetProcessMemoryInfo(GetCurrentProcess(),&pmc,sizeof(pmc));  \
1439 	                                                  Trace("开始启动" << name << "[mem:" << pmc.PagefileUsage << "]......" << endl);
1441 	// 连接跨区桥服务器	
1442 	Trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl);
1442 	Trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl);
1443 	START_SERVICE("跨区桥服务器");
1444 	CreateBridgeConnector();
1445 	if(m_BridgeConnector == NULL)
1445 	if(m_BridgeConnector == NULL)
1446 	{
1447 		Error("连接跨区桥服务器失败... ..." << endl);
1448 		return false;
1449 	}
1448 		return false;
1449 	}
1450 	Trace("连接跨区桥服务器成功... ..." << endl);
1451 	Trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl << endl);
1453 	// 加上服务器名服务器ID
2725 	CALCULATE_RELEASEMODULE("LUA引擎");
2727 	EmphasisLn("完成释放场景服的各个模块.....总耗时="<<::GetTickCount()-nTotalTick<<"ms");
2729 	/// 关闭跨区桥服务器连接器
2730 	ReleaseBridgeConnector();
2730 	ReleaseBridgeConnector();
2731 	EmphasisLn("已关闭跨区桥服务器连接器");
2733 	// 关闭管理连接器
2734 	ReleaseManagerConnector();
3496 	return m_ManagerConnector;
3497 }
3499 // 获得跨区桥服务器连接器
3500 IBridgeConnector* CZoneServiceProvider::GetBridgeConnector(void)
3501 {
3512 	return m_nCurAreaLoadMapMode;
3513 }
3515 /** 取得跨区服务器
3516 @param   
3517 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\ZoneServer\SchemeZoneMatron.cpp 7 KB CPP 文件 2014/2/25 14:29:35 2018/10/23 19:45:59 2018/10/23 19:45:59 1
202 		// 禁止双人坐骑进入
203 		schemeInfo.bForbidBWM = pCSVReader->GetBool(i, 17, 0);
205 		// 不允许跨区传送
206 		schemeInfo.bForbidStarTrek = pCSVReader->GetBool(i, 18, 0);
208 		// 标志位

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\ZoneServer\MiscServerWrap.cpp 15 KB CPP 文件 2014/2/25 14:29:20 2018/10/23 19:45:54 2018/10/23 19:45:54 1
540 		if (dwNowTicks>dwLastTimes+60000)
541 		{
542 			ErrorLn("难道开了多台登陆服务器？这样会导致跨区的模块无法使用！台数 = " << count);
543 		}
544 		return;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\ZoneServer2\ZoneServerLauncher.cpp 9 KB CPP 文件 2014/2/25 14:29:48 2018/10/23 19:46:05 2018/10/23 19:46:05 6
258 	return true;
259 }
264 /// 启动跨区桥服务器连接器
265 bool CZoneServerLauncher::__CreateBridgeConnector(void)
266 {
265 bool CZoneServerLauncher::__CreateBridgeConnector(void)
266 {
267 	// 加载跨区桥服务器连接器设定
268 	Ini ini("Bridge.ini");
269 	std::string strBridgeServerIP = ini.getString("Setting","BridgeServerIP","127.0.0.1");
291 	if (nOpenBridge != 1)
292 	{
293 		WarningLn("跨区桥服务器连接禁用!");
294 		return true;
295 	}
294 		return true;
295 	}
297 	// 跨区桥服务器连接器连接	
298 	if(!m_pBridgeConnector->Connect(strBridgeServerIP.c_str(), nBridgeServerPort))
299 	{
298 	if(!m_pBridgeConnector->Connect(strBridgeServerIP.c_str(), nBridgeServerPort))
299 	{
300 		TraceLn("连接跨区桥服务器失败!");
301 		return false;
302 	}
303 	else
304 	{
305 		TraceLn("连接跨区桥服务器:游戏世界ID="<<dwGameWorldID<<":"<<strWorldName.c_str()<<","<<strBridgeServerIP.c_str()<<":"<<nBridgeServerPort);
306 	}
308 	return true;	

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\TestServer\TestServer.cpp 38 KB CPP 文件 2014/2/25 14:28:58 2018/10/23 19:45:47 2018/10/23 19:45:47 1
1186 	else
1187 	{
1188 		// 取得跨区桥服务器连接器接口
1189 		IBridgeConnector*pBridgeConnector = GetGlobalBridgeConnector();
1190 		if (pBridgeConnector!=NULL)

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\TeamServer\TeamServer.cpp 60 KB CPP 文件 2014/2/25 14:28:54 2018/10/23 19:45:46 2018/10/23 19:45:46 1
1476 	msglinestate.nMode = nMode;
1477 	msglinestate.bActiveExit = pTunnel->IsActiveExitClient(); 
1479 	// 为了让跨区的时候，不退出队伍，强制标记得为断线下线
1480 	if(!bLoginFlag && nMode == loginXlogout_Mode_StarTrek)
1481 	{

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\StarTrekServer\StarTrekServer.cpp 8 KB CPP 文件 2014/2/25 14:28:37 2018/10/23 19:45:41 2018/10/23 19:45:41 7
107 }
109 /**
110 @name         : 处理其他服务器通过跨区桥服务器转发的消息
111 @param actionId  : 消息码
112 @param bridgeHead  : 桥消息头
154 	}
155 }
157 /** 预判断能否跨区	
158 @param	 nInGameWorldID		: 迁入世界ID
159 @param   dwInZoneID			：迁入场景ID
161 @param   nStarTrekType		：传送类型
162 @param   dwStarTrekFlag		：传送标志
163 @param   bAsyncCheck		: 是否需要跨区判断
164 @param   pszCanInLuaFunction: 迁入场景服能否接收的Lua函数
164 @param   pszCanInLuaFunction: 迁入场景服能否接收的Lua函数
165 @param   pszCheckResultLua	: 跨区判断的结果Lua函数
166 @param   跨区判断:
167 　　　　 1: 若在当前进程都失败，则直接返回
168 		 2: 最终结果在pszCheckResultLua返回, 参数输入只需填函数名, 参数依次为:
179 									   pszCanInLuaFunction, pszCheckResultLua);
180 }
182 /** 跨区
183 @param	 nInGameWorldID			: 迁入世界ID
184 @param   dwInZoneID				：迁入场景ID
207 									pszDoneInLuaFunction);
208 }
210 /** 释放跨区对像
211 @param   nSTDir : tStarTrek_MsgDir_In, tStarTrek_MsgDir_Out
212 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\StarTrekServer\OutDirHandler.cpp 26 KB CPP 文件 2014/2/25 14:28:36 2018/10/23 19:45:41 2018/10/23 19:45:41 10
181 	return (*itNeed).second;
182 }
184 /** 预判断能否跨区	
185 @param	 nInGameWorldID		: 迁入世界ID
186 @param   dwInZoneID			：迁入场景ID
188 @param   nStarTrekType		：传送类型
189 @param   dwStarTrekFlag		：传送标志
190 @param   bAsyncCheck		: 是否需要跨区判断
191 @param   pszCanInLuaFunction: 迁入场景服能否接收的Lua函数
191 @param   pszCanInLuaFunction: 迁入场景服能否接收的Lua函数
192 @param   pszCheckResultLua	: 跨区判断的结果Lua函数
193 @param   跨区判断:
194 　　　　 1: 若在当前进程都失败，则直接返回
195 		 2: 最终结果在pszCheckResultLua返回, 参数输入只需填函数名, 参数依次为:
211 	return __CanStarTrek(PDBID, nInGameWorldID, dwInBridgeServerID, dwInZoneID, ptInLoc, nStarTrekType, dwStarTrekFlag, bAsyncCheck, pszCanInLuaFunction, pszCheckResultLua, 0);
212 }
214 /** 判断能否跨区	
215 @param	 nInGameWorldID		: 迁入世界ID
216 @param	 dwInBridgeServerID	: 迁入服务器ID
219 @param   nStarTrekType		：传送类型
220 @param   dwStarTrekFlag		：传送标志
221 @param   bAsyncCheck		: 是否需要跨区判断
222 @param   pszCanInLuaFunction: 迁入场景服能否接收的Lua函数
222 @param   pszCanInLuaFunction: 迁入场景服能否接收的Lua函数
223 @param   pszCheckResultLua	: 跨区判断的结果Lua函数
224 @return  返回:参见tStarTrek_Result_　....
225 */
309 	return tStarTrek_Result_Succeed;
310 }
312 /** 本游戏世界判断是否能跨区
313 @param   nInGameWorldID	　  : 迁入世界ID
314 @param	 dwInBridgeServerID	: 迁入服务器ID
466 	return tStarTrek_Result_Succeed;
467 }
469 /** 跨区
470 @param	 nInGameWorldID			: 迁入世界ID
471 @param   dwInZoneID				：迁入场景ID
554 }
556 /**
557 @name         : 处理其他服务器通过跨区桥服务器转发的消息
558 @param actionId  : 消息码
559 @param bridgeHead  : 桥消息头

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\StarTrekServer\NeedOutObject.cpp 26 KB CPP 文件 2014/2/25 14:28:36 2018/10/23 19:45:41 2018/10/23 19:45:41 4
320 	if(pTerminalTunnel != NULL)
321 	{
322 		pTerminalTunnel->Kickout(EKickoutClient_Reason_StarTrekFailed, "对不起,跨区切换超时.");
323 	}
324 	else
380 			else if (nReasonEx == tStarTrek_Result_CloseStarTreak)
381 			{
382 				sprintf_s(chatText, "对不起,跨区功能已关闭,暂时无法传送,请稍候再试[%d,%d]... ...", nReleaseTreakReason, nReasonEx);
383 			}
384 			else
491 	}
493 	///////////////////////////////////////////////////////////////////
494 	// 发准备跨区事件，让其他模块好做因应
495 	SEventPersonStarTrek_S eventstartrek;
496 	eventstartrek.uidPerson			= pPerson->GetUID();
528 	if(nTrekLen <= -1)
529 	{
530 		ErrorLn("跨区切换失败...取得重构角色现场景失败! PDBID="<<m_Context.PDBID);
531 		debugBreak;
533 		SaveDataAndLogout(tReleaseTreak_Reason_ExportContextFail);

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\StarTrekServer\InDirHandler.cpp 20 KB CPP 文件 2014/2/25 14:28:35 2018/10/23 19:45:40 2018/10/23 19:45:40 1
52 }
54 /**
55 @name         : 处理其他服务器通过跨区桥服务器转发的消息
56 @param actionId  : 消息码
57 @param bridgeHead  : 桥消息头

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\SiegeWarServer\SiegeWarServer.cpp 93 KB CPP 文件 2014/2/25 14:28:21 2018/10/23 19:45:37 2018/10/23 19:45:37 1
2497 		return 0;
2498 	}
2499 	// 取得跨区竞技部件指针
2500 	IPersonStrikePart *pPersonStrikePart = (IPersonStrikePart *)pPerson->GetEntityPart(ENTITYPART_PERSON_STRIKE);
2501 	if (pPersonStrikePart == NULL)

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\SiegeWarServer\ExternalFacade.cpp 67 KB CPP 文件 2014/2/25 14:28:17 2018/10/23 19:45:36 2018/10/23 19:45:36 2
2456 		}
2457 	}
2459 	// 公共区取跨区国家名称
2460 	if (bLocal)
2461 	{
2474 	else
2475 	{
2476 		// 取得跨区桥服务器连接器接口
2477 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
2478 		if (NULL != pBridgeConnector)

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\ShareServer\ZoneSvrSource.cpp 59 KB CPP 文件 2014/2/25 14:28:15 2018/10/23 19:45:35 2018/10/23 19:45:35 6
110 	pEventEngine->Subscibe(static_cast<IEventExecuteSink *>(this), EVENT_PERSON_BATTLERIDE_KNIGHTTYPE, 
111 							SOURCE_TYPE_PERSON, 0, "CZoneSvrSource::Create");
113 	/////// 注册跨区桥服务器连接器 事件处理者 ///////////////////////////////////////////////////////////////////
114 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
115 	if (NULL!=pBridgeConnector)
138 	// 关闭内存信息同步定时器
139 	gZoneServiceProvider->GetTimeAxis()->KillTimer(emShareEmemory_TimeID, this);
141 	/////// 注销跨区桥服务器连接器 事件处理者 ///////////////////////////////////////////////////////////////////
142 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
143 	if (NULL!=pBridgeConnector)
303 	}
304 }
307 ////////// IBridgeEventHandler 处理处理跨区桥服务器执行事件 /////////////////////////////////////////////////////////
308 /** 
309 @param   wEventID ：事件ID
1665 		return;
1666 	}
1668 	/////// 跨区桥服务器连接器  ////////////////////////////////////////
1669 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
1670 	if (NULL!=pBridgeConnector)
1756 		return;
1757 	}
1760 	/////// 跨区桥服务器连接器  ////////////////////////////////////////
1761 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
1762 	if (NULL!=pBridgeConnector)
1818 		return;
1819 	}
1822 	/////// 跨区桥服务器连接器  ////////////////////////////////////////
1823 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
1824 	if (NULL!=pBridgeConnector)

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\ServerModule\ExternalHelper.cpp 48 KB CPP 文件 2014/2/25 14:28:01 2018/10/23 19:45:29 2018/10/23 19:45:29 2
1654 		}
1655 	}
1657 	// 公共区取跨区国家名称
1658 	if (bLocal)
1659 	{
1672 	else
1673 	{
1674 		// 取得跨区桥服务器连接器接口
1675 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
1676 		if (NULL != pBridgeConnector)

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\RelationServer\VerifyPart.cpp 74 KB CPP 文件 2014/2/25 14:27:42 2018/10/23 19:45:22 2018/10/23 19:45:22 2
547 // 	return true;
548 }
551 /** 跨区切换地图时，将部件数据导出带过去,　如果没有数据，将nLen设为0或返回false
552 @param   
553 @param   
565 	return ExportRenewContext(pszContext,nLen);
566 }
568 /** 跨区切换地图时，将部件数据现场导入
569 @param   
570 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\RelationServer\TitlePart.cpp 64 KB CPP 文件 2014/2/25 14:27:42 2018/10/23 19:45:21 2018/10/23 19:45:21 2
727 // 	return true;
728 }
731 /** 跨区切换地图时，将部件数据导出带过去,　如果没有数据，将nLen设为0或返回false
732 @param   
733 @param   
745 	return ExportRenewContext(pszContext,nLen);
746 }
748 /** 跨区切换地图时，将部件数据现场导入
749 @param   
750 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\NerveServer\ZenSkillPart.cpp 184 KB CPP 文件 2014/2/25 14:27:25 2018/10/23 19:45:17 2018/10/23 19:45:17 1
636 // 	return true;
637 }
639 /** 跨区切换地图时，将部件数据导出带过去,　如果没有数据，将nLen设为0或返回false
640 @param   
641 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\NerveServer\NervePart.cpp 121 KB CPP 文件 2014/2/25 14:27:22 2018/10/23 19:45:16 2018/10/23 19:45:16 1
958 	return true;
959 }
961 /** 跨区切换地图时，将部件数据导出带过去,　如果没有数据，将nLen设为0或返回false
962 @param   
963 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MatchServer\WarServer.cpp 67 KB CPP 文件 2014/2/25 14:27:18 2018/10/23 19:45:15 2018/10/23 19:45:15 15
5 ** 日  期:	2011-03-15
6 ** 版  本:	1.0
7 ** 描  述:	跨区战争系统
8 ** 应  用:  	
9 	
366 	return &(iter->second);
367 }
371 /**  请求更新跨区共享国家信息
372 @return  
373 */
387 		return false;
388 	}
390 	// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
391 	return g_pMatchServer->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_RequestCountryInfo,dwCountryID,0,0);
392 }
436 	obufData.push_back(szTitle, sendData.nTitleStrLen);
437 	obufData.push_back(szHistory, sendData.nHistoryStrLen);
439 	// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
440 	return g_pMatchServer->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_RequestAddHistory,dwCountryID,0,0, obufData.data(), obufData.size());
441 }
537 	obufData.push_back(&dwMaxOnlineCount, sizeof(DWORD));
538 	obufData.push_back(&dwBossHP, sizeof(DWORD));
540 	// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
541 	g_pMatchServer->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_WorldCountryWarState,pCountryWar->m_dwTaskWorldWarID,dwRunStep,dwWarResult,obufData.data(), obufData.size());
543 }
808 }
810 //////////////////////////////////////////////////////////////////////////
812 /** 处理跨区桥服务器发过来的消息
813 @name         : 处理其他服务器通过跨区桥服务器转发的消息
814 @param actionId  : 消息码
815 @param bridgeHead  : 桥消息头
1346 	default:
1347 		{
1348 			ErrorLn("跨区战争系统有一个跨服撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
1349 		}
1350 		break;
1415 				break;
1416 			}
1417 			// 取得跨区桥服务器连接器接口
1418 			IBridgeConnector * pBridgeConnector = GetGlobalBridgeConnector();
1419 			if (pBridgeConnector == NULL)
1506 				break;
1507 			}
1508 			// 取得跨区桥服务器连接器接口
1509 			IBridgeConnector * pBridgeConnector = GetGlobalBridgeConnector();
1510 			if (pBridgeConnector == NULL)
2017 	default:
2018 		{
2019 			ErrorLn("跨区战争系统有一个服务器信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
2020 		}
2021 		break;
2213 	default:
2214 		{
2215 			ErrorLn("跨区战争系统有一个客户端信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
2216 		}
2217 		break;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MatchServer\War.cpp 98 KB CPP 文件 2014/2/25 14:27:16 2018/10/23 19:45:13 2018/10/23 19:45:13 2
415 		return false;
416 	}
417 	// 跨区副本部件
418 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
419 	if (pEctypeAssistPart==NULL)
759 		return false;
760 	}
761 	// 跨区副本部件
762 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
763 	if (pEctypeAssistPart==NULL)

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MatchServer\StrikeVote.cpp 30 KB CPP 文件 2014/2/25 14:27:14 2018/10/23 19:45:13 2018/10/23 19:45:13 1
5 ** 日  期:	2011-2-11
6 ** 版  本:	1.0
7 ** 描  述:	跨区竞技系统
8 ** 应  用:  	
9 	

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MatchServer\StrikeServer.cpp 27 KB CPP 文件 2014/2/25 14:27:14 2018/10/23 19:45:13 2018/10/23 19:45:13 6
5 ** 日  期:	2010-10-27
6 ** 版  本:	1.0
7 ** 描  述:	跨区竞技系统
8 ** 应  用:  	
9 	
45 {
47 }
50 /** 处理跨区桥服务器发过来的消息
51 @name         : 处理其他服务器通过跨区桥服务器转发的消息
52 @param actionId  : 消息码
53 @param bridgeHead  : 桥消息头
86 	default:
87 		{
88 			ErrorLn("跨区竞技系统有一个跨服撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
89 		}
90 		break;
200 	default:
201 		{
202 			ErrorLn("跨区竞技系统有一个服务器撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
203 		}
204 		break;
729 		default:
730 		{
731 			ErrorLn("跨区竞技系统有一个客户端撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
732 		}
733 		break;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MatchServer\StrikeMatch.cpp 52 KB CPP 文件 2014/2/25 14:27:13 2018/10/23 19:45:13 2018/10/23 19:45:13 11
46 {
48 }
50 /** 处理跨区桥服务器发过来的消息
51 @name         : 处理其他服务器通过跨区桥服务器转发的消息
52 @param actionId  : 消息码
53 @param bridgeHead  : 桥消息头
547 		return;
548 	}
549 	// 跨区副本部件
550 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
551 	if (NULL==pEctypeAssistPart)
643 		return false;
644 	}
645 	// 跨区副本部件
646 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
647 	if (NULL==pEctypeAssistPart)
806 		return;
807 	}
808 	// 跨区副本部件
809 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
810 	if (NULL==pEctypeAssistPart)
1107 		return false;
1108 	}
1109 	// 跨区副本部件
1110 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
1111 	if (NULL==pEctypeAssistPart)
1249 		return false;
1250 	}
1252 	// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
1253 	return g_pMatchServer->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_CSMSG,Match_CSMsg_RequestJoinStrike,pPerson->GetNumProp(CREATURE_PROP_PDBID),pPerson->GetFromGameWorldID(),0,obufData.data(),obufData.size());
1255 }
1304 		return false;
1305 	}
1306 	// 跨区副本部件
1307 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
1308 	if (NULL==pEctypeAssistPart)
1375 		return false;
1376 	}
1378 	// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
1379 	return g_pMatchServer->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_CSMSG,Match_CSMsg_RequestViewStrike,dwPlayerID,pPerson->GetFromGameWorldID(),0,obufData.data(),obufData.size());
1381 }

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MatchServer\StrikeDropPrize.cpp 64 KB CPP 文件 2014/2/25 14:27:12 2018/10/23 19:45:13 2018/10/23 19:45:13 1
5 ** 日  期:	2011-3-12
6 ** 版  本:	1.0
7 ** 描  述:	跨区竞技系统
8 ** 应  用:  	
9 	

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MatchServer\Strike.cpp 329 KB CPP 文件 2014/2/25 14:27:11 2018/10/23 19:45:13 2018/10/23 19:45:13 6
1189 		return false;
1190 	}
1191 	// 跨区副本部件
1192 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
1193 	if (pEctypeAssistPart==NULL)
1591 		return false;
1592 	}
1593 	// 跨区副本部件
1594 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
1595 	if (pEctypeAssistPart==NULL)
6747 						double fEnergyCreditRate	= 1.0;	// 实战声望精力加成系数
6748 						double fEnergyMoneyRate		= 1.0;	// 实战徽章精力加成系数
6750 						// 判断玩家是否有奖励 每个角色每天参与跨区PVP竞技的有效收益时间为3小时，超过3小时，角色仍可加入战斗，但经验、声望奖励为0
6751 						const SEnergyStateSchemeInfo* pEnergyInfo = pVerifyPart->GetEnergyStateInfo(EnergyType_Strike);
6752 						if (pEnergyInfo!=NULL)
7061 						double fEnergyCreditRate	= 1.0;	// 实战声望精力加成系数
7062 						double fEnergyMoneyRate		= 1.0;	// 实战徽章精力加成系数
7064 						// 判断玩家是否有奖励 每个角色每天参与跨区PVP竞技的有效收益时间为3小时，超过3小时，角色仍可加入战斗，但经验、声望奖励为0
7065 						const SEnergyStateSchemeInfo* pEnergyInfo = pVerifyPart->GetEnergyStateInfo(EnergyType_Strike);
7066 						if (pEnergyInfo!=NULL)
7831 					double fEnergyCreditRate	= 1.0;	// 实战声望精力加成系数
7832 					double fEnergyMoneyRate		= 1.0;	// 实战徽章精力加成系数
7834 					// 判断玩家是否有奖励 每个角色每天参与跨区PVP竞技的有效收益时间为3小时，超过3小时，角色仍可加入战斗，但经验、声望奖励为0
7835 					const SEnergyStateSchemeInfo* pEnergyInfo = pVerifyPart->GetEnergyStateInfo(EnergyType_Strike);
7836 					if (pEnergyInfo!=NULL)
8158 					double fEnergyCreditRate	= 1.0;	// 实战声望精力加成系数
8159 					double fEnergyMoneyRate		= 1.0;	// 实战徽章精力加成系数
8161 					// 判断玩家是否有奖励 每个角色每天参与跨区PVP竞技的有效收益时间为3小时，超过3小时，角色仍可加入战斗，但经验、声望奖励为0
8162 					const SEnergyStateSchemeInfo* pEnergyInfo = pVerifyPart->GetEnergyStateInfo(EnergyType_Strike);
8163 					if (pEnergyInfo!=NULL)

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MatchServer\PersonStrikePart.cpp 95 KB CPP 文件 2014/2/25 14:27:09 2018/10/23 19:45:12 2018/10/23 19:45:12 4
722 // 	return true;
723 }
726 /** 跨区切换地图时，将部件数据导出带过去,　如果没有数据，将nLen设为0或返回false
727 @param   
728 @param   
740 	return ExportRenewContext(pszContext,nLen);
741 }
743 /** 跨区切换地图时，将部件数据现场导入
744 @param   
745 @param   
1235 		return;
1236 	}
1238 	// 跨区副本部件
1239 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) m_pMaster->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
1240 	if (pEctypeAssistPart==NULL)
1272 	m_StrikeInfo.wLocx			= 0;					// x坐标
1273 	m_StrikeInfo.wLocy			= 0;					// y坐标
1275 	// 跨区副本部件
1276 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) m_pMaster->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
1277 	if (pEctypeAssistPart==NULL)

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MatchServer\MatchServer.cpp 290 KB CPP 文件 2014/2/25 14:27:05 2018/10/23 19:45:11 2018/10/23 19:45:11 57
102 		return false;
103 	}
105 	// 创建跨区副本助手
106 	if (m_EctypeAssist.Create() == false)
107 	{
118 		return false;
119 	}
120 	// 创建跨区竞技系统模块
121 	if (m_StrikeServer.Create() == false)
122 	{
128 		return false;
129 	}
131 	// 创建跨区战争系统模块
132 	if (m_WarServer.Create() == false)
133 	{
172 		return false;
173 	}
175 	// 订阅  跨区桥服务器连接器 MSG_MODULEID_MATCH 消息
176 	pBridgeConnector->registerMessageHandler(MSG_MODULEID_MATCH,this);
177 	// 订阅 MSG_MODULEID_MATCH 模块消息
209 	// 正在释放Release
210 	m_bRelease = true;
212 	// 取消订阅 取得跨区桥服务器连接器MSG_MODULEID_MATCH消息
213 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
214 	if (pBridgeConnector != NULL)
261 	// 关闭战场管理器
262 	m_WarManager.Release();
264 	// 关闭跨区战争系统模块
265 	m_WarServer.Release();
267 	// 关闭竞技场管理器
267 	// 关闭竞技场管理器
268 	m_StrikeManager.Release();
270 	// 关闭跨区竞技系统模块
271 	m_StrikeServer.Release();
273 	// 关闭跨服竞技撮合系统模块
279 	// 关闭公共区遣返模块
280 	m_PublicWatcher.Close();
282 	// 关闭跨区副本助手
283 	m_EctypeAssist.Close();
285 	delete this;
3574 }*/
3576 //////////////////////////////////////////////////////////////////////////
3578 /** 创建跨区副本部件
3579 */
3580 IEctypeAssistPart* CMatchServer::CreateEctypeAssistPart()
3588 	return new CPersonStrikePart();
3589 }
3592 /** 取得跨区副本助手
3593 */
3594 IEctypeAssist* CMatchServer::GetEctypeAssist()
3604 	return &m_StrikeMatch;
3605 }
3607 /** 取得跨区竞技系统接口
3608 */
3609 IStrikeServer* CMatchServer::GetStrikeServer()
3619 	return &m_StrikeManager;
3620 }
3622 /** 取得跨区战争系统接口
3623 */
3624 IWarServer* CMatchServer::GetWarServer()
3662 }
3665 //////////////////////////////////////////////////////////////////////////
3667 /** 取得跨区副本助手
3668 */
3669 CEctypeAssist& CMatchServer::GetEctypeAssistInstance()
3677 	return m_StrikeMatch;
3678 }
3680 /** 取得跨区竞技系统
3681 */
3682 CStrikeServer& CMatchServer::GetStrikeServerInstance()
3698 	return m_mapStrikeSceneSchemeList;
3699 }
3701 // 取得跨区战争系统
3702 CWarServer& CMatchServer::GetWarServerInstance()
3703 {
3879 }
3880 //////////////////////////////////////////////////////////////////////////
3882 // 发跨区信息消息 dwServerID:服务器ID ,跨区信息专用
3883 bool CMatchServer::SendDataBridgeToServer(DWORD dwServerID,WORD wKeyAction,DWORD dwMsgCode,DWORD dwUserData1,DWORD dwUserData2,DWORD dwUserData3,const char * pData,DWORD dwLen)
3884 {
5161 		return false;
5162 	}
5164 	// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
5165 	return SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_SUBMSG,Match_SubMsg_RequestCancelMatch,pPerson->GetNumProp(CREATURE_PROP_PDBID),pPerson->GetFromGameWorldID(),dwReason);
5166 }
5192 		return false;
5193 	}
5195 	// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
5196 	return SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_SUBMSG,Match_SubMsg_RequestAcceptMatch,pPerson->GetNumProp(CREATURE_PROP_PDBID),pPerson->GetFromGameWorldID(),dwFlag);
5197 }
5222 		return false;
5223 	}
5225 	// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
5226 	return SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_SUBMSG,Match_SubMsg_RequestTeamInfo,pPerson->GetNumProp(CREATURE_PROP_PDBID),pPerson->GetFromGameWorldID(),0);
5227 }
5226 	return SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_SUBMSG,Match_SubMsg_RequestTeamInfo,pPerson->GetNumProp(CREATURE_PROP_PDBID),pPerson->GetFromGameWorldID(),0);
5227 }
5230 /** 请求跨区查看玩家装备
5231 @param  const char * pData	: 请求消息数据
5232 @param  DWORD dwLen			: 请求消息数据长度
5239 		return false;
5240 	}
5241 	// 跨区查看玩家装备
5242 	SMsgActionWorldLookEquip_SC *pMsg = (SMsgActionWorldLookEquip_SC *)pData;
5244 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
5255 		if (dwSendServerID>0)
5256 		{
5257 			// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
5258 			SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_SUBMSG,Match_SubMsg_RequestLookWorldEquip,pMsg->dwPDBID,getThisGameWorldID(),0,pData,dwLen);
5259 		}
5266 		if (dwSendServerID>0)
5267 		{
5268 			// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
5269 			SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_SUBMSG,Match_SubMsg_RequestLookWorldEquip,pMsg->dwPDBID,getThisGameWorldID(),0,pData,dwLen);
5270 		}
5331 		return false;
5332 	}
5334 	// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
5335 	return SendDataBridgeToServer(dwSendServerID,
5336 								  MSG_MATCH_DATE_SUBMSG,
5491 	return NULL;
5492 }
5494 /** 取得跨区世界文明等级
5495 @param  DWORD dwWorldID		: 游戏世界ID
5495 @param  DWORD dwWorldID		: 游戏世界ID
5496 @return  DWORD 跨区世界文明等级
5497 */
5498 DWORD CMatchServer::GetWorldCivilGrade(DWORD dwWorldID)
5528 	return pBridgeCountry->GetCivilGrade();
5529 }
5531 /** 取得跨区世界文明点数
5532 @param  DWORD dwWorldID		: 游戏世界ID
5532 @param  DWORD dwWorldID		: 游戏世界ID
5533 @return  DWORD 跨区世界文明点数
5534 */
5535 DWORD CMatchServer::GetWorldCivilDot(DWORD dwWorldID)
5608 		return;
5609 	}
5610 	// 跨区副本部件
5611 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
5612 	if (NULL==pEctypeAssistPart)
5672 	}
5673 }
5675 // 请求跨区查看玩家装备
5676 void CMatchServer::OnMsgRequestLookWorldEquip(DWORD dwActorID,DWORD dwWorldID,DWORD dwFromServerID,const char * pData,DWORD dwLen)
5677 {
5680 		return;
5681 	}
5682 	// 跨区查看玩家装备
5683 	SMsgActionWorldLookEquip_SC *pMsg = (SMsgActionWorldLookEquip_SC *)pData;
5685 	if (dwActorID!=pMsg->dwPDBID || pMsg->dwFromPDBID==0)
5708 	{
5709 		// 发送给指定来源服务器
5710 		// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
5711 		SendDataBridgeToServer(dwFromServerID,MSG_MATCH_DATE_SUBMSG,Match_SubMsg_LookWorldEquipResult,pMsg->dwFromPDBID,pMsg->dwFromWorldID,(DWORD)nGetLens,(const char *)pBufData,(DWORD)nGetLens);
5712 	}
5903 	}
5905 	SMsgMatchItemNode * pMatchItem = (SMsgMatchItemNode *)(pData+sizeof(SMsgMatchRequestInfo_CS));
5907 	// 跨区副本部件
5908 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
5909 	if (NULL==pEctypeAssistPart)
6093 				if (dwSendServerID>0)
6094 				{
6095 					// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
6096 					SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_SUBMSG,Match_SubMsg_RequestAddMatch,dwMatchTypeID,dwFindTeamID,0,obufData.data(),obufData.size());
6097 				}
6273 	}
6275 	SMsgMatchItemNode * pMatchItem = (SMsgMatchItemNode *)(pData+sizeof(SMsgMatchRequestInfo_CS));
6277 	// 跨区副本部件
6278 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
6279 	if (NULL==pEctypeAssistPart)
6499 				if (dwSendServerID>0)
6500 				{
6501 					// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
6502 					SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_SUBMSG,Match_SubMsg_RequestAddTeamMatch,dwMatchTypeID,dwMatchCaptain,dwTeamerCounts,obufData.data(),obufData.size());
6503 				}
6613 }
6615 //////////////////IBridgeMessageHandler////////////////////////////////////////////////////////
6617 /** 处理跨区桥服务器发过来的消息
6618 @name         : 处理其他服务器通过跨区桥服务器转发的消息
6619 @param actionId  : 消息码
6620 @param bridgeHead  : 桥消息头
6632 		}
6633 		break;
6634 	case MSG_MATCH_KQE:		// 跨区副本助手子消息
6635 		{
6636 			m_EctypeAssist.HandleBridgeMessage(actionId,bridgeHead, head, data, len);
6684 		}
6685 		break;
6686 	case MSG_MATCH_KQE:				// 跨区副本助手子消息
6687 		{
6688 			m_EctypeAssist.OnTransmit(server,actionId,head,data,len);
6748 		}
6749 		break;
6750 	case MSG_MATCH_KQE:		//  跨区副本助手子消息
6751 		{
6752 			m_EctypeAssist.OnMessage(pPerson, actionId, head, data,len);
6829 		}
6830 		break;
6831 	case Match_SubMsg_LookWorldEquipResult:		// 请求跨区查看玩家装备结果
6832 		{
6833 			if (nNewlen!=pMsg->dwUserData3 || pMsg->dwUserData1==0)
6967 							if (dwSendServerID>0)
6968 							{
6969 								// 发跨区撮合信息消息 dwServerID:服务器ID ,跨区信息专用
6970 								SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_SUBMSG,Match_SubMsg_FailAddTeamerMatch,pMsg->dwUserData1,pMsg->dwUserData2,pMsg->dwUserData3);
6971 							}
6976 		}
6977 		break;
6978 	case Match_SubMsg_RequestLookWorldEquip:		// 请求跨区查看玩家装备
6979 		{
6980 			if (nNewlen!=sizeof(SMsgActionWorldLookEquip_SC))
6985 			DWORD dwWorldID		= pMsg->dwUserData2;				// 信息来源游戏世界ID
6986 			DWORD dwServerID	= pMsg->dwUserData3;				// 信息来源服务器ID,用来回消息
6988 			// 请求跨区查看玩家装备
6989 			OnMsgRequestLookWorldEquip(dwActorID,dwWorldID,dwServerID,pMsgData,nNewlen);
6990 		}
8045 			DBREQ_PARAM_ADDSERVICES_CENTERDBUSER_UPDATE reqData;
8046 			reqData.dwWorldID	= dwDBWorldID;												//游戏世界ID
8047 			reqData.dwNewWorldID= dwNewDBWorldID;											//新游戏世界ID（漂移可以跨区移民）
8048 			reqData.dwUserID	= param.dwUserID;											//账号ID
8049 			reqData.dwActorID	= param.dwActorID;											//角色ID

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MatchServer\KqEctype.cpp 22 KB CPP 文件 2014/2/25 14:27:03 2018/10/23 19:45:11 2018/10/23 19:45:11 3
5 ** 日  期:	2010-7-15
6 ** 版  本:	1.0
7 ** 描  述:	跨区副本助手
8 ** 应  用:  	
9 ********************************************************************/
130 	if (nZoneID == 0)
131 	{
132 		ErrorLn("[CKqEctype::Create] 创建跨区副本失败 dwEctypeType=" << pEctypeTeam->dwEctypeType << "难度：" << nDifficulty);
134 		for (int i = 0; i < m_nMemberCount && i < ECTYPE_MEMBER_MAXCOUNT; i ++)
135 		{
577 		return;
578 	}
580 	// 无论本区还是跨区都通过桥服务器中转，方便统一消息流向
581 	SMsgKqeCallMember_GP call;
582 	call.dwPDBID = member.dwPDBID;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MatchServer\EctypeAssistPart.cpp 33 KB CPP 文件 2014/2/25 14:27:02 2018/10/23 19:45:10 2018/10/23 19:45:10 7
5 ** 日  期:	2010-7-15
6 ** 版  本:	1.0
7 ** 描  述:	跨区副本部件
8 ** 应  用:  	
9 ********************************************************************/
124 			if (m_Context.dwSerialID > 0)
125 			{
126 				WarningLn("[跨区副本 玩家登陆] 验证副本状态，玩家：" << m_pMaster->GetName() << " 副本序号：" << m_Context.dwSerialID << " 副本世界：" << m_Context.dwWorldID << " 服务器序号：" << m_Context.dwServerSubID);
127 				DWORD dwPDBID = m_pMaster->GetNumProp(CREATURE_PROP_PDBID);
128 				DWORD dwSrcBriServerID = pBridgeConnector->GetGameServerIDByTypeSubID(m_Context.dwWorldID, MSG_ENDPOINT_ZONE, m_Context.dwServerSubID);
258 			if (m_Context.dwSerialID > 0)
259 			{
260 				WarningLn("[跨区副本 玩家登陆] 验证副本状态，玩家：" << m_pMaster->GetName() << " 副本序号：" << m_Context.dwSerialID << " 副本世界：" << m_Context.dwWorldID << " 服务器序号：" << m_Context.dwServerSubID);
261 				DWORD dwPDBID = m_pMaster->GetNumProp(CREATURE_PROP_PDBID);
262 				DWORD dwSrcBriServerID = pBridgeConnector->GetGameServerIDByTypeSubID(m_Context.dwWorldID, MSG_ENDPOINT_ZONE, m_Context.dwServerSubID);
415 	return true;
416 }
418 /// purpose: 是否正在进行跨区副本
419 bool CEctypeAssistPart::IsEctypeing()
420 {
421 	return (m_Context.dwSerialID > 0);
422 }
424 /// purpose: 取得跨区现场
425 const SKqEctypePartContext* CEctypeAssistPart::GetEctypeContext()
426 {
427 	return &m_Context;
428 }
430 /// purpose: 设置跨区现场
431 void CEctypeAssistPart::SetEctypeContext(SKqEctypePartContext* pContext)
432 {
1077 		TEctypeAssistPartPrivateContext *pOutContext = &pRoleContext->stEctypeAssistPart;
1078 		pOutContext->nState = m_nState;
1080 		//跨区现场
1081 		TEctypePartContextData* pEctypeData = &pOutContext->stEctypePartData;
1082 		pEctypeData->dwSerialID	= m_Context.dwSerialID	;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MatchServer\EctypeAssist.cpp 78 KB CPP 文件 2014/2/25 14:27:02 2018/10/23 19:45:10 2018/10/23 19:45:10 34
5 ** 日  期:	2010-7-15
6 ** 版  本:	1.0
7 ** 描  述:	跨区副本助手
8 ** 应  用:  	
9 ********************************************************************/
39 bool CEctypeAssist::Create(void)
40 {
41 	kqe_trace("创建跨区副本模块");
43 	IEventEngine* pEventEngine = gZoneServiceProvider->GetEventEngine();
44 	if (pEventEngine == NULL)
69 	g_pEctypeAssist = this;
70 	
71 	kqe_trace("创建跨区副本模块 成功");
72 	return true;
73 }
98 	g_pEctypeAssist = NULL;
99 }
101 /** 取得跨区副本信息
102 */
103 const SKqEctypeScheme* CEctypeAssist::GetKqEctypeScheme(WORD wTypeID)
111 	return &(it->second);
112 }
114 /** 取得跨区副本配置信息
115 */
116 const SKqEctypeConfig* CEctypeAssist::GetKqEctypeConfig()
220 	}
221 	TraceLn(osb.c_str());
223 	// 这里需要做跨区均衡处理
224 	if (pEctypeConfig->bLocalEctype == true)
225 	{
291 	if (pKqEctype->Create(dwSerial, pEctypeTeam) == false)
292 	{
293 		ErrorLn("[CreateKqEctype] 创建跨区副本对象失败, dwMatchID=" << pEctypeTeam->dwEctypeType << " dwSerial=" << dwSerial);
294 		delete pKqEctype;
295 		return false;
617 	MyTransport(pPerson, pLocInfo->dwWorldID, pLocInfo->dwSrcZoneID, ptLoc, tStarTrek_Flag_RunOnDie|tStarTrek_Flag_RunOnEctype);
618 }
620 /** 处理跨区桥服务器发过来的消息
621 */
622 void CEctypeAssist::HandleBridgeMessage(unsigned long actionId, SMsgBridgeHead &bridgeHead, SGameMsgHead* head, LPSTR data, size_t len)
694 	default:
695 		{
696 			ErrorLn("跨区副本消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
697 			break;
698 		}
762 			break;
763 		}
765 		// 跨区通知
766 	case MSG_KQE_DIDANOTIFY:
767 		{
772 	default:
773 		{
774 			ErrorLn("跨区副本消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
775 		}
776 		break;
832 	default:
833 		{
834 			ErrorLn("跨区副本消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
835 			break;
836 		}
1054 		return false;
1055 	}
1057 	// 跨区副本配置脚本
1058 	string strPath;
1059 	if (isPublicGameWorld() == true)
1075 	return true;
1076 }
1078 /// purpose:  加载跨区副本配置脚本
1079 bool CEctypeAssist::LoadKqEctypeScheme(ICSVReader * pCSVReader)
1080 {
1107 		if (nCount != 2)
1108 		{
1109 			ErrorLn("跨区副本配置脚本" << "限制开始时间 配置错误");
1110 			return false;
1111 		}
1122 		if (nCount != 2)
1123 		{
1124 			ErrorLn("跨区副本配置脚本" << "限制结束时间 配置错误");
1125 			return false;
1126 		}
1295 	return dwServerID;
1296 }
1298 /** 创建一个跨区副本序号
1299 */
1300 DWORD CEctypeAssist::CreateSerialID()
1344 		}
1345 		const SKqEctypeContext* pEctypeContext = pKqEctype->GetContext();
1347 		// 玩家进入跨区副本
1348 		if (pEctypeContext->dwZoneID == pEvent->dwNewZoneID)
1349 		{
1348 		if (pEctypeContext->dwZoneID == pEvent->dwNewZoneID)
1349 		{
1350 			kqe_trace("[玩家进入跨区副本] 玩家：" << pPerson->GetName() << "副本序号：" << pEctypeContext->dwSerialID);
1352 			SKqEctypeMember* pMember = (SKqEctypeMember*)pKqEctype->GetMemberInfoByPDBID(dwPDBID);
1353 			if (pMember == NULL)
1353 			if (pMember == NULL)
1354 			{
1355 				WarningLn("[跨区副本 场景切换] 全局表和副本内的成员表不一致，玩家ID：" << dwPDBID);
1356 				return;
1357 			}
1360 			if (pMember->bEnter == false)
1361 			{
1362 				kqe_trace("[第一次进入跨区副本] 玩家：" << pPerson->GetName() << "副本序号：" << pEctypeContext->dwSerialID);
1364 				IEctype* pEctypeObj =  pEctypeManager->findEctype(pEctypeContext->dwZoneID);
1365 				CEctypeAssistPart* pEctypeAssistPart = (CEctypeAssistPart*)pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
1385 			else
1386 			{
1387 				kqe_trace("[重复进入跨区副本] 玩家：" << pPerson->GetName() << "副本序号：" << pEctypeContext->dwSerialID);
1389 				// KqReturnToEctype(ectypeType, actor)
1390 				CLuaParam param[3];
1399 		else if (pEctypeContext->dwZoneID == pEvent->dwOldZoneID)
1400 		{
1401 			kqe_trace("[从跨区副本出去] 玩家：" << pPerson->GetName() << "副本序号：" << pEctypeContext->dwSerialID << "场景ID：" << pEctypeContext->dwZoneID);
1403 			// KqGoOutEctype(ectypeType, actor, oldZoneID, newZoneID)
1404 			CLuaParam param[5];
1471 		return;
1472 	}
1473 	kqe_trace("[跨区副本 玩家登陆] 玩家：" << pPerson->GetName());
1474 	const SKqEctypePartContext*  pContext = pEctypeAssistPart->GetEctypeContext();	
1475 	// 如果玩家在副本状态，到副本所在的场景服验证是否有效
1486 			const SKqEctypeContext* pEctypeContext = pKqEctype->GetContext();
1487 			DWORD dwNewZoneID = pPerson->GetZoneID();
1489 			// 玩家进入跨区副本
1490 			if (pEctypeContext->dwZoneID == dwNewZoneID)
1491 			{
1490 			if (pEctypeContext->dwZoneID == dwNewZoneID)
1491 			{
1492 				kqe_trace("[登陆进入跨区副本] 玩家：" << pPerson->GetName() << "副本序号：" << pEctypeContext->dwSerialID << " 副本场景：" << dwNewZoneID);
1494 				SKqEctypeMember* pMember = (SKqEctypeMember*)pKqEctype->GetMemberInfoByPDBID(dwPDBID);
1495 				if (pMember == NULL)
1495 				if (pMember == NULL)
1496 				{
1497 					WarningLn("[登陆进入跨区副本 场景切换] 全局表和副本内的成员表不一致，玩家ID：" << dwPDBID);
1498 					return;
1499 				}
1502 				if (pMember->bEnter == false)
1503 				{
1504 					kqe_trace("[第一次进入跨区副本] 玩家：" << pPerson->GetName() << "副本序号：" << pEctypeContext->dwSerialID);
1506 					IEctype* pEctypeObj =  pEctypeManager->findEctype(pEctypeContext->dwZoneID);
1507 					CEctypeAssistPart* pEctypeAssistPart = (CEctypeAssistPart*)pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
1529 				else
1530 				{
1531 					kqe_trace("[重复进入跨区副本] 玩家：" << pPerson->GetName() << "副本序号：" << pEctypeContext->dwSerialID);
1533 					// KqReturnToEctype(ectypeType, actor, serialID)
1534 					CLuaParam param[3];
1597 		return;
1598 	}
1599 	// 跨区副本部件
1600 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
1601 	if (NULL==pEctypeAssistPart)
1661 void CEctypeAssist::OnClientGoEctype(IPerson* pPerson, SMsgMatchDataSubMsg* pSubMsg, LPSTR pszMsg, size_t nLen)
1662 {
1663 	kqe_trace("[前往跨区副本] 玩家：" << pPerson->GetName());
1665 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
1666 	if (pBridgeConnector == NULL)
1772 	}
1773 }
1775 // 创建一个跨区副本
1776 void CEctypeAssist::OnTransmitCreateEctype(DWORD dwServerID, SMsgMatchDataSubMsg* pSubMsg, LPSTR pszMsg, size_t nLen)
1777 {
1879 		return;
1880 	}
1882 	// 把玩家设置成跨区副本状态
1883 	SKqEctypePartContext context;
1884 	context.dwEctypeType = pCall->dwEctypeType;
2088 	}
2090 	// TODOTODO 提示下
2092 	// 把玩家设置成跨区副本状态
2093 	pEctypeAssistPart->SetEctypeContext(pContext);
2095 	// 传送到公共区的副本 TODOTODO

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MatchServer\DummyServer.cpp 23 KB CPP 文件 2014/2/25 14:27:01 2018/10/23 19:45:10 2018/10/23 19:45:10 4
448 		return;
449 	}
451 	// 跨区副本部件
452 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
453 	if (NULL==pEctypeAssistPart)
564 		return;
565 	}
567 	// 跨区副本部件
568 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
569 	if (NULL==pEctypeAssistPart)
741 }
743 //////////////////////////////////////////////////////////////////////////
745 /** 处理跨区桥服务器发过来的消息
746 @name         : 处理其他服务器通过跨区桥服务器转发的消息
747 @param actionId  : 消息码
748 @param bridgeHead  : 桥消息头

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MatchServer\Dummy.cpp 45 KB CPP 文件 2014/2/25 14:27:00 2018/10/23 19:45:10 2018/10/23 19:45:10 3
674 		return false;
675 	}
677 	// 跨区副本部件
678 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
679 	if (NULL==pEctypeAssistPart)
903 		return false;
904 	}
906 	// 跨区副本部件
907 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
908 	if (NULL==pEctypeAssistPart)
1512 		return;
1513 	}
1514 	// 跨区副本部件
1515 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
1516 	if (NULL==pEctypeAssistPart)

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MatchServer\CountryWar.cpp 208 KB CPP 文件 2014/2/25 14:27:00 2018/10/23 19:45:09 2018/10/23 19:45:09 1
5858 		return 0;
5859 	}
5860 	// 取得跨区竞技部件指针
5861 	IPersonStrikePart *pPersonStrikePart = (IPersonStrikePart *)pPerson->GetEntityPart(ENTITYPART_PERSON_STRIKE);
5862 	if (pPersonStrikePart == NULL)

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MatchServer\CGameMatchAPI.cpp 148 KB CPP 文件 2014/2/25 14:26:57 2018/10/23 19:45:08 2018/10/23 19:45:08 21
134 	return pMatchServer->GetWarConfigName(dwConfigNameType);
135 };
137 /**  取得跨区战争系统
138 @param   
138 @param   
139 @return  取得跨区战争系统
140 */
141 IWarServer * CGameMatchAPI::GetWarServer()
149 	return pMatchServer->GetWarServer();
151 }
155 //========================================================跨区副本API==================================================
157 /** 取得某个玩家的副本ID
158 @return 副本序号
167 	return g_pEctypeAssist->GetKqEctypeID(dwPDBID);
168 }
170 /** 取得跨区副本现场
171 @param dwSerialID 副本序号
172 */
186 	return pKqEctype->GetContext();
187 }
189 /** 取得跨区副本成员个数
190 @param dwSerialID 副本序号
191 */
205 	return pKqEctype->GetMemberCount();
206 }
208 /** 取得跨区副本成员信息
209 @param dwSerialID 副本序号
210 */
224 	return pKqEctype->GetMemberInfo(nIndex);
225 }
227 /** 取得跨区副本成员信息
228 @param dwSerialID 副本序号
229 */
243 	return pKqEctype->GetMemberInfoByPDBID(dwPDBID);
244 }
246 /** 跨区副本结束
247 @param dwSerialID 副本序号
248 */
263 	pKqEctype->Release();*/
264 }
266 /** 跨区副本结束
267 @param nActor		玩家序列号
268 @param wEctypeType	副本类型
283 	return g_pEctypeAssist->CanEctype(pPerson->GetUID(), wEctypeType);
284 }
286 /** 取得玩家跨区部件身上的副本序号
287 @param nActor		玩家序列号
288 @param wEctypeType	副本类型
319 	return 0;
320 }
322 /** 进入跨区副本
323 @param nActor		玩家序列号
324 */
333 	g_pEctypeAssist->GoEctype(pPerson);
334 }
336 /** 离开跨区副本
337 @param nActor		玩家序列号
338 */
394 SGlobalEctypeTeam g_GlobalEctypeTeam;
395 int g_nTestKqeMemberCount;
397 /** 创建跨区副本 开始
398 @param dwEctypeType	 副本类型
399 @param nDifficulty	 副本难度
411 	g_GlobalEctypeTeam.nTeamID = nTeamID;
412 }
414 /** 创建跨区副本 添加成员
415 @param dwPDBID	 副本类型
416 @param dwWorldID 副本难度
434 	}
435 }
437 /** 创建跨区副本 完成
438 */ 
439 int CGameMatchAPI::NewKqeEnd()
447 	return g_pEctypeAssist->AcceptEctypeTeam(&g_GlobalEctypeTeam);
449 }
451 /** 到社会服创建跨区副本 完成
452 */ 
453 int CGameMatchAPI::SocialNewKqeEnd()
1609 	return true;
1610 }
1612 ///////////// 跨区战场API /////////////////////////////////////////////////////////////
1614 /** 用现场创建跨服国战
1615 @param  DWORD dwWarTypeID		: 战场场类型 EMWarItemType
2065 		return 0;
2066 	}
2068 	// 判断是否是跨区国战类型
2069 	if (pWar->GetWarMode() != dwWaMode)
2070 	{
3832 		return false;
3833 	}
3834 	// 判断是否是跨区国战类型
3835 	if (!pWar->GetPVPClass()->IsWar())
3836 	{
3837 		return false;
3838 	}
3840 	// 判断是否是跨区国战类型
3841 	if (!pWar->GetWarMode() == WarMode_Country)
3842 	{
4014 		return 0;
4015 	}
4017 	// 判断是否是跨区国战类型
4018 	if (!pWar->GetWarMode() == WarMode_Country)
4019 	{

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MatchServer\BudoServer.cpp 52 KB CPP 文件 2014/2/25 14:26:56 2018/10/23 19:45:08 2018/10/23 19:45:08 4
242 		return;
243 	}
245 	// 跨区副本部件
246 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
247 	if (NULL==pEctypeAssistPart)
1143 }
1145 //////////////////////////////////////////////////////////////////////////
1147 /** 处理跨区桥服务器发过来的消息
1148 @name         : 处理其他服务器通过跨区桥服务器转发的消息
1149 @param actionId  : 消息码
1150 @param bridgeHead  : 桥消息头
1470 		return;
1471 	}
1473 	// 跨区副本部件
1474 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
1475 	if (NULL==pEctypeAssistPart)

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MatchServer\Budo.cpp 83 KB CPP 文件 2014/2/25 14:26:55 2018/10/23 19:45:07 2018/10/23 19:45:07 2
711 		return false;
712 	}
714 	// 跨区副本部件
715 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
716 	if (NULL==pEctypeAssistPart)
2667 		return;
2668 	}
2670 	// 跨区副本部件
2671 	IEctypeAssistPart * pEctypeAssistPart = (IEctypeAssistPart * ) pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
2672 	if (NULL==pEctypeAssistPart)

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MarryServer\TeachStudPart.cpp 30 KB CPP 文件 2014/2/25 14:26:50 2018/10/23 19:45:06 2018/10/23 19:45:06 2
395 // 	return true;
396 }
398 /** 跨区切换地图时，将部件数据导出带过去,　如果没有数据，将nLen设为0或返回false
399 @param   
400 @param   
432 	return true;
433 }
435 /** 跨区切换地图时，将部件数据现场导入
436 @param   
437 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MarryServer\StockPart.cpp 27 KB CPP 文件 2014/2/25 14:26:46 2018/10/23 19:45:05 2018/10/23 19:45:05 2
310 // 	return true;
311 }
313 /** 跨区切换地图时，将部件数据导出带过去,　如果没有数据，将nLen设为0或返回false
314 @param   
315 @param   
344 	return true;
345 }
347 /** 跨区切换地图时，将部件数据现场导入
348 @param   
349 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MarryServer\SecurityPart.cpp 55 KB CPP 文件 2014/2/25 14:26:44 2018/10/23 19:45:05 2018/10/23 19:45:05 2
718 // 	return true;
719 }
721 /** 跨区切换地图时，将部件数据导出带过去,　如果没有数据，将nLen设为0或返回false
722 @param   
723 @param   
748 	return true;
749 }
751 /** 跨区切换地图时，将部件数据现场导入
752 @param   
753 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MarryServer\RoleVendedPart.cpp 41 KB CPP 文件 2014/2/25 14:26:38 2018/10/23 19:45:04 2018/10/23 19:45:04 2
464 // 	return true;
465 }
467 /** 跨区切换地图时，将部件数据导出带过去,　如果没有数据，将nLen设为0或返回false
468 @param   
469 @param   
481 	return	ExportRenewContext(pszContext, nLen);
482 }
484 /** 跨区切换地图时，将部件数据现场导入
485 @param   
486 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MarryServer\ResAdjustPart.cpp 13 KB CPP 文件 2014/2/25 14:26:37 2018/10/23 19:45:04 2018/10/23 19:45:04 3
340 // 	return true;
341 }
343 /** 跨区切换地图时，将部件数据导出带过去,　如果没有数据，将nLen设为0或返回false
344 @param   
345 @param   
379 	return true;
380 }
382 /** 跨区切换地图时，将部件数据现场导入
383 @param   
384 @param   
531 	}
532 }
534 /** 设置跨区用值
535 @param   
536 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MarryServer\MiscPart.cpp 73 KB CPP 文件 2014/2/25 14:26:34 2018/10/23 19:45:02 2018/10/23 19:45:02 2
773 // 	return true;
774 }
776 /** 跨区切换地图时，将部件数据导出带过去,　如果没有数据，将nLen设为0或返回false
777 @param   
778 @param   
813 	return true;
814 }
816 /** 跨区切换地图时，将部件数据现场导入
817 @param   
818 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MarryServer\MarryPart.cpp 79 KB CPP 文件 2014/2/25 14:26:33 2018/10/23 19:45:02 2018/10/23 19:45:02 2
718 	return true;
719 }
721 /** 跨区切换地图时，将部件数据导出带过去,　如果没有数据，将nLen设为0或返回false
722 @param   
723 @param   
736 	return false; 
737 }
739 /** 跨区切换地图时，将部件数据现场导入
740 @param   
741 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MarryServer\InvitePart.cpp 64 KB CPP 文件 2014/2/25 14:26:31 2018/10/23 19:45:01 2018/10/23 19:45:01 2
633 // 	return true;
634 }
637 /** 跨区切换地图时，将部件数据导出带过去,　如果没有数据，将nLen设为0或返回false
638 @param   
639 @param   
704 	return true;
705 }
707 /** 跨区切换地图时，将部件数据现场导入
708 @param   
709 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MarryServer\CreditPart.cpp 39 KB CPP 文件 2014/2/25 14:26:26 2018/10/23 19:45:00 2018/10/23 19:45:00 2
447 	return true;
448 }
450 /** 跨区切换地图时，将部件数据导出带过去,　如果没有数据，将nLen设为0或返回false
451 @param   
452 @param   
465 	return false; 
466 }
468 /** 跨区切换地图时，将部件数据现场导入
469 @param   
470 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MarryServer\CardCollectPart.cpp 42 KB CPP 文件 2014/2/25 14:26:25 2018/10/23 19:45:00 2018/10/23 19:45:00 2
535 // 	return true;
536 }
538 /** 跨区切换地图时，将部件数据导出带过去,　如果没有数据，将nLen设为0或返回false
539 @param   
540 @param   
552 	return	ExportRenewContext(pszContext, nLen);
553 }
555 /** 跨区切换地图时，将部件数据现场导入
556 @param   
557 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\LuaServer\LuaServer.cpp 11 KB CPP 文件 2014/2/25 14:25:55 2018/10/23 19:44:40 2018/10/23 19:44:40 1
237 }
239 /**
240 @name         : 处理其他服务器通过跨区桥服务器转发的消息
241 @param actionId  : 消息码
242 @param bridgeHead  : 桥消息头

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\LuaServer\GameMatchAPI.cpp 68 KB CPP 文件 2014/2/25 14:25:52 2018/10/23 19:44:39 2018/10/23 19:44:39 17
123 	return pMatchServer->GetWarConfigName(dwConfigNameType);
124 };
126 /**  取得跨区战争系统
127 @param   
127 @param   
128 @return  取得跨区战争系统
129 */
130 IWarServer * GetWarServer()
138 	return pMatchServer->GetWarServer();
140 }
144 //========================================================跨区副本API==================================================
146 /** 取得某个玩家的副本ID
147 @return 副本序号
151 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->GetKqEctypeID(dwPDBID);
152 }
154 /** 取得跨区副本现场
155 @param dwSerialID 副本序号
156 */
159 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->GetKqeContext(dwSerialID);
160 }
162 /** 取得跨区副本成员个数
163 @param dwSerialID 副本序号
164 */
167 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->GetKqeMemberCount(dwSerialID) ;
168 }
170 /** 取得跨区副本成员信息
171 @param dwSerialID 副本序号
172 */
175 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->GetKqeMemberInfo(dwSerialID, nIndex) ;
176 }
178 /** 取得跨区副本成员信息
179 @param dwSerialID 副本序号
180 */
183 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->GetKqeMemberInfoByPDBID(dwSerialID, dwPDBID) ;
184 }
186 /** 跨区副本结束
187 @param dwSerialID 副本序号
188 */
191 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->KqEctypeEnd(dwSerialID);
192 }
194 /** 跨区副本结束
195 @param nActor		玩家序列号
196 @param wEctypeType	副本类型
200 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->CanKqEctype(nActor, wEctypeType);
201 }
203 /** 取得玩家跨区部件身上的副本序号
204 @param nActor		玩家序列号
205 @param wEctypeType	副本类型
209 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->GetKqEctypeIDByActor(nActor, wEctypeType);
210 }
212 /** 进入跨区副本
213 @param nActor		玩家序列号
214 */
217 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->EnterKqEctype(nActor);
218 }
220 /** 离开跨区副本
221 @param nActor		玩家序列号
222 */
233 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->KqeSetCurZoneID(dwSerialID, dwZoneID);
234 }
237 /** 创建跨区副本 开始
238 @param dwEctypeType	 副本类型
239 @param nDifficulty	 副本难度
245 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->NewKqeBegin(dwEctypeType, nDifficulty, nCaptainIndex, nTeamID);
246 }
248 /** 创建跨区副本 添加成员
249 @param dwPDBID	 副本类型
250 @param dwWorldID 副本难度
256 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->NewKqeAddMember(dwPDBID, dwWorldID,  nLevel, szName, bOnlyTransport);
257 }
259 /** 创建跨区副本 完成
260 */ 
261 int NewKqeEnd()
263 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->NewKqeEnd();
264 }
266 /** 到社会服创建跨区副本 完成
267 */ 
268 int SocialNewKqeEnd()
760 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->ActorStrikeUseXPSkill( dwActorID,  dwSkillID,  dwSkillSubID);
761 }
763 ///////////// 跨区战场API /////////////////////////////////////////////////////////////
765 /** 用现场创建跨服国战
766 @param  DWORD dwWarTypeID		: 战场场类型 EMWarItemType

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\LuaServer\GameEngineAPI.cpp 220 KB CPP 文件 2014/2/25 14:25:49 2018/10/23 19:44:38 2018/10/23 19:44:38 1
1251 }
1253 /**
1254 @name            : 创建人物完成跨区笑傲江湖任务
1255 @brief           : 
1256 @param szCallFunc: 回调函数名

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\GameResCreator\DropPrizeCreator.cpp 138 KB CPP 文件 2014/2/25 14:25:04 2018/10/23 19:44:01 2018/10/23 19:44:01 1
4378 				return;
4379 			}
4380 /* 由于现在跨区，资源等级从部件等地直接获取，所以这里要是没有了应该是没有问题的
4381 			SMsgResAdjustSyncCivil* pMsg = (SMsgResAdjustSyncCivil*)pszContext;
4382 			if (pMsg->nCivilGrade<=0 || pMsg->nCivilGrade>CIVIL_MAX_LEVEL)

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\EntityServer\PersonPropBank.cpp 192 KB CPP 文件 2014/2/25 14:25:14 2018/10/23 19:43:53 2018/10/23 19:43:53 2
3637 	return m_pGameZone;
3638 }
3640 /** 跨区切换地图时，将临时小型数据导出带过去, 如果没有数据，将nLen设为0或返回false
3641 @param   
3642 @param   
3648 	return false;
3649 }
3651 /** 跨区切换地图时，将临时小型数据导入
3652 @param   
3653 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\EntityServer\PersonMountingPart.cpp 15 KB CPP 文件 2014/2/25 14:25:12 2018/10/23 19:43:52 2018/10/23 19:43:52 2
441 // 	return false;
442 }
445 /** 跨区切换地图时，将部件数据导出带过去,　如果没有数据，将nLen设为0或返回false
446 @param   
447 @param   
459 	return ExportRenewContext(pszContext,nLen);
460 }
462 /** 跨区切换地图时，将部件数据现场导入
463 @param   
464 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\EntityServer\PersonBattleRidePart.cpp 224 KB CPP 文件 2014/2/25 14:25:09 2018/10/23 19:43:51 2018/10/23 19:43:51 2
3484 // 	return true;
3485 }
3488 /** 跨区切换地图时，将部件数据导出带过去,　如果没有数据，将nLen设为0或返回false
3489 @param   
3490 @param   
3502 	return ExportRenewContext(pszContext,nLen);
3503 }
3505 /** 跨区切换地图时，将部件数据现场导入
3506 @param   
3507 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\EntityServer\Person.cpp 54 KB CPP 文件 2014/2/25 14:25:08 2018/10/23 19:43:51 2018/10/23 19:43:51 2
745 	return m_PersonPropBank.ExportDetailContext(pszContext, nLen);
746 }
748 /** 跨区切换地图时，将临时小型数据导出带过去, 如果没有数据，将nLen设为0或返回false
749 @param   
750 @param   
755 	return m_PersonPropBank.ExportTrekContext(pszContext, nLen);
756 }
758 /** 跨区切换地图时，将临时小型数据导入
759 @param   
760 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\EntityServer\EntityServer.cpp 129 KB CPP 文件 2014/2/25 14:24:48 2018/10/23 19:43:45 2018/10/23 19:43:45 15
372 	return pNewEntity;	
373 }
375 /** 通过跨区数据构造实体(只限人物)
376 @param   
377 @param   
395 		buildproc[dwEntityClass] == NULL)
396 	{
397 		Error("通过跨区数据构造实体失败！场景ID = " << dwZoneID << "，EntityClass = " << dwEntityClass << endl);
398 		return NULL;
399 	}
411 	else
412 	{
413 		Error("通过跨区数据构造实体失败！场景ID = " << dwZoneID << "，EntityClass = " << dwEntityClass << endl);
414 		return NULL;
415 	}
1210 	}
1211 	pPerson->AddEntityPart(pArenaPart);
1213 	// 创建跨区副本部件
1214 	IEctypeAssistPart* pEctypeAssistPart = gZoneServiceProvider->GetMatchServer()->CreateEctypeAssistPart();
1215 	FiltPersonContext(nLoginMode, ENTITYPART_PERSON_ECTYPEASSIST, pszContext, nLen, pszDest, nDestLen);
1216 	if(!pEctypeAssistPart->Create(pPerson, pszDest, nDestLen, nLoginMode))
1217 	{
1218 		TRACE_NEWPERSON_FAILED("构建跨区副本部件");
1219 		pPerson->Clean();
1220 		SAFE_RELEASE(pEctypeAssistPart);
1932 		return NULL;
1933 	}
1935 	// 创建跨区副本部件
1936 	IEntityPart* pEctypeAssistPart = pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
1937 	FiltPersonContext(nLoginMode, ENTITYPART_PERSON_ECTYPEASSIST, pszContext, nLen, pszDest, nDestLen);
1938 	if(!pEctypeAssistPart->Create(pPerson, pszDest, nDestLen, nLoginMode))
1939 	{
1940 		TRACE_REUSERPERSON_FAILED("创建跨区副本部件");
1942 		pPerson->Restore();
1944 		return NULL;
3569 			}
3570 			break;
3571 		case ENTITYPART_PERSON_ECTYPEASSIST: // 跨区副本部件
3572 			{
3573 				pszDest = (LPSTR)pSrc->byKqEctypeData; nDestLen = sizeof(pSrc->byKqEctypeData);
3574 			}
3575 			break;
3576 		case ENTITYPART_PERSON_STRIKE: // 跨区竞技部件
3577 			{
3578 				pszDest = (LPSTR)pSrc->byStrikeData; nDestLen = sizeof(pSrc->byStrikeData);
3727 			}
3728 			break;
3729 		case ENTITYPART_PERSON_ECTYPEASSIST: // 跨区副本部件
3730 			{
3731 				pszDest = (LPSTR)pSrc->byKqEctypeData; nDestLen = sizeof(pSrc->byKqEctypeData);
3737 			}
3738 			break;
3739 		case ENTITYPART_PERSON_STRIKE: // 跨区竞技部件
3740 			{
3741 				pszDest = (LPSTR)pSrc->byStrikeData; nDestLen = sizeof(pSrc->byStrikeData);
4525 		return NULL;
4526 	}
4528 	// 创建跨区副本部件
4529 	IEntityPart* pEctypeAssistPart = pPerson->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
4530 	if(!pEctypeAssistPart->Create_ORM(pPerson, pszDest, nDestLen, nLoginMode))
4530 	if(!pEctypeAssistPart->Create_ORM(pPerson, pszDest, nDestLen, nLoginMode))
4531 	{
4532 		TRACE_REUSERPERSON_FAILED("创建跨区副本部件");
4534 		pPerson->Restore();
4536 		return NULL;
5078 	}
5079 	
5081 	// 创建跨区副本部件
5082 	IEctypeAssistPart* pEctypeAssistPart = gZoneServiceProvider->GetMatchServer()->CreateEctypeAssistPart();	
5083 	if(!pPerson->AddEntityPart(pEctypeAssistPart))
5083 	if(!pPerson->AddEntityPart(pEctypeAssistPart))
5084 	{
5085 		ErrorLn("构建跨区副本部件失败");		
5086 		SAFE_RELEASE(pPerson);
5087 		return NULL;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\EntityServer\CreatureCommonPart.cpp 128 KB CPP 文件 2014/2/25 14:24:41 2018/10/23 19:43:42 2018/10/23 19:43:42 2
3203 					return;
3204 				}
3205 				// 跨区查看玩家装备
3206 				SMsgActionWorldLookEquip_SC sendData;
3207 				sendData.dwPDBID		= pMsg->dwPDBID;		// 看谁的PDBID
3322 				//	return;
3323 				//}
3324 				//// 跨区查看玩家装备
3325 				//SMsgActionWorldLookEquip_SC sendData;
3326 				//sendData.dwPDBID		= pMsg->dwPDBID;		// 看谁的PDBID

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\EnterManager\SaveActorToVan.cpp 55 KB CPP 文件 2014/2/25 14:24:33 2018/10/23 19:43:39 2018/10/23 19:43:39 15
119 		}
120 	}
124 	//     ORM改造, 目前不考虑跨区切换流程, 这个代码先屏蔽, 以后考虑跨区时再定详细方案
125 // 	如果跨区切换，此处要把人物坐标替换成迁入游戏世界的地图ID和位置，迁入游戏世界登陆服才能方读到相应的位置
126 // 		if(nType == ESaveToVan_Type_StarTrek && pContext != NULL && nContextLen == sizeof(SStarTrekContext))
127 // 		{
446 					 2：定时缓存、不存入数据库、不解锁
447 					 3：定时保存、要存入数据库、不解锁
448 @param   pContext   ：跨区用扩展数据
449 @param   nContextLen：跨区用扩展数据长度
450 @param   nOutContextLen：切换进程导出数据
451 @param   nOutLen    ：切换进程最大可导出数据长度
490 	else if(nType == ESaveToVan_Type_StarTrek)
491 	{
492 		sprintf_s(szLogoutDesc, "%s跨区切换，pdbid=%d，", pMaster->GetName(), dwPDBID);
493 	}
494 	else
562 		}
563 	}
565 	// 如果跨区切换，此处要把人物坐标替换成迁入游戏世界的地图ID和位置，迁入游戏世界登陆服才能方读到相应的位置
566 	if(nType == ESaveToVan_Type_StarTrek && pContext != NULL && nContextLen == sizeof(SStarTrekContext))
567 	{
750 		return -1;
751 	}
753 	// 跨区副本数据
754 	IEntityPart * pKqEctypePart = pMaster->GetEntityPart(ENTITYPART_PERSON_ECTYPEASSIST);
755 	nSaveLen = sizeof(reqsaveactor.byKqEctypeData);
756 	if(!pKqEctypePart->ExportDBContext((LPSTR)reqsaveactor.byKqEctypeData, nSaveLen))
757 	{
758 		EmphasisLn(szLogoutDesc<<"导出跨区副本数据失败！");
759 		return false;
760 	}
759 		return false;
760 	}
762 	// 跨区竞技PK数据
763 	IEntityPart * pStrikePart = pMaster->GetEntityPart(ENTITYPART_PERSON_STRIKE);
764 	nSaveLen = sizeof(reqsaveactor.byStrikeData);
765 	if(!pStrikePart->ExportDBContext((LPSTR)reqsaveactor.byStrikeData, nSaveLen))
766 	{
767 		EmphasisLn(szLogoutDesc<<"导出跨区竞技PK数据失败！");
768 		return false;
769 	}
1485 	}
1486 }
1488 /** 获取跨区切换的现场
1489 @param   
1490 @param   
1555 		if(!ofixb.good())
1556 		{
1557 			ErrorLn("跨区切换场景失败...获取现场给出buffer太小! partid="<<iPart);
1558 			debugBreak;
1560 			return -1;
1564 	if(!ofixb.good())
1565 	{
1566 		ErrorLn("跨区切换场景失败...获取现场给出buffer太小!");
1567 		debugBreak;
1569 		return -1;
1693 	case ESaveToVan_Type_StarTrek:  // 距区切换、要存入数据库、解锁
1694 		{
1695 			ErrorLn("CSaveActorHelper::SaveToVan  跨区切换暂不支持   Actor:" << pMaster->GetName());
1696 			return DBSVR::INVALID_TRANSACTID;;
1697 		}

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\EnterManager\LoginTransmit.cpp 7 KB CPP 文件 2014/2/25 14:24:32 2018/10/23 19:43:38 2018/10/23 19:43:38 1
142 			else
143 			{
144 				TraceLn("[跨区]玩家登入场景服PDBID="<<pMsg->dwActorDBID<<" clientid="<<pMsg->dwClientID<<" UDBID="<<pMsg->dwUserID);
146 				CTerminalTunnel * pTerminalTunnel = new CTerminalTunnel();				
147 				pTerminalTunnel->Create(pMsg->dwClientID);

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\EnterManager\EnterManager.cpp 35 KB CPP 文件 2014/2/25 14:24:29 2018/10/23 19:43:37 2018/10/23 19:43:37 1
1059 	}
1061 }
1063 /** 获取跨区切换的现场
1064 @param   
1065 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\EnterManager\DBRetSinkSetUserLockForTrek.cpp 15 KB CPP 文件 2014/2/25 14:24:29 2018/10/23 19:43:36 2018/10/23 19:43:36 25
71 	if(nFromGameWorldID <= 0)
72 	{
73 		ErrorLn("[跨区]严重问题!加锁返回后取得的FromGameWorldID无效,UDBID="<<nQueueIndex);
74 	}
75 	g_CancelUserSolidLock.EraseFromGameWorldIDForShoot(nQueueIndex);
78 	if(pTerminalTunnel == NULL)
79 	{
80 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, m_nExecuteGameWorldID, "[跨区]TerminalTunnel返回时已无效");
81 		return;
82 	}
85 	{
86 		char szUnlockReason[1024] = { 0 };
87 		sprintf_s(szUnlockReason, "[跨区]加永久锁时DB返回失败, DBError Desc=%s", pszDBRetDesc);
88 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, m_nExecuteGameWorldID, szUnlockReason);
89 		pTerminalTunnel->Kickout(EKickoutClient_Reason_StarTrekFailed, pszDBRetDesc);
95 	{
96 		char szUnlockReason[1024] = { 0 };
97 		sprintf_s(szUnlockReason, "[跨区]StateSaveGameWorldID=%d, FromGameWorldID=%d, ExecuteGameWorldID=%d, ThisWorldID=%d", 
98 			nStateSaveGameWorldID, nFromGameWorldID, m_nExecuteGameWorldID, getThisGameWorldID()); 
99 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, m_nExecuteGameWorldID, szUnlockReason);
104 	if(nOutLen != sizeof(DBREQ_RESULT_SETUSERLOCK) || pOutData == NULL)
105 	{			
106 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, m_nExecuteGameWorldID, "[跨区]加永久锁时返回数据大小不合法");
107 		pTerminalTunnel->Kickout(EKickoutClient_Reason_StarTrekFailed, "请求异常,请向游戏管理员请求支持[0x1A9F].");
108 		return;
113 	{
114 		char szUnlockReason[1024] = { 0 };
115 		sprintf_s(szUnlockReason, "[跨区]数据库返回的UDBID校验失败. DBReturnUDBID=%d, QueueIndex=%d, TerminalUDBID=%d", 
116 				  pMsg->dwUserID, nQueueIndex, pTerminalTunnel->GetUDBID());
117 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, m_nExecuteGameWorldID, szUnlockReason);
123 	{
124 		char szTraceDesc[1024] = { 0 };
125 		sprintf_s(szTraceDesc, "[跨区]设置永久锁存在严重的流程控制问题, 需修正.UDBID=%d, 描述=%s", pMsg->dwUserID, pszDBRetDesc);
126 		ErrorLn(szTraceDesc); AlertError(MG_AlertSrcType_DataBase, szTraceDesc);
127 	}
133 	if(g_ExternalFacade.GetZoneSvrRunState() != EZoneServer_RunState_Running ||	pVanConnector == NULL || !pVanConnector->IsRunning())
134 	{			
135 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, m_nExecuteGameWorldID, "[跨区]服务器群停机维护期间禁止登陆");
136 		pTerminalTunnel->Kickout(EKickoutClient_Reason_StarTrekFailed, "服务器群停机维护期间禁止登陆..");
137 		return;
141 	if(pEnterGameWorldInfo == NULL)
142 	{
143 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, m_nExecuteGameWorldID, "[跨区]加永久锁返回时pEnterGameWorldInfo为空");
144 		pTerminalTunnel->Kickout(EKickoutClient_Reason_StarTrekFailed, "请求异常,请向游戏管理员请求支持[0x729F].");
145 		return;
150 	if(pNeedInObject == NULL)
151 	{
152 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, m_nExecuteGameWorldID, "[跨区]加永久锁返回时NeedInObject对像已不存在");
153 		pTerminalTunnel->Kickout(EKickoutClient_Reason_StarTrekFailed, "请求异常,请向游戏管理员请求支持[0x629F].");
154 		return;
206 	if(nFromGameWorldID <= 0)
207 	{
208 		ErrorLn("[跨区]严重问题!向公共区加锁返回后取得的FromGameWorldID无效,UDBID="<<nQueueIndex);
209 	}
210 	g_CancelUserSolidLock.EraseFromGameWorldIDForShoot(nQueueIndex);
213 	if(pTerminalTunnel == NULL)
214 	{
215 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, nFromGameWorldID, "[跨区]向公共区加锁返回时TerminalTunnel已无效.");
216 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, m_nExecuteGameWorldID, "[跨区]向公共区加锁返回时TerminalTunnel已无效.");
217 		return;
218 	}
222 	{
223 		char szUnlockReason[1024] = { 0 };
224 		sprintf_s(szUnlockReason, "[跨区]向公共区加锁返回时StateSaveGameWorldID=%d, FromGameWorldID=%d, ExecuteGameWorldID=%d, ThisWorldID=%d", 
225 			nStateSaveGameWorldID, nFromGameWorldID, m_nExecuteGameWorldID, getThisGameWorldID()); 
226 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, nFromGameWorldID,	  szUnlockReason);
233 	{
234 		char szUnlockReason[1024] = { 0 };
235 		sprintf_s(szUnlockReason, "[跨区]向公共区永久锁时DB返回失败, DBError Desc=%s", pszDBRetDesc);
236 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, nFromGameWorldID, szUnlockReason);
237 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, m_nExecuteGameWorldID, szUnlockReason);
242 	if(nOutLen != sizeof(DBREQ_RESULT_SETUSERLOCK) || pOutData == NULL)
243 	{
244 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, nFromGameWorldID, "[跨区]向公共区加锁返回数据大小不合法.");
245 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, m_nExecuteGameWorldID, "[跨区]向公共区加锁返回数据大小不合法.");
246 		pTerminalTunnel->Kickout(EKickoutClient_Reason_StarTrekFailed, "请求异常,请向游戏管理员请求支持[0x4CE5].");
247 		return;
252 	{			
253 		char szUnlockReason[1024] = { 0 };
254 		sprintf_s(szUnlockReason, "[跨区]向公共区加锁返回的UDBID校验失败. DBReturnUDBID=%d, QueueIndex=%d, TerminalUDBID=%d", 
255 			pMsg->dwUserID, nQueueIndex, pTerminalTunnel->GetUDBID());
256 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, nFromGameWorldID, szUnlockReason);
263 	{
264 		char szTraceDesc[1024] = { 0 };
265 		sprintf_s(szTraceDesc, "[跨区] 向公共区设置永久保护锁存在严重的流程控制问题, 需修正! UDBID=%d, 描述=%s", pMsg->dwUserID, pszDBRetDesc);
266 		ErrorLn(szTraceDesc); AlertError(MG_AlertSrcType_DataBase, szTraceDesc);
267 	}
270 	if(pEnterGameWorldInfo == NULL)
271 	{
272 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, nFromGameWorldID, "[跨区]向公共区加永久锁返回时pEnterGameWorldInfo为空");
273 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, m_nExecuteGameWorldID, "[跨区]向公共区加永久锁返回时pEnterGameWorldInfo为空");
274 		pTerminalTunnel->Kickout(EKickoutClient_Reason_StarTrekFailed, "请求异常,请向游戏管理员请求支持[0x7BBF].");
275 		return;
280 	if(pNeedInObject == NULL)
281 	{
282 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, nFromGameWorldID, "[跨区]向公共区加永久锁返回时NeedInObject对像已不存在");
283 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, m_nExecuteGameWorldID, "[跨区]向公共区加永久锁返回时NeedInObject对像已不存在");
284 		pTerminalTunnel->Kickout(EKickoutClient_Reason_StarTrekFailed, "请求异常,请向游戏管理员请求支持[0x6BCF].");
285 		return;
293 	if(g_ExternalFacade.GetZoneSvrRunState() != EZoneServer_RunState_Running ||	pVanConnector == NULL || !pVanConnector->IsRunning())
294 	{
295 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, nFromGameWorldID, "[跨区]向公共区加锁返回后服务器群停机维护.");
296 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, m_nExecuteGameWorldID, "[跨区]向公共区加锁返回后服务器群停机维护.");
297 		pTerminalTunnel->Kickout(EKickoutClient_Reason_StarTrekFailed, "服务器群停机维护期间禁止登陆...");
298 		return;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\EnterManager\DBRetSinkSetSolidLockForTrek.cpp 4 KB CPP 文件 2014/2/25 14:24:28 2018/10/23 19:43:36 2018/10/23 19:43:36 1
5 ** 日  期:	2010/7/13 10:06
6 ** 版  本:	1.0
7 ** 描  述:	跨区加永久锁
8 ** 应  用:  	
10 **************************** 修改记录 ******************************

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\EnterManager\DBRetSinkSelectActorForTrek.cpp 9 KB CPP 文件 2014/2/25 14:24:28 2018/10/23 19:43:36 2018/10/23 19:43:36 12
5 ** 日  期:	2010/8/2 16:48
6 ** 版  本:	1.0
7 ** 描  述:	DBREQ_RESULT_SELECTACTOR 给跨区用的
8 ** 应  用:  	
10 **************************** 修改记录 ******************************
71 	if(nFromGameWorldID <= 0)
72 	{
73 		ErrorLn("[跨区]严重问题!读取角色数据返回后取到的FromGameWorldID无效,UDBID="<<nQueueIndex);
74 	}
75 	g_CancelUserSolidLock.EraseFromGameWorldIDForShoot(nQueueIndex);
78 	if(pTerminalTunnel == NULL)
79 	{
80 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, nFromGameWorldID, "[跨区]读取角色数据返回后TerminalTunnel已无效.");
81 		if(isPublicGameWorld()){
81 		if(isPublicGameWorld()){
82 			g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, getThisGameWorldID(), "[跨区]读取角色数据返回后TerminalTunnel已无效.");}			
83 		return;
84 	}
88 	{
89 		char szUnlockReason[1024] = { 0 };
90 		sprintf_s(szUnlockReason, "[跨区]读取角色数据时StateSaveGameWorldID=%d, FromGameWorldID=%d, ExecuteGameWorldID=%d, ThisWorldID=%d", 
91 			nStateSaveGameWorldID, nFromGameWorldID, m_nExecuteGameWorldID, getThisGameWorldID()); 
92 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, nStateSaveGameWorldID, szUnlockReason);
110 	if(nOutLen < sizeof(DBREQ_RESULT_SELECTACTOR) || pOutData == NULL)
111 	{
112 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, nFromGameWorldID, "[跨区]读取角色数据返回数据大小不合法.");
113 		if(isPublicGameWorld()){
113 		if(isPublicGameWorld()){
114 			g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, getThisGameWorldID(), "[跨区]读取角色数据返回数据大小不合法.");}
115 		pTerminalTunnel->Kickout(EKickoutClient_Reason_StarTrekFailed, "请求异常,请向游戏管理员寻求支持[0x4CED].");
116 		return;
121 	{
122 		char szUnlockReason[1024] = { 0 };
123 		sprintf_s(szUnlockReason, "[跨区]读取角色数据返回的UDBID校验失败. DBReturnUDBID=%d, QueueIndex=%d, TerminalUDBID=%d, DBReturnPDBID=%d, TerminalUDBID=%d", 
124 			pDBReq->dwUserID, nQueueIndex, pTerminalTunnel->GetUDBID(),  pDBReq->dwActorID, pTerminalTunnel->GetPDBID());
126 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, nFromGameWorldID, szUnlockReason);
134 	if(pEnterGameWorldInfo == NULL)
135 	{
136 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, nFromGameWorldID, "[跨区]读取角色数据返回时pEnterGameWorldInfo为空");			
137 		if(isPublicGameWorld()){
137 		if(isPublicGameWorld()){
138 			g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, getThisGameWorldID(), "[跨区]读取角色数据返回时pEnterGameWorldInfo为空");}			
139 		pTerminalTunnel->Kickout(EKickoutClient_Reason_StarTrekFailed, "请求异常,请向游戏管理员寻求支持[0x7DEF].");
140 		return;
145 	if(pNeedInObject == NULL)
146 	{
147 		g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, nFromGameWorldID, "[跨区]读取角色数据返回时NeedInObject对像已不存在");
148 		if(isPublicGameWorld()){
148 		if(isPublicGameWorld()){
149 			g_CancelUserSolidLock.CancelSolidLock(nQueueIndex, getThisGameWorldID(), "[跨区]读取角色数据返回时NeedInObject对像已不存在");}			
150 		pTerminalTunnel->Kickout(EKickoutClient_Reason_StarTrekFailed, "请求异常,请向游戏管理员寻求支持[0x6DAF].");
151 		return;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\EnterManager\ConnectStateTrek.cpp 7 KB CPP 文件 2014/2/25 14:24:27 2018/10/23 19:43:36 2018/10/23 19:43:36 1
5 ** 日  期:	2010/7/2 18:11
6 ** 版  本:	1.0
7 ** 描  述:	跨区切换态
8 ** 应  用:  	
10 **************************** 修改记录 ******************************

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\EnterManager\ConnectStateLoginForTrek.cpp 33 KB CPP 文件 2014/2/25 14:24:26 2018/10/23 19:43:34 2018/10/23 19:43:34 28
5 ** 日  期:	2010/7/11 19:10
6 ** 版  本:	1.0
7 ** 描  述:	跨区登陆态
8 ** 应  用:  	
10 **************************** 修改记录 ******************************
120 	default:
121 		{
122 			Error("[跨区登陆] 玩家登陆态未处理的消息 = " << dwMsgID << endl);
123 			break;
124 		}
194 	reqsetuserlock.dwUserID			= pMsg->dwUserID;
195 	reqsetuserlock.nLockFlag		= 2/*永久保护锁*/;	
196 	reqsetuserlock.OnOffLine		= 1/*因跨区切换而上线*/;
197 	reqsetuserlock.dwActorID		= pMsg->dwActorDBID;
198 	reqsetuserlock.nZoneSvrHardID	= (BYTE)nZoneServerID;
202 		sizeof(reqsetuserlock), &g_DBRetSinkSetUserLockForTrek_ToGeneralDB, pSTContext->nFromGameWorldID))
203 	{
204 		ErrorLn("[跨区]向角色源区请求GAMEDB_REQUEST_SETUSERLOCK失败,UDBID="<<pMsg->dwUserID);
205 		return;
206 	}
229 	if(pNeedInObject == NULL)
230 	{
231 		ErrorLn("[跨区]设置帐号锁请求返回后, NeedInObject对像已不存在, 前面已验证过. UDBID="<<pMsg->dwUserID);
232 		m_pTerminal->Kickout(EKickoutClient_Reason_StarTrekFailed, "请求异常,请向游戏管理员寻求支持[0x929F].");
233 		return;
250 	{
251 		char szUnlockReason[1024] = { 0 };
252 		sprintf_s(szUnlockReason, "[跨区]加永久锁时数据库返回的锁标志不对, LockFlag=%d.", pMsg->nLockFlag);
253 		g_CancelUserSolidLock.CancelSolidLock(m_pTerminal->GetUDBID(), nFromGameWorldID, szUnlockReason);
254 		m_pTerminal->Kickout(EKickoutClient_Reason_StarTrekFailed, "请求异常,请向游戏管理员寻求支持.[0x7F9F]");
267 		if(pDBEngine == NULL)
268 		{
269 			ErrorLn("[跨区]数据库引擎返回NULL, 肯定会锁号. UDBID="<<m_pTerminal->GetUDBID());
270 			return;
271 		}
274 		if(pSchemeCenter == NULL)
275 		{				
276 			ErrorLn("[跨区]SchemeCenter返回NULL, 肯定会锁号. UDBID="<<m_pTerminal->GetUDBID());
277 			return;
278 		}
290 			reqsetuserlock.dwUserID			= m_pTerminal->GetUDBID();
291 			reqsetuserlock.nLockFlag		= 2/*永久保护锁*/;	
292 			reqsetuserlock.OnOffLine		= 1/*因跨区切换而上线*/;
293 			reqsetuserlock.dwActorID		= m_pTerminal->GetPDBID();
294 			reqsetuserlock.nZoneSvrHardID	= (BYTE)nZoneServerID;
299 			{
300 				char szUnlockReason[1024] = { 0 };
301 				sprintf_s(szUnlockReason, "[跨区]向公共区调用GAMEDB_REQUEST_SETUSERLOCK失败, PDBID=%d", m_pTerminal->GetPDBID());
302 				g_CancelUserSolidLock.CancelSolidLock(m_pTerminal->GetUDBID(), nFromGameWorldID, szUnlockReason);
303 				m_pTerminal->Kickout(EKickoutClient_Reason_StarTrekFailed, "对不起,读取角色数据失败,切换失败.");
339 	if(pNeedInObject == NULL)
340 	{			
341 		ErrorLn("[跨区]向公共区设置永久锁请求返回后, NeedInObject对像已不存在, 前面已验证过. UDBID="<<pMsg->dwUserID);
342 		m_pTerminal->Kickout(EKickoutClient_Reason_StarTrekFailed, "请求异常,请向游戏管理员寻求支持[0xCD9F].");
343 		return;
355 	{
356 		char szUnlockReason[256] = { 0 };
357 		sprintf_s(szUnlockReason, "[跨区]向公共区加永久锁返回标志不对, LockFlag=%d.", pMsg->nLockFlag);
358 		g_CancelUserSolidLock.CancelSolidLock(m_pTerminal->GetUDBID(), nFromGameWorldID, szUnlockReason);
359 		g_CancelUserSolidLock.CancelSolidLock(m_pTerminal->GetUDBID(), getThisGameWorldID(), szUnlockReason);
391 	if(pGateway == NULL)
392 	{
393 		ErrorLn("[跨区] 取网关连接客理器出错.udbid="<<m_pTerminal->GetUDBID());
394 		return false;
395 	}
398 	if(pDBEngine == NULL)
399 	{
400 		ErrorLn("[跨区] 取数据库引擎方法出错.udbid="<<m_pTerminal->GetUDBID());
401 		return false;
402 	}
405 	if(pAccountInfo == NULL)
406 	{
407 		ErrorLn("[跨区] GetUserInfo失败.udbid="<<m_pTerminal->GetUDBID());
408 		return false;
409 	}
413 	if(pNeedInObject == NULL)
414 	{
415 		ErrorLn("[跨区] 取NeedInObject对像已不存在.udbid="<<m_pTerminal->GetUDBID());
416 		return false;
417 	}
448 							 sizeof(reqselectactor), &g_DBRetSinkSelectActorForTrek, nFromGameWorldID))
449 	{
450 		ErrorLn("[跨区]向公共区请求GAMEDB_REQUEST_SELECTACTOR失败,UDBID="<<m_pTerminal->GetUDBID());
451 		return false;
452 	}
478 	if(nLen < sizeof(DBREQ_RESULT_SELECTACTOR) || pDBEngine == NULL || pSchemeCenter == NULL || pStarTrekServer == NULL)
479 	{
480 		ErrorLn("[跨区]读取角色数据返回后, 数据大小非法或者一些接口指针为空, 前面已验证过. UDBID="<<m_pTerminal->GetUDBID());
481 		m_pTerminal->Kickout(EKickoutClient_Reason_StarTrekFailed, "请求异常,请向游戏管理员寻求支持[0x9B9F].");
482 		return;
487 	if(pNeedInObject == NULL)
488 	{
489 		ErrorLn("[跨区]读取角色数据返回后, NeedInObject已不存在, 前面已验证过. UDBID="<<m_pTerminal->GetUDBID());
490 		m_pTerminal->Kickout(EKickoutClient_Reason_StarTrekFailed, "对不起，切换超时失败，请联系游戏管理员.");
491 		return;
496 	if(pMsg->dwActorID != m_pTerminal->GetPDBID() || pMsg->dwUserID != pNeedInObject->GetContext()->UDBID)
497 	{
498 		ErrorLn("[跨区]读取角色数据请求异常, PDBID不一致.pdbid="<<pMsg->dwActorID<<" 源pdbid="<<m_pTerminal->GetPDBID());
499 		m_pTerminal->Kickout(EKickoutClient_Reason_StarTrekFailed, "角色数据校验出错，请联系游戏管理员.");
500 		return;
505 		int nHeadFileSize = sizeof(DBREQ_RESULT_SELECTACTOR) + pMsg->nGoodsQty * sizeof(DBREQ_TABLE_GOODS);
506 		char szUnlockReason[1024] = { 0 };
507 		sprintf_s(szUnlockReason, "[跨区]角色数据校验出错, 数据库读出大小=%d, 头定义文件大小=%d", nLen, nHeadFileSize);
508 		g_CancelUserSolidLock.CancelSolidLock(pMsg->dwUserID, nFromGameWorldID, szUnlockReason);
509 		if(isPublicGameWorld()){
512 		return;
513 	}
514 	TraceLn("[跨区登陆] "<<pMsg->szActorName<<"(pdbid="<<pMsg->dwActorID<<")从数据库内读出"<<pMsg->nGoodsQty<<"个物品.");
516 	//////////////////////////////////////////////////// 找到可进入的地图 //////////////////////////////////////////////////
517 	POINT ptDirectEnterTile = { 0, 0};
566 	{
567 		char szUnlockReason[1024] = { 0 };
568 		sprintf_s(szUnlockReason, "[跨区] 竟然无法找到登陆地图, pdbid=%d", pMsg->dwActorID);
569 		g_CancelUserSolidLock.CancelSolidLock(pMsg->dwUserID, nFromGameWorldID, szUnlockReason);
570 		if(isPublicGameWorld()){
581 		{
582 			char szUnlockReason[1024] = { 0 };
583 			sprintf_s(szUnlockReason, "[跨区]竟然无法找到登陆位置, pdbid=%d", pMsg->dwActorID);
584 			g_CancelUserSolidLock.CancelSolidLock(pMsg->dwUserID, nFromGameWorldID, szUnlockReason);
585 			if(isPublicGameWorld()){
606 	{			
607 		char szUnlockReason[1024] = { 0 };
608 		sprintf_s(szUnlockReason, "[跨区]创建人物实体失败, pdbid=%d", pMsg->dwActorID);
609 		g_CancelUserSolidLock.CancelSolidLock(pMsg->dwUserID, nFromGameWorldID, szUnlockReason);
610 		if(isPublicGameWorld()){
697 	{
698 		char szUnlockReason[1024] = { 0 };
699 		sprintf_s(szUnlockReason, "[跨区]ExportDetailContext导出失败, pdbid=%d", pMsg->dwActorID);
700 		g_CancelUserSolidLock.CancelSolidLock(pMsg->dwUserID, nFromGameWorldID, szUnlockReason);
701 		if(isPublicGameWorld()){
722 	{
723 		char szUnlockReason[1024] = { 0 };
724 		sprintf_s(szUnlockReason, "[跨区]通知客户端创建人物失败, pdbid=%d", pMsg->dwActorID);
725 		g_CancelUserSolidLock.CancelSolidLock(pMsg->dwUserID, nFromGameWorldID, szUnlockReason);
726 		if(isPublicGameWorld()){
796 		pTaskServer->ImportBuffData(PDBID, (LPSTR)pMsg->byIntDatas, sizeof(pMsg->byIntDatas), (LPSTR)pMsg->byByteDatas, sizeof(pMsg->byByteDatas));
797 	}
799 	//////////////////////////////////////////////// 释放跨区迁入对像 ///////////////////////////////////////////////////
800 	pStarTrekServer->ReleaseTreakObject(tStarTrek_MsgDir_In, m_pTerminal->GetUserInfo()->stid, tReleaseTreak_Reason_Succeed, false);
801 }

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\CountryServer\CountryServerAPI.cpp 83 KB CPP 文件 2014/2/25 14:23:49 2018/10/23 19:43:17 2018/10/23 19:43:17 13
424 		}
425 	}
427 	// 公共区取跨区国家名称
428 	if (bLocal)
429 	{
449 	else
450 	{
451 		// 取得跨区桥服务器连接器接口
452 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
453 		if (NULL != pBridgeConnector)
590 		}
591 	}
593 	// 公共区取跨区国家名称
594 	if (bLocal)
595 	{
603 	else
604 	{
605 		// 取得跨区桥服务器连接器接口
606 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
607 		if (NULL != pBridgeConnector)
653 		}
654 	}
656 	// 公共区取跨区国家名称
657 	if (bLocalName)
658 	{
666 	else
667 	{
668 		// 取得跨区桥服务器连接器接口
669 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
670 		if (NULL != pBridgeConnector)
742 		}
743 	}
745 	// 公共区取跨区国家名称
746 	if (bLocal)
747 	{
760 	else
761 	{
762 		// 取得跨区桥服务器连接器接口
763 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
764 		if (NULL != pBridgeConnector)
826 	else
827 	{
828 		// 通过跨区桥服务器连接器接口取得国家群组号
829 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
830 		if (NULL != pBridgeConnector)
906 	else
907 	{
908 		// 通过跨区桥服务器连接器接口取得国家群组号
909 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
910 		if (NULL != pBridgeConnector)
995 	else
996 	{
997 		// 通过跨区桥服务器连接器接口取得国家群组号
998 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
999 		if (NULL != pBridgeConnector)
1095 	else
1096 	{
1097 		// 通过跨区桥服务器连接器接口取得国家群组号
1098 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
1099 		if (NULL != pBridgeConnector)
1197 	else
1198 	{
1199 		// 通过跨区桥服务器连接器接口取得国家群组号
1200 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
1201 		if (NULL != pBridgeConnector)

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\CountryServer\BasePart.cpp 44 KB CPP 文件 2014/2/25 14:23:46 2018/10/23 19:43:16 2018/10/23 19:43:16 2
341 	}
343 	pStrData = pszMsg + sizeof(SMsgCountryBaseAnswerBuildServer_OS) + pMsg->nNameLen + pMsg->nTitleLen + pMsg->nLocalNameLen;
344 	// 取得跨区国家名称
345 	if (pMsg->nWorldNameLen>0 && pMsg->nWorldNameLen<sizeof(m_CountryBaseInfo.szWorldName))
346 	{
375 	// 调式代码
376 	char szBuf[512]={0};
377 	sprintf_s(szBuf,sizeof(szBuf), "CBasePart::OnUpdateSelfInfo() 更新国家基础数据: 国家ID=%d,国家名称=%s,等级=%d,等级名=%s,强大程度=%d,文明点数=%d,金钱=%d,木材=%d,粮草=%d,交易税收=%d,官员俸禄=%d,军队俸禄=%d,功勋兑换=%d,文官上限=%d,将军上限=%d,巡捕上限=%d,诸侯上限=%d,侯相上限=%d,国王ID=%d,本区国家短名称=%s,跨区国家名称=%s,所属数据库游戏世界名称=%s",
378 		m_CountryBaseInfo.dwID,m_CountryBaseInfo.szName,m_CountryBaseInfo.nLevel,m_CountryBaseInfo.szLevelName,
379 		m_CountryBaseInfo.dwPower,m_CountryBaseInfo.dwPiont,m_CountryBaseInfo.dwMoney,m_CountryBaseInfo.dwWood,m_CountryBaseInfo.dwFood,

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\ClanServer\ExternalHelper.cpp 31 KB CPP 文件 2014/2/25 14:23:39 2018/10/23 19:43:14 2018/10/23 19:43:14 2
1223 		}
1224 	}
1226 	// 公共区取跨区国家名称
1227 	if (bLocal)
1228 	{
1241 	else
1242 	{
1243 		// 取得跨区桥服务器连接器接口
1244 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
1245 		if (NULL != pBridgeConnector)

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\ChatServer\ChatSystemCommand.cpp 12 KB CPP 文件 2014/2/25 14:23:35 2018/10/23 19:43:12 2018/10/23 19:43:12 1
205 	else if (StringHelper::casecmpn(cmd, ":move ", 6) == 0) // cmd=":mvoe gm'dbid, player'name"
206 	{
207 		// 取得跨区桥服务器连接器接口
208 		IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
209 		if (pBridgeConnector == NULL)

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\ChatServer\ChatServer.cpp 40 KB CPP 文件 2014/2/25 14:23:34 2018/10/23 19:43:11 2018/10/23 19:43:11 1
1221 }
1223 /**
1224 @name         : 处理其他服务器通过跨区桥服务器转发的消息
1225 @param actionId  : 消息码
1226 @param bridgeHead  : 桥消息头

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Cluster\VoiceServer\GlobalVoiceServer.cpp 183 KB CPP 文件 2014/2/25 14:21:49 2018/10/23 19:42:14 2018/10/23 19:42:14 3
2760 	head->wKeyModule  = MSG_MODULEID_VOICE;
2761 	head->wKeyAction  = MSG_VOICE_SENDDATA;
2763 	// 通过跨区桥服务器中转消息必须加入此消息体
2764 	SMsgVoiceHead * pBhead =(SMsgVoiceHead *)data;
2765 	pBhead->dwWorldID	= server.m_dwWorldID;		// 游戏世界ID
2833 	pHead->wKeyModule  = MSG_MODULEID_VOICE;
2834 	pHead->wKeyAction  = MSG_VOICE_SENDDATA;
2836 	// 通过跨区桥服务器中转消息必须加入此消息体
2837 	SMsgVoiceHead * pBhead =(SMsgVoiceHead*)(pSendData - sizeof(SMsgVoiceHead));
2838 	pBhead->dwWorldID	= server.m_dwWorldID;		// 游戏世界ID
6006 		_T("验证码服务器"),
6007 		_T("Tracker服务器"),
6008 		_T("跨区桥服务器"),
6009 		_T("DB应用服务器"),
6010 		_T("通行证服务器"),

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Cluster\VoiceGateway\GlobalVoiceGateway.cpp 60 KB CPP 文件 2014/2/25 14:21:39 2018/10/23 19:42:06 2018/10/23 19:42:06 3
1558 	//	head->wKeyAction  = MSG_VOICE_SENDDATA;
1559 	//
1560 	//	// 通过跨区桥客户端中转消息必须加入此消息体
1561 	//	SMsgVoiceHead * pBhead =(SMsgVoiceHead *)data;
1562 	//	pBhead->dwWorldID	= client.m_dwWorldID;		// 游戏世界ID
1631 	//	pHead->wKeyAction  = MSG_VOICE_SENDDATA;
1632 	//
1633 	//	// 通过跨区桥客户端中转消息必须加入此消息体
1634 	//	SMsgVoiceHead * pBhead =(SMsgVoiceHead*)(pSendData - sizeof(SMsgVoiceHead));
1635 	//	pBhead->dwWorldID	= client.m_dwWorldID;		// 游戏世界ID
2148 		_T("验证码服务器"),
2149 		_T("Tracker服务器"),
2150 		_T("跨区桥服务器"),
2151 		_T("DB应用服务器"),
2152 		_T("通行证服务器"),

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Cluster\VoiceConnector\VoiceConnector.cpp 42 KB CPP 文件 2014/2/25 14:21:36 2018/10/23 19:42:04 2018/10/23 19:42:04 2
408 	if (moduleId >= 0 && moduleId < MSG_MODULEID_MAXID)
409 	{
410 		// 通过跨区语音服务器中转消息必须加入此消息体
411 		SMsgVoiceHead voiceHead;
412 		// 处理中转数据,把附加数据去掉
426 			if (moduleId >= MSG_MODULEID_MAXID)
427 			{
428 				Error("跨区语音服务器连接器:中转消息moduleId("<<moduleId<<") 超出范围！"<<endl);
429 				return;
430 			}

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Cluster\PassportServer\GlobalPassportServer.cpp 47 KB CPP 文件 2014/2/25 14:21:25 2018/10/23 19:41:48 2018/10/23 19:41:48 3
1006 		_T("验证码服务器"),
1007 		_T("Tracker服务器"),
1008 		_T("跨区桥服务器"),
1009 		_T("DB应用服务器"),
1010 		_T("通行证服务器"),
1213 	head->wKeyModule  = MSG_MODULEID_PASSPORT;
1214 	head->wKeyAction  = MSG_PASSPORT_SENDDATA;
1216 	// 通过跨区桥服务器中转消息必须加入此消息体
1217 	SMsgPassportHead * pBhead =(SMsgPassportHead *)data;
1218 	pBhead->dwWorldID	= server.m_dwWorldID;		// 游戏世界ID
1285 	pHead->wKeyModule  = MSG_MODULEID_PASSPORT;
1286 	pHead->wKeyAction  = MSG_PASSPORT_SENDDATA;
1288 	// 通过跨区桥服务器中转消息必须加入此消息体
1289 	SMsgPassportHead * pBhead =(SMsgPassportHead*)(pSendData - sizeof(SMsgPassportHead));
1290 	pBhead->dwWorldID	= server.m_dwWorldID;		// 游戏世界ID

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Cluster\PassportConnector\PassportConnector.cpp 38 KB CPP 文件 2014/2/25 14:21:24 2018/10/23 19:41:46 2018/10/23 19:41:46 3
408 	if (moduleId >= 0 && moduleId < MSG_MODULEID_MAXID)
409 	{
410 		// 通过跨区通行证服务器中转消息必须加入此消息体
411 		SMsgPassportHead passportHead;
412 		// 处理中转数据,把附加数据去掉
426 			if (moduleId >= MSG_MODULEID_MAXID)
427 			{
428 				Error("跨区通行证服务器连接器:中转消息moduleId("<<moduleId<<") 超出范围！"<<endl);
429 				return;
430 			}
1212 		_T("验证码服务器"),
1213 		_T("Tracker服务器"),
1214 		_T("跨区桥服务器"),
1215 		_T("DB应用服务器"),
1216 		_T("通行证服务器"),

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Cluster\PassportConnector\PassportCommonPart.cpp 3 KB CPP 文件 2014/2/25 14:21:24 2018/10/23 19:41:46 2018/10/23 19:41:46 2
5 ** 日  期:	2010-6-28
6 ** 版  本:	1.0
7 ** 描  述:	通用 跨区桥连接器扩展信息类
8 ** 应  用:  	
10 **************************** 修改记录 ******************************
18 #include "PassportCommonPart.h"
20 /**
21 @name : 跨区桥连接器扩展信息类
22 @brief:
23 */

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Cluster\LoginServer\LoginServerImp.cpp 91 KB CPP 文件 2014/2/25 14:20:54 2018/10/23 19:41:17 2018/10/23 19:41:17 19
44 // 向中心服同步玩家人数定时器时长
45 #define DLOGIN_UPDATEPERSONNUM 30000
47 // 跨区请求数据维护定时器ID
48 #define DLOGIN_TIMER_AREASWITCH 2
48 #define DLOGIN_TIMER_AREASWITCH 2
50 // 跨区请求数据维护定时器时长
51 #define DLOGIN_AREASWITCH 5000
51 #define DLOGIN_AREASWITCH 5000
53 // 跨区请求数据队伍存活时长(秒)
54 #define DLOGIN_AREASWITCHQUEUE_LIVETIME 120
57 // 名称最小数量 需再从数据库中批量读取
219 	}
220 }
224 /// 启动跨区桥服务器连接器
225 void LoginServerImp::CreateBridgeConnector(void)
226 {
225 void LoginServerImp::CreateBridgeConnector(void)
226 {
227 	// 加载跨区桥服务器连接器设定
228 	Ini ini("Bridge.ini");
229 	std::string strBridgeServerIP = ini.getString("Setting","BridgeServerIP","127.0.0.1");
243 	if (nOpenBridge!=1)
244 	{
245 		WarningLn("跨区桥服务器连接禁用!");
246 		return;
247 	}
246 		return;
247 	}
249 	// 跨区桥服务器连接器连接
250 	TraceLn("连接跨区桥服务器:游戏世界ID="<<dwGameWorldID<<":"<<strWorldName.c_str()<<","<<strBridgeServerIP.c_str()<<":"<<nBridgeServerPort);
251 	if(!m_BridgeConnector->Connect(strBridgeServerIP.data(),nBridgeServerPort))
252 	{
251 	if(!m_BridgeConnector->Connect(strBridgeServerIP.data(),nBridgeServerPort))
252 	{
253 		TraceLn("连接跨区桥服务器失败!");
254 		return;
255 	}
254 		return;
255 	}
256 	//TraceLn("连接跨区桥服务器成功!");
258 	// 注册桥服务器消息
259 	m_BridgeConnector->registerMessageHandler(MSG_MODULEID_LOGIN, this);
259 	m_BridgeConnector->registerMessageHandler(MSG_MODULEID_LOGIN, this);
260 }
261 /// 关闭跨区桥服务器连接器
262 void LoginServerImp::ReleaseBridgeConnector(void)
263 {
266 		// 注销桥服务器消息
267 		m_BridgeConnector->unregisterMessageHandler(MSG_MODULEID_LOGIN);
269 		// 关闭跨区桥服务器连接器
270 		TraceLn("关闭跨区桥服务器连接器!");
271 		m_BridgeConnector->Release();
272 		m_BridgeConnector = NULL;
564 			case MG_SoftControl_SetServerUID:	// 设定软件服务器的UID
565 				{
566 					// 连接器连接跨区桥服务器
567 					if (NULL != m_ManagerConnector && m_ManagerConnector->GetWorldID()!=0)
568 					{
570 						if (NULL==m_BridgeConnector)
571 						{
572 							// 启动跨区桥服务器连接器
573 							CreateBridgeConnector();
574 						}
851 	// 关闭通行证服务器连接器
852 	ReleasePassportConnector();
854 	// 关闭跨区桥服务器连接器
855 	ReleaseBridgeConnector();
857 	// 关闭管理连接器
1632 //end add
1634 /**
1635 @name         : 处理其他服务器通过跨区桥服务器转发的消息
1636 @param actionId  : 消息码
1637 @param bridgeHead  : 桥消息头
1781 	m_BridgeConnector->SendDataToServer(pMsg->context.serverID, buf.data(), buf.size());
1782 }
1785 /** 取跨区登陆临时数据
1786 @param   
1787 @param   
1798 	return &(Iter->second);
1799 }
1801 /** 删除跨区登陆临时数据
1802 @param   
1803 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Cluster\LoginServer\ClientState_Queue.cpp 19 KB CPP 文件 2014/2/25 14:20:48 2018/10/23 19:41:14 2018/10/23 19:41:14 2
367 bool ClientState_Queue::GetZoneServerID(CGID &nServerID, int &nMapID, POINT &ptTile)
368 {
369 	// 换区操作时，不随机选择场景服务器，因为有可能随机到的场影服务器上没有跨区数据
370 	STATE_SWITCH_CONTEXT &switchContext = m_pClient->GetSwitchContext();
371 	if (switchContext.stid != 0)
419 		return true;
420 	}
422 	// 在非跨区登陆时，如果找不到指定的地图，就在青龙城与云中界随机一个与国家对应的地图
423 	{
424 		DWORD dwLevel = switchContext.actorInfo.dwLevel;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Cluster\LoginServer\ClientState_Login.cpp 73 KB CPP 文件 2014/2/25 14:20:47 2018/10/23 19:41:14 2018/10/23 19:41:14 3
733 		}
734 	}
736 	// 六国登陆 取得跨区桥服务器连接器接口
737 	if(SendCountryInfo(std::string(data.szEnterWorldName)) == false)
738 	{
1005 	}
1006 }
1009 /** 处理用户跨区登陆请求
1010 @param   
1011 @param   
1335 		}
1336 #endif
1338 		// 六国登陆 取得跨区桥服务器连接器接口
1339 		if(SendCountryInfo(std::string(pMsg->szEnterWorldName)) == false)
1340 		{

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Cluster\LoginServer\ClientState_Game.cpp 20 KB CPP 文件 2014/2/25 14:20:46 2018/10/23 19:41:14 2018/10/23 19:41:14 1
207 	//// 是否检查锁
208 	//switchContext.bCheckLock = false;
209 	//// 跨区时的STID
210 	//switchContext.stid = 0;
212 	//switchContext.dwOtherFlag=1;								

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Cluster\LoginServer\ClientState_AreaSwitch.cpp 13 KB CPP 文件 2014/2/25 14:20:45 2018/10/23 19:41:14 2018/10/23 19:41:14 6
130 	GameDatabaseAccessor::getInstance().RemoveDBRetSink(this);
131 }
134 /** 处理用户跨区登陆请求
135 @param   
136 @param   
147 	m_bDBRequester = GameDatabaseAccessor::getInstance().ExecuteSP(GAMEDB_REQUEST_QUERYUSERLOGIN,rand(),(LPCSTR)&userLogin,sizeof(userLogin),this, switchContext.dwGameWorldID);
148 }
150 /** 处理用户跨区登陆请求 数据库返回
151 @param   
152 @param   
196 	HandleUserSwitchAreaQueryActorInfo(result->dwPDBID);	
197 }
200 // 处理用户跨区选角色请求
201 void ClientState_AreaSwitch::HandleUserSwitchAreaQueryActorInfo(DWORD dwPDBID)
202 {
208 	m_bDBRequester = GameDatabaseAccessor::getInstance().ExecuteSP(GAMEDB_REQUEST_QUERYACTORLOGIN, rand(), (LPCSTR)&data, sizeof(data), this, switchContext.dwGameWorldID);
209 }
211 // 处理用户跨区选角色请求 数据库返回
212 void ClientState_AreaSwitch::HandleDBResult_SwitchAreaQueryActorInfo(DBREQ_RESULT_QUERYACTORLOGIN * result,DWORD dwResultLen)
213 {
232 	m_pClient->GotoState(CLIENT_CONN_STATE_QUEUE,(const char *)&switchContext,sizeof(switchContext));
233 }
235 // 处理用户跨区登陆请求(在区库中查询)
236 void ClientState_AreaSwitch::HandleUserSwitchAreaQueryUserAreaInfo(LPCSTR pData, int nLen)
237 {
321 	m_bDBRequester = GameDatabaseAccessor::getInstance().ExecuteSP(GAMEDB_REQUEST_QUERYUSERLOGINAREA,rand(),(LPCSTR)&userLogin,sizeof(userLogin),this, switchContext.dwGameWorldID);
322 }
324 // 处理用户跨区登陆请求 数据库返回
325 void ClientState_AreaSwitch::HandleDBResult_SwitchAreaQueryUserAreaInfo(DBREQ_RESULT_QUERYUSERLOGINAREA * result,DWORD dwResultLen)
326 {

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Cluster\LoginServer2\LoginServerImp.cpp 91 KB CPP 文件 2014/2/25 14:21:14 2018/10/23 19:41:33 2018/10/23 19:41:33 19
44 // 向中心服同步玩家人数定时器时长
45 #define DLOGIN_UPDATEPERSONNUM 30000
47 // 跨区请求数据维护定时器ID
48 #define DLOGIN_TIMER_AREASWITCH 2
48 #define DLOGIN_TIMER_AREASWITCH 2
50 // 跨区请求数据维护定时器时长
51 #define DLOGIN_AREASWITCH 5000
51 #define DLOGIN_AREASWITCH 5000
53 // 跨区请求数据队伍存活时长(秒)
54 #define DLOGIN_AREASWITCHQUEUE_LIVETIME 120
57 // 名称最小数量 需再从数据库中批量读取
219 	}
220 }
224 /// 启动跨区桥服务器连接器
225 void LoginServerImp::CreateBridgeConnector(void)
226 {
225 void LoginServerImp::CreateBridgeConnector(void)
226 {
227 	// 加载跨区桥服务器连接器设定
228 	Ini ini("Bridge.ini");
229 	std::string strBridgeServerIP = ini.getString("Setting","BridgeServerIP","127.0.0.1");
243 	if (nOpenBridge!=1)
244 	{
245 		WarningLn("跨区桥服务器连接禁用!");
246 		return;
247 	}
246 		return;
247 	}
249 	// 跨区桥服务器连接器连接
250 	TraceLn("连接跨区桥服务器:游戏世界ID="<<dwGameWorldID<<":"<<strWorldName.c_str()<<","<<strBridgeServerIP.c_str()<<":"<<nBridgeServerPort);
251 	if(!m_BridgeConnector->Connect(strBridgeServerIP.data(),nBridgeServerPort))
252 	{
251 	if(!m_BridgeConnector->Connect(strBridgeServerIP.data(),nBridgeServerPort))
252 	{
253 		TraceLn("连接跨区桥服务器失败!");
254 		return;
255 	}
254 		return;
255 	}
256 	//TraceLn("连接跨区桥服务器成功!");
258 	// 注册桥服务器消息
259 	m_BridgeConnector->registerMessageHandler(MSG_MODULEID_LOGIN, this);
259 	m_BridgeConnector->registerMessageHandler(MSG_MODULEID_LOGIN, this);
260 }
261 /// 关闭跨区桥服务器连接器
262 void LoginServerImp::ReleaseBridgeConnector(void)
263 {
266 		// 注销桥服务器消息
267 		m_BridgeConnector->unregisterMessageHandler(MSG_MODULEID_LOGIN);
269 		// 关闭跨区桥服务器连接器
270 		TraceLn("关闭跨区桥服务器连接器!");
271 		m_BridgeConnector->Release();
272 		m_BridgeConnector = NULL;
564 			case MG_SoftControl_SetServerUID:	// 设定软件服务器的UID
565 				{
566 					// 连接器连接跨区桥服务器
567 					if (NULL != m_ManagerConnector && m_ManagerConnector->GetWorldID()!=0)
568 					{
570 						if (NULL==m_BridgeConnector)
571 						{
572 							// 启动跨区桥服务器连接器
573 							CreateBridgeConnector();
574 						}
851 	// 关闭通行证服务器连接器
852 	ReleasePassportConnector();
854 	// 关闭跨区桥服务器连接器
855 	ReleaseBridgeConnector();
857 	// 关闭管理连接器
1632 //end add
1634 /**
1635 @name         : 处理其他服务器通过跨区桥服务器转发的消息
1636 @param actionId  : 消息码
1637 @param bridgeHead  : 桥消息头
1781 	m_BridgeConnector->SendDataToServer(pMsg->context.serverID, buf.data(), buf.size());
1782 }
1785 /** 取跨区登陆临时数据
1786 @param   
1787 @param   
1798 	return &(Iter->second);
1799 }
1801 /** 删除跨区登陆临时数据
1802 @param   
1803 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Cluster\LoginServer2\ClientState_Queue.cpp 19 KB CPP 文件 2014/2/25 14:21:07 2018/10/23 19:41:28 2018/10/23 19:41:28 2
367 bool ClientState_Queue::GetZoneServerID(CGID &nServerID, int &nMapID, POINT &ptTile)
368 {
369 	// 换区操作时，不随机选择场景服务器，因为有可能随机到的场影服务器上没有跨区数据
370 	STATE_SWITCH_CONTEXT &switchContext = m_pClient->GetSwitchContext();
371 	if (switchContext.stid != 0)
419 		return true;
420 	}
422 	// 在非跨区登陆时，如果找不到指定的地图，就在青龙城与云中界随机一个与国家对应的地图
423 	{
424 		DWORD dwLevel = switchContext.actorInfo.dwLevel;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Cluster\LoginServer2\ClientState_Login.cpp 78 KB CPP 文件 2014/2/25 14:21:06 2018/10/23 19:41:28 2018/10/23 19:41:28 3
738 		}
739 	}
741 	// 六国登陆 取得跨区桥服务器连接器接口
742 	if(SendCountryInfo(std::string(data.szEnterWorldName)) == false)
743 	{
1011 	}
1012 }
1015 /** 处理用户跨区登陆请求
1016 @param   
1017 @param   
1341 		}
1342 #endif
1344 		// 六国登陆 取得跨区桥服务器连接器接口
1345 		if(SendCountryInfo(std::string(pMsg->szEnterWorldName)) == false)
1346 		{

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Cluster\LoginServer2\ClientState_Game.cpp 20 KB CPP 文件 2014/2/25 14:21:04 2018/10/23 19:41:27 2018/10/23 19:41:27 1
207 	//// 是否检查锁
208 	//switchContext.bCheckLock = false;
209 	//// 跨区时的STID
210 	//switchContext.stid = 0;
212 	//switchContext.dwOtherFlag=1;								

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Cluster\LoginServer2\ClientState_AreaSwitch.cpp 13 KB CPP 文件 2014/2/25 14:21:04 2018/10/23 19:41:27 2018/10/23 19:41:27 6
130 	GameDatabaseAccessor::getInstance().RemoveDBRetSink(this);
131 }
134 /** 处理用户跨区登陆请求
135 @param   
136 @param   
147 	m_bDBRequester = GameDatabaseAccessor::getInstance().ExecuteSP(GAMEDB_REQUEST_QUERYUSERLOGIN,rand(),(LPCSTR)&userLogin,sizeof(userLogin),this, switchContext.dwGameWorldID);
148 }
150 /** 处理用户跨区登陆请求 数据库返回
151 @param   
152 @param   
196 	HandleUserSwitchAreaQueryActorInfo(result->dwPDBID);	
197 }
200 // 处理用户跨区选角色请求
201 void ClientState_AreaSwitch::HandleUserSwitchAreaQueryActorInfo(DWORD dwPDBID)
202 {
208 	m_bDBRequester = GameDatabaseAccessor::getInstance().ExecuteSP(GAMEDB_REQUEST_QUERYACTORLOGIN, rand(), (LPCSTR)&data, sizeof(data), this, switchContext.dwGameWorldID);
209 }
211 // 处理用户跨区选角色请求 数据库返回
212 void ClientState_AreaSwitch::HandleDBResult_SwitchAreaQueryActorInfo(DBREQ_RESULT_QUERYACTORLOGIN * result,DWORD dwResultLen)
213 {
232 	m_pClient->GotoState(CLIENT_CONN_STATE_QUEUE,(const char *)&switchContext,sizeof(switchContext));
233 }
235 // 处理用户跨区登陆请求(在区库中查询)
236 void ClientState_AreaSwitch::HandleUserSwitchAreaQueryUserAreaInfo(LPCSTR pData, int nLen)
237 {
321 	m_bDBRequester = GameDatabaseAccessor::getInstance().ExecuteSP(GAMEDB_REQUEST_QUERYUSERLOGINAREA,rand(),(LPCSTR)&userLogin,sizeof(userLogin),this, switchContext.dwGameWorldID);
322 }
324 // 处理用户跨区登陆请求 数据库返回
325 void ClientState_AreaSwitch::HandleDBResult_SwitchAreaQueryUserAreaInfo(DBREQ_RESULT_QUERYUSERLOGINAREA * result,DWORD dwResultLen)
326 {

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Cluster\Include\BridgeFun.cpp 7 KB CPP 文件 2014/2/25 14:20:40 2018/10/23 19:41:12 2018/10/23 19:41:12 2
5 ** 日  期:	2010-6-25
6 ** 版  本:	1.0
7 ** 描  述:	跨区桥服务器共用函数
8 ** 应  用:  	
10 **************************** 修改记录 ******************************
188 		_T("验证码服务器"),
189 		_T("Tracker服务器"),
190 		_T("跨区桥服务器"),
191 		_T("DB应用服务器"),
192 		_T("通行证服务器"),

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Cluster\BridgeServer\ServerUser.cpp 7 KB CPP 文件 2014/2/25 14:22:01 2018/10/23 19:40:55 2018/10/23 19:40:55 1
5 ** 日  期:	2010-6-24
6 ** 版  本:	1.0
7 ** 描  述:	跨区桥服务器用户
8 ** 应  用:  	
10 **************************** 修改记录 ******************************

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Cluster\BridgeServer\ServerList.cpp 2 KB CPP 文件 2014/2/25 14:22:01 2018/10/23 19:40:55 2018/10/23 19:40:55 1
5 ** 日  期:	2010-6-24
6 ** 版  本:	1.0
7 ** 描  述:	跨区桥服务器用户列表
8 ** 应  用:  		
10 **************************** 修改记录 ******************************

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Cluster\BridgeServer\ListInfoDlg.cpp 8 KB CPP 文件 2014/2/25 14:22:00 2018/10/23 19:40:54 2018/10/23 19:40:54 1
162 	CBridgeServerDlg * pServerDlg =(CBridgeServerDlg *) AfxGetApp()->m_pMainWnd;
164 	CListCtrl& ListCtrl = m_InfoList;
166 	GlobalBridgeServer& mainServer = pServerDlg->m_BridgeServer;	//跨区桥服务器服务
168 	char szBuf[256]={0};
170 	// 防止闪

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Cluster\BridgeServer\GlobalBridgeServer.cpp 42 KB CPP 文件 2014/2/25 14:22:00 2018/10/23 19:40:53 2018/10/23 19:40:53 10
5 ** 日  期:	2010-6-24
6 ** 版  本:	1.0
7 ** 描  述:	跨区桥服务器
8 ** 应  用:  	
10 **************************** 修改记录 ******************************
84 	TraceLn("连接子服务器管理器:"<<strManagerServerIP.data()<<":"<<nManagerServerPort);
85 	m_ManagerConnector = CreateManagerConnectorProc(this,&m_TimerAxis);
86 	m_ManagerConnector->Create(MSG_MG_ENDPOINT_BRIDGE,0,_NGT"跨区桥服务器");
87 	if(!m_ManagerConnector->Connect(strManagerServerIP.data(),nManagerServerPort))
88 	{
327 			if(Create(wServerListenPort))
328 			{
329 				Trace("启动跨区桥服务器 OK ！"<<endl);
330 			}
331 			else
331 			else
332 			{
333 				Error("启动跨区桥服务器 失败！"<<endl);
334 			}
335 		}
339 			if(Close())
340 			{
341 				Trace("停止跨区桥服务器 OK ！"<<endl);
342 			}
343 			else
343 			else
344 			{
345 				Error("停止跨区桥服务器 失败！"<<endl);
346 			}
347 		}
351 			if(Close())
352 			{
353 				Trace("停止跨区桥服务器 OK ！"<<endl);
354 			}
355 			else
355 			else
356 			{
357 				Error("停止跨区桥服务器 失败！"<<endl);
358 			}
359 			// 通知服务器关闭
1023 	head->wKeyModule  = MSG_MODULEID_BRIDGE;
1024 	head->wKeyAction  = MSG_BRIDGE_SENDDATA;
1026 	// 通过跨区桥服务器中转消息必须加入此消息体
1027 	SMsgBridgeHead * pBhead =(SMsgBridgeHead *)data;
1028 	pBhead->dwWorldID	= server.m_dwWorldID;		// 游戏世界ID
1095 	pHead->wKeyModule  = MSG_MODULEID_BRIDGE;
1096 	pHead->wKeyAction  = MSG_BRIDGE_SENDDATA;
1098 	// 通过跨区桥服务器中转消息必须加入此消息体
1099 	SMsgBridgeHead * pBhead =(SMsgBridgeHead*)(pSendData - sizeof(SMsgBridgeHead));
1100 	pBhead->dwWorldID	= server.m_dwWorldID;		// 游戏世界ID

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Cluster\BridgeServer\BridgeServerDlg.cpp 18 KB CPP 文件 2014/2/25 14:21:59 2018/10/23 19:40:53 2018/10/23 19:40:53 6
5 ** 日  期:	2010-6-24
6 ** 版  本:	1.0
7 ** 描  述:	跨区桥服务器主程序界面
8 ** 应  用:  	
9 	
427 	if (m_BridgeServer.IsStart())
428 	{
429 		CString strAlert="跨区桥服务器正在运行中，你确定要停止服务并退出程序吗？";
430 		if(MessageBox(strAlert,"操作确认",MB_YESNO|MB_ICONQUESTION)!=IDYES) 
431 		{
432 			return;
433 		}
435 		Trace("停止跨区桥服务器 ..."<<endl);
437 		// 关闭程序,停止服务后要关闭进程
438 		m_BridgeServer.SetControlCode(BS_ControlCode_ShutDown);
477 	//更新修改的中心服务器ＩＰ,端口到m_BridgeServer.m_strCenterServerIP,m_BridgeServer.m_nPort
478 	UpdateCenterServerConfig();
480 	Trace("启动跨区桥服务器 ..."<<endl);
482 	// 启动服务
483 	m_BridgeServer.SetControlCode(BS_ControlCode_StartService);
513 		return false;
514 	}
516 	CString strAlert="跨区桥服务器正在运行中，你确定要停止服务并退出程序吗？";
517 	if(MessageBox(strAlert,"操作确认",MB_YESNO|MB_ICONQUESTION)!=IDYES) 
518 	{
519 		return false;
520 	}
522 	Trace("停止跨区桥服务器 ..."<<endl);
524 	// 停止服务
525 	m_BridgeServer.SetControlCode(BS_ControlCode_StopService);

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Cluster\BridgeServer\BridgeServer.cpp 4 KB CPP 文件 2014/2/25 14:21:58 2018/10/23 19:40:53 2018/10/23 19:40:53 4
5 ** 日  期:	2010-6-24
6 ** 版  本:	1.0
7 ** 描  述:	跨区桥服务器主程序
8 ** 应  用:  	
9 	
69 	if(GetLastError()==ERROR_ALREADY_EXISTS)	
70 	{
71 		//::MessageBox(NULL,"跨区桥服务器已经在运行!","跨区桥服务器",MB_ICONINFORMATION);
72 		//AfxMessageBox("跨区桥服务器已经在运行!",MB_ICONINFORMATION);	
73 		return FALSE;
74 	}

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Cluster\BridgeConnector\ServerCapabilityTest.cpp 11 KB CPP 文件 2014/2/25 14:21:58 2018/10/23 19:40:52 2018/10/23 19:40:52 1
138 		nCheckInterval = 5;	
139 	}
141 	EmphasisLn("=============== 启动跨区服务器性能测试 间隔时长为" << nCheckInterval << "秒 ===============");
142 	pTimerAxis->SetTimer(DTIMER_ID_TESTSTART, 1, this);
144 	pTimerAxis->SetTimer(DTIMER_ID_SERVERCHECK, nCheckInterval*1000, this);

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Cluster\BridgeConnector\BridgeZonePart.cpp 9 KB CPP 文件 2014/2/25 14:21:57 2018/10/23 19:40:52 2018/10/23 19:40:52 3
5 ** 日  期:	2010-6-28
6 ** 版  本:	1.0
7 ** 描  述:	场景服 跨区桥连接器扩展信息类
8 ** 应  用:  	
10 **************************** 修改记录 ******************************
17 #include "BridgeZonePart.h"
20 /**
21 @name : 场景服 跨区桥连接器扩展信息类
22 @brief:
23 */
297 	default:
298 		{
299 			ErrorLn("尚有一个跨区桥服务器扩展信息消息未处理，dwMsgCode = "<<dwMsgCode);
300 		}
301 	}

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Cluster\BridgeConnector\BridgeSocialPart.cpp 9 KB CPP 文件 2014/2/25 14:21:57 2018/10/23 19:40:52 2018/10/23 19:40:52 5
5 ** 日  期:	2010-6-28
6 ** 版  本:	1.0
7 ** 描  述:	社会服 跨区桥连接器扩展信息类
8 ** 应  用:  	
10 **************************** 修改记录 ******************************
17 #include "BridgeSocialPart.h"
19 /**
20 @name : 社会服 跨区桥连接器扩展信息类
21 @brief:
22 */
181 #ifdef BRIDGE_PRINT_DEBUG_INF
182 				// 调式代码
183 				sprintf_s(szBuf, _countof(szBuf),_NGT"更新全部国家信息:国家ID=%d,发展等级=%d,强大程度=%d,文明点数=%d,金钱=%d,木材=%d,粮草=%d,攻击=%d,防御=%d,赢次数=%d,国王=%d,世界文明等级=%d,世界文明点数=%d,所属数据库游戏世界ID=%d,群组号=%d,国家基础数据标识=%d,本区国家名称=%s,跨区国家名称=%s",
184 					node.dwID,node.nLevel,node.dwPower,node.dwPiont,node.dwMoney,node.dwWood,node.dwFood,
185 					node.dwWorldAttack,node.dwWorldDefend,node.dwLastWinTimes,node.dwKingPlayerID,node.dwCivilGrade,node.dwCivilDot,node.dwDBWorldID,node.dwGroupID,node.dwFlag,node.szName,node.szWorldName);
218 #ifdef BRIDGE_PRINT_DEBUG_INF
219 			// 调式代码
220 			sprintf_s(szBuf, _countof(szBuf),_NGT"更新国家信息:国家ID=%d,发展等级=%d,强大程度=%d,文明点数=%d,金钱=%d,木材=%d,粮草=%d,攻击=%d,防御=%d,赢次数=%d,国王=%d,世界文明等级=%d,世界文明点数=%d,所属数据库游戏世界ID=%d,群组号=%d,国家基础数据标识=%d,本区国家名称=%s,跨区国家名称=%s",
221 				node.dwID,node.nLevel,node.dwPower,node.dwPiont,node.dwMoney,node.dwWood,node.dwFood,
222 				node.dwWorldAttack,node.dwWorldDefend,node.dwLastWinTimes,node.dwKingPlayerID,node.dwCivilGrade,node.dwCivilDot,node.dwDBWorldID,node.dwGroupID,node.dwFlag,node.szName,node.szWorldName);
249 	default:
250 		{
251 			ErrorLn("尚有一个跨区桥服务器扩展信息消息未处理，dwMsgCode = "<<dwMsgCode);
252 		}
253 	}

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Cluster\BridgeConnector\BridgeConnector.cpp 49 KB CPP 文件 2014/2/25 14:21:56 2018/10/23 19:40:52 2018/10/23 19:40:52 30
5 ** 日  期:	2009/8/25
6 ** 版  本:	1.0
7 ** 描  述:	跨区桥服务器连接器
8 ** 应  用:  	
10 **************************** 修改记录 ******************************
58 	if (NULL!=g_hBridgeConnector)
59 	{
60 		ErrorLn("跨区桥服务器连接器被重复创建，会导致服务器管理功能出问题，请检查相关代码并修正！");
61 	}
62 	g_hBridgeConnector = this;
213 	return m_dwPublicWorldID;	// 公共游戏世界ID
214 }
217 // 发给跨区桥服务器数据
218 void  BridgeConnector::SendData(const char * pData,DWORD dwLen)
219 {
270 {
271 	Close();
272 	WarningLn("主动重连 跨区桥服务器 " << m_szRemoteIP.c_str() <<":" << m_wRemotePort);
274 	return Connect(m_szRemoteIP.c_str(),m_wRemotePort);
275 }
296 						Close();
297 						m_pTimerAxis->SetTimer(ETimerEventID_ReconnectNet,BRIDGE_RECONNECT_INTERVAL,this,1);
299 						WarningLn("与跨区桥服务器连接超过"<<BRIDGE_KEEPALIVE_MAXTIMEOUT<<"毫秒没有心跳,重连跨区桥服务器：  " << m_szRemoteIP.c_str() <<":" << m_wRemotePort);
300 					}
301 				}
348 	if (NULL==handler || wEventID>=EVENT_BRIDGE_MAXID)
349 	{
350 		Error("注册跨区桥服务器连接器事件处理者无效,wEventID="<<wEventID<<" "<<endl);
351 		return false;
352 	}
364 	if (NULL==handler|| wEventID>=EVENT_BRIDGE_MAXID)
365 	{
366 		Error("注销跨区桥服务器连接器事件处理者无效,wEventID="<<wEventID<<" "<<endl);
367 		return false;
368 	}
380 	if (wEventID>=EVENT_BRIDGE_MAXID)
381 	{
382 		Error("触发跨区桥服务器连接器事件ID无效,wEventID="<<wEventID<<" "<<endl);
383 		return false;
384 	}
406 		if (m_MsgHandlers[moduleId] != NULL)
407 		{
408 			Warning("跨区桥服务器连接器 moduleId("<<moduleId<<") already registered"<<endl);
409 		}
410 		m_MsgHandlers[moduleId] = handler;
413 	else
414 	{
415 		Error("跨区桥服务器连接器 moduleId("<<moduleId<<") range error"<<endl);
416 		return false;
417 	}
427 	{
428 		if (m_MsgHandlers[moduleId] == NULL)
429 			Warning("跨区桥服务器连接器 moduleId("<<moduleId<<") already unregistered"<<endl);
430 		m_MsgHandlers[moduleId] = 0;
431 		return true;
433 	else
434 	{
435 		Error("跨区桥服务器连接器 moduleId("<<moduleId<<") range error"<<endl);
436 		return false;
437 	}
450 	if (moduleId >= 0 && moduleId < MSG_MODULEID_MAXID)
451 	{
452 		// 通过跨区桥服务器中转消息必须加入此消息体
453 		SMsgBridgeHead bridgeHead;
454 		// 处理中转数据,把附加数据去掉
468 			if (moduleId >= MSG_MODULEID_MAXID)
469 			{
470 				Error("跨区桥服务器连接器:中转消息moduleId("<<moduleId<<") 超出范围！"<<endl);
471 				return;
472 			}
497 			{
498 				dwLastAlertTimes = dwNowTimes;
499 				Error("跨区桥服务器连接器 moduleId("<<moduleId<<") Handler not registered"<<endl);
500 			}
501 		}
504 	else
505 	{
506 		Error("跨区桥服务器连接器:消息moduleId("<<moduleId<<") 超出范围！"<<endl);
507 	}
508 }
550 	if (m_bIsConnected==false || m_pConnection==0 || m_ID==0)
551 	{
552 		WarningLn("桥服务器连接器还没有连上跨区桥服务器，请求设定服务器状态失败!");
553 		return false;
554 	}
553 		return false;
554 	}
556 	WarningLn("向跨区桥服务器设定服务器状态["<<dwStateFlag);
558 	return true;
559 }
563 {
564 	ostrstream buffer;
565 	buffer << " 跨区桥服务器[" << m_szRemoteIP <<":" << m_wRemotePort <<"][ID=" << m_ID << ",dwWorldID="<<m_dwWorldID<<",ServerType="<<m_wServerType<<",SubID="<<m_wSubID<<":"<<m_szName<<"]" << std::ends;
566 	return buffer.str();
567 }
566 	return buffer.str();
567 }
569 // 跨区桥服务器连接器接口
570 IBridgeConnector* GetGlobalBridgeConnector()
571 {
664 	}
666 }
669 // 发服务器扩展信息消息 dwServerID:服务器ID 为0时广播给所有桥服务器连接器,跨区桥服务器连接器同步服务器扩展信息专用
670 bool BridgeConnector::SendExtDataToServer(DWORD dwServerID,DWORD dwMsgCode,DWORD dwUserData1,DWORD dwUserData2,DWORD dwUserData3,const char * pData,DWORD dwLen)
671 {
990 	m_mapPartList.clear();
992 }
994 ///////////////////////// IBridgeMessageHandler 处理跨区桥服务器发过来的消息 /////////////////////////
995 void BridgeConnector::HandleBridgeMessage(ulong actionId, SMsgBridgeHead &bridgeHead, SGameMsgHead* head, LPSTR data, size_t len)
996 {
1041 	default:
1042 		{
1043 			ErrorLn("尚有一个跨区桥服务器发过来的消息未处理，actionId = "<<actionId);
1044 		}
1045 	}
1045 	}
1046 }
1049 ///////////////////////// 处理跨区桥服务器发过来的消息 /////////////////////////
1051 // 中转消息
1052 void BridgeConnector::OnMsgTransitData(unsigned long actionId,SMsgBridgeHead &bridgeHead, SGameMsgHead* head, LPSTR data, size_t len)
1054 	if(data==NULL|| len < sizeof(SMsgBridgeTransitData))
1055 	{
1056 		ErrorLn("跨区桥服务器中转消息数据大小非法!");
1057 		return;
1058 	}
1064 	if (0==pMsg->dwServerID || 0==new_len || pMsg->dwDataLens!=new_len)
1065 	{
1066 		ErrorLn("跨区桥服务器中转消息数据大小校验非法!");
1067 		return;
1068 	}
1076 	if( len != sizeof(SMsgBridgeHandshakeResponse))
1077 	{
1078 		ErrorLn("跨区桥服务器回应握手消息数据大小非法!");
1079 		return;
1080 	}
1084 	m_ID = pMsg->dwID;
1085 	m_dwPublicWorldID = pMsg->dwPublicWorldID;
1087 	TraceLn("与跨区桥服务器握手成功! ID="<<m_ID<<",公共游戏世界ID="<<m_dwPublicWorldID);
1089 	// 设置公共区游戏世界ID
1090 	setPublicGameWorldID((int)m_dwPublicWorldID);
1089 	// 设置公共区游戏世界ID
1090 	setPublicGameWorldID((int)m_dwPublicWorldID);
1092 	// 触发与跨区桥服务器握手成功事件
1093 	SEventBridgeHandshake evenData;
1094 	evenData.dwServerID = m_ID;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Cluster\BridgeConnector\BridgCommonPart.cpp 3 KB CPP 文件 2014/2/25 14:21:56 2018/10/23 19:40:51 2018/10/23 19:40:51 2
5 ** 日  期:	2010-6-28
6 ** 版  本:	1.0
7 ** 描  述:	通用 跨区桥连接器扩展信息类
8 ** 应  用:  	
10 **************************** 修改记录 ******************************
18 #include "BridgCommonPart.h"
20 /**
21 @name : 社会服 跨区桥连接器扩展信息类
22 @brief:
23 */

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcClient\Client\MatchClient\WarClient.cpp 8 KB CPP 文件 2014/2/25 13:44:54 2018/10/23 19:34:25 2018/10/23 19:34:25 2
5 ** 日  期:	2011-03-19
6 ** 版  本:	1.0
7 ** 描  述:	跨区战场
8 ** 应  用:  	
9 	
278 	default:
279 		{
280 			ErrorLn("跨区战场客户端系统有一个服务器战场信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
281 		}
282 		break;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcClient\Client\MatchClient\War.cpp 16 KB CPP 文件 2014/2/25 13:44:54 2018/10/23 19:34:25 2018/10/23 19:34:25 1
5 ** 日  期:	2011-03-19
6 ** 版  本:	1.0
7 ** 描  述:	跨区战场
8 ** 应  用:  	
9 	

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcClient\Client\MatchClient\StrikeClient.cpp 54 KB CPP 文件 2014/2/25 13:44:53 2018/10/23 19:34:25 2018/10/23 19:34:25 2
5 ** 日  期:	2010-10-29
6 ** 版  本:	1.0
7 ** 描  述:	跨区竞技
8 ** 应  用:  	
9 	
1707 	default:
1708 		{
1709 			ErrorLn("跨区竞技客户端系统有一个服务器竞技信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
1710 		}
1711 		break;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcClient\Client\MatchClient\MatchClient.cpp 135 KB CPP 文件 2014/2/25 13:44:51 2018/10/23 19:34:25 2018/10/23 19:34:25 13
85 		return false;
86 	}
88 	// 创建跨区副本助手
89 	if (m_EctypeAssist.Create() == false)
90 	{
96 		return false;
97 	}
98 	// 创建跨区竞技客户端系统
99 	if (m_StrikeClient.Create() == false)
100 	{
101 		return false;
102 	}
103 	// 创建跨区战争客户端系统
104 	if (m_WarClient.Create() == false)
105 	{
157 	// 关闭挑战假人系统客户端系统
158 	m_DummyClient.Release();
160 	// 关闭跨区战争客户端系统
161 	m_WarClient.Release();
161 	m_WarClient.Release();
163 	// 关闭跨区竞技客户端系统
164 	m_StrikeClient.Release();
166 	// 关闭服竞技撮合系统客户端
166 	// 关闭服竞技撮合系统客户端
167 	m_StrikeMatch.Release();
169 	// 关闭跨区副本助手
170 	m_EctypeAssist.Close();
172 	delete this;
172 	delete this;
173 }
175 /** 创建跨区助手部件
176 */
177 IEctypeAssistPart* CMatchClient::CreateEctypeAssistPart()
194 	return &m_StrikeMatch;
195 }
197 /** 取得跨区竞技系统接口
198 */
199 IStrikeClient* CMatchClient::GetStrikeClient()
201 	return &m_StrikeClient;
202 }
203 /** 取得跨区战场客户端系统接口定义
204 */
205 IWarClient* CMatchClient::GetWarClient()
220 }
222 //////////////////////////////////////////////////////////////////////////
224 // 取得跨区副本助手
225 CEctypeAssist& CMatchClient::GetCEctypeAssistInstance()
226 {
233 	return m_StrikeMatch;
234 }
235 // 取得跨区竞技系统
236 CStrikeClient& CMatchClient::GetStrikeClientInstance()
237 {
238 	return m_StrikeClient;
239 }
240 // 取得跨区战场客户端系统接口定义
241 CWarClient& CMatchClient::GetWarClientInstance()
242 {
3486 		}
3487 		break;
3488 	case MSG_MATCH_KQE:				//  跨区副本助手子消息
3489 		{
3490 			m_EctypeAssist.OnMessage(head, data, len);

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcClient\Client\MatchClient\EctypeAssistPart.cpp 6 KB CPP 文件 2014/2/25 13:44:49 2018/10/23 19:34:25 2018/10/23 19:34:25 2
5 ** 日  期:	2010-7-15
6 ** 版  本:	1.0
7 ** 描  述:	跨区副本助手部件
8 ** 应  用:  	
9 ********************************************************************/
102 	if (nLen != sizeof(SKqEctypePartContext) + sizeof(BYTE)+sizeof(SDummyDBInfo))
103 	{
104 		ErrorLn("[跨区副本部件 现场长度不对]");
105 		return false;
106 	}

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcClient\Client\MatchClient\EctypeAssist.cpp 2 KB CPP 文件 2014/2/25 13:44:49 2018/10/23 19:34:25 2018/10/23 19:34:25 1
5 ** 日  期:	2010-7-15
6 ** 版  本:	1.0
7 ** 描  述:	跨区副本助手
8 ** 应  用:  	
9 ********************************************************************/

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcClient\Client\MatchClient\CountryWar.cpp 13 KB CPP 文件 2014/2/25 13:44:48 2018/10/23 19:34:25 2018/10/23 19:34:25 2
5 ** 日  期:	2011-03-31
6 ** 版  本:	1.0
7 ** 描  述:	跨区国战
8 ** 应  用:  	
9 	
543 		{
544 			bHasDone = true;
546 			ErrorLn("跨区国战战场客户端系统有一个服务器战场信息子消息未处理，dwMsgCode = "<< dwMsgCode);
547 		}
548 		break;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcClient\Client\MarryClient\TeachStudClient.cpp 33 KB CPP 文件 2014/2/25 13:44:45 2018/10/23 19:34:25 2018/10/23 19:34:25 2
350 	for (Iter=m_funcMap.begin(); Iter!=m_funcMap.end(); Iter++)
351 	{
352 		if (Iter->second.nType == EMST_FUNCT_TINFO && Iter->second.data == funcName && Iter->first>=0)// 只有序号大于0的才删（适应跨区作此修改）
353 		{
355 			if (nCurTime - Iter->second.nTime < 60)
396 	for (Iter=m_funcMap.begin(); Iter!=m_funcMap.end(); Iter++)
397 	{
398 		if (Iter->second.nType == EMST_FUNCT_SINFO && Iter->second.data == funcName && Iter->first>=0)// 只有序号大于0的才删（适应跨区作此修改）
399 		{
401 			if (nCurTime - Iter->second.nTime < 60)

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcClient\Client\EntityClient\SchemeZoneMatron.cpp 7 KB CPP 文件 2014/2/25 13:42:55 2018/10/23 19:34:12 2018/10/23 19:34:12 1
201 		// 禁止双人坐骑进入
202 		schemeInfo.bForbidBWM = pCSVReader->GetBool(i, 17, 0);
204 		// 不允许跨区传送
205 		schemeInfo.bForbidStarTrek = pCSVReader->GetBool(i, 18, 0);
207 		// 标志位

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcClient\Client\EntityClient\EntityClient.cpp 56 KB CPP 文件 2014/2/25 13:42:36 2018/10/23 19:34:09 2018/10/23 19:34:09 2
1025 	}
1026 	pHero->AddEntityPart(pSuitPart);
1028 	// 跨区副本部件
1029 	IEctypeAssistPart* pEctypeAssistPart = gGlobalClient->getMatchClient()->CreateEctypeAssistPart();
1030 	if(!pEctypeAssistPart->Create(pHero, NULL, 0))
1030 	if(!pEctypeAssistPart->Create(pHero, NULL, 0))
1031 	{
1032 		Error("通过默认数据构造Hero实体失败！-- 创建跨区副本部件" << endl);
1034 		SAFE_RELEASE(pEctypeAssistPart);
1036 		SAFE_RELEASE(pHero);

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcClient\Client\CountryClient\GameCountryAPI.cpp 42 KB CPP 文件 2014/2/25 13:42:04 2018/10/23 19:33:54 2018/10/23 19:33:54 3
600 			if (pBridgeCountry != NULL)
601 			{
602 				// 取跨区国家名称
603 				pBridgeCountry->GetWorldCountryName();
604 			}
633 		if (isPublicGameWorld())
634 		{
635 			// 跨区国家名称
636 			return pInfo->szWorldName;
637 		}
652 			if (pBridgeCountry != NULL)
653 			{
654 				// 取跨区国家名称
655 				return pBridgeCountry->GetWorldCountryName();
656 			}

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcClient\Client\CountryClient\BasePart.cpp 36 KB CPP 文件 2014/2/25 13:41:57 2018/10/23 19:33:54 2018/10/23 19:33:54 1
336 	}
338 	pStrData = pszMsg + sizeof(SMsgCountryBaseAnswerBuildClient_OC) + pMsg->nNameLen + pMsg->nTitleLen + pMsg->nLocalNameLen;
339 	// 取得跨区国家名称
340 	if (pMsg->nWorldNameLen>0)
341 	{

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcClient\Client\controller\SwitchAreaForm.cpp 7 KB CPP 文件 2014/2/25 13:46:45 2018/10/23 19:33:52 2018/10/23 19:33:52 1
5 ** 日  期:	2010-07-02
6 ** 版  本:	1.0
7 ** 描  述:	用于跨区切换过渡界面，（暂时没有启用）
8 ** 应  用:  
9 ******************************************************************/

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcClient\Client\controller\GameForm.cpp 66 KB CPP 文件 2014/2/25 13:46:38 2018/10/23 19:33:49 2018/10/23 19:33:49 5
230 void GameForm::release()
231 {
232 	// 清除跨区数据
233 	memset(&m_switchAreaBuf, 0, sizeof(m_switchAreaBuf));
234 	m_bSwitchArea = false;
250 bool GameForm::create()
251 {
252 	// 清除跨区数据
253 	memset(&m_switchAreaBuf, 0, sizeof(m_switchAreaBuf));
254 	m_bSwitchArea = false;
1434 					}
1435 					SMsgLoginServer_AreaSwitchRes * pRes = (SMsgLoginServer_AreaSwitchRes *)data;
1437 					// 清除跨区数据
1438 					m_switchAreaBuf = *pRes;
1439 					m_bSwitchArea = true;
1470 					ISchemeCenter* pSchemeCenter = gGlobalClient->getEntityClient()->GetSchemeCenter();
1471 					if (pSchemeCenter != NULL && pSchemeCenter->GetGameBaseConfig(EGameConfig_Area)==EGameArea_StressTest)
1472 					{/* 压测区不启用跨区，所以先关闭
1473 						//char szCurRemoteIp[20] = {0};
1474 						LPCSTR szCurRemoteIp = NULL;
1860 }
1861 //end add
1864 // 重新连跨区网关
1865 void GameForm::ConnectNewAreaGateway()
1866 {

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcClient\Client\ChatClient\GMCommandManager.cpp 15 KB CPP 文件 2014/2/25 13:41:34 2018/10/23 19:33:38 2018/10/23 19:33:38 1
141 	REG_GM_CMD(GMCommand_Simple,				"prison",				4,	":prison 角色名,理由,显示给玩家的理由,分钟",		"蹲监牢",					RightFlag_Mute, true);
142 	REG_GM_CMD(GMCommand_Simple,				"checkzone",			1,	":checkzone 角色名",	 "查询玩家在公共区还是普通区",							RightFlag_ChangePos_Myself, true);
143 	REG_GM_CMD(GMCommand_Simple,				"hang",					0,	":hang",				 "跨区传送到默认位置",									RightFlag_ChangePos_Myself, true);
144 	REG_GM_CMD(GMCommand_ScanModeMd5,			"spex",					3,	":spex type,文件路径,flag",	 "扫描玩家是否具有指定对应md5码的进程，主要用于检测外挂，文件指定md5列表",			RightFlag_TrackUserPC, true);
145 	REG_GM_CMD(GMCommand_FileMd5,				"md5",					2,	":md5 角色名,文件路径",	 "扫描玩家是否具有指定对应md5码的进程，主要用于检测外挂，文件指定md5列表",			RightFlag_TrackUserPC, true);

I:\work\source\盛世OL\[src.cool]盛世OL\Server\GameServer\worldkernel\YyCntSvrClientSink.cpp 5 KB CPP 文件 2014/2/25 15:44:26 2018/10/23 13:19:22 2018/10/23 13:19:22 2
47 	SafeCopy( msg.szReason , szReason , sizeof(msg.szReason) ) ;
48 	SafeCopy( msg.szGmRoleName , szGmRoleName , sizeof(msg.szGmRoleName) ) ;
50 	LOGMSG( "跨区封Ip, GmAccount %d , GmRole %d , Ip %d , 理由:%s" ,
51 				dwGmAccountId , dwGmRoleId , dwIp , szReason  ) ;
53 	for(int i = MSGPORT_MAPGROUP_FIRST; i < m_pMsgPort->GetSize(); i++)
74 	SafeCopy( msg.szGmRoleName , szGmRoleName , sizeof(msg.szGmRoleName) ) ;
75 	
76 	LOGMSG( "跨区封发机超, GmAccount %d , GmRole %d , amount %d , 理由:%s" ,
77 		dwGmAccountId , dwGmRoleId , dwMinTimeOutAmount, szReason  ) ;
78 	

I:\work\source\盛世OL\[src.cool]盛世OL\Server\GameServer\mapgroupkernel\MapGroupKernel.cpp 51 KB CPP 文件 2014/2/25 15:43:12 2018/10/23 13:19:19 2018/10/23 13:19:19 3
1134 		}
1135 		break;
1136 	case MAPGROUP_FORBID_IPROLE: // 跨区封IP上的用户 [YuHaiyun 2008-9-12 17:02]
1137 		{
1138 			const ST_FORBID_IP *pForbidIpRole = ( const ST_FORBID_IP*)buf ;
1145 				in_addr addr ;
1146 				addr.S_un.S_addr = pForbidIpRole->dwIp ;
1147 				SafeSprintf( szMsg , sizeof(szMsg) , "%s跨区封IP %s:%s" , 
1148 						pForbidIpRole->szGmRoleName , 
1149 						inet_ntoa( addr ) , 
1164 			{
1165 				MSGBUF szMsg = "" ;
1166 				SafeSprintf( szMsg , sizeof(szMsg) , "%s跨区封发机超 %d:%s" , 
1167 					pForbidIpRole->szGmRoleName , 
1168 					pForbidIpRole->dwMinTimeOutAmount , 

I:\work\source\灭神OL\[src.cool]灭神OL\src\CleanEngine\Engine\Scene\SceneZone.cpp 67 KB CPP 文件 2010/1/13 21:37:20 2018/10/22 17:30:25 2018/10/22 17:30:25 2
1251 			if(nPos >= 0)
1252 			{
1253 				// 如果是灯光,检测是否跨区域,目前不支持跨区域编辑
1254 				if(m_pObjects[nPos].m_ObjectF.m_eType == ScnObj_Light)
1255 				{

I:\work\source\武侠无双\zccode_chess_0027\武侠无双\WXWS_CODE\SwordLogin双线\SwrodLogin\ActiveClientManager.cpp 20 KB CPP 文件 2011/4/9 9:35:27 2018/10/23 15:35:58 2018/10/23 15:35:58 1
622 }
624 //
625 // 跨区T人
626 //
627 void CActiveClientManager::DBKick( Account* pAccount )

I:\work\source\武侠无双\zccode_chess_0027\武侠无双\WXWS_CODE\SwordLogin_OldVersion\SwrodLogin\ActiveClientManager.cpp 19 KB CPP 文件 2011/4/1 17:25:16 2018/10/23 15:35:52 2018/10/23 15:35:52 1
582 }
584 //
585 // 跨区T人
586 //
587 void CActiveClientManager::DBKick( Account* pAccount )

I:\work\source\武侠无双\zccode_chess_0027\武侠无双\WXWS_CODE\SwordClient\socket\SSockManager.cpp 214 KB CPP 文件 2011/5/11 14:17:00 2018/10/23 15:34:57 2018/10/23 15:34:57 1
2285 	//	g_pChooseDlg->Init(".\\UITex\\Choose.dlg");
2287 	//	g_pChooseDlg->SetAllRoleInfo( info, byNum, false);//设置本区的角色数据
2288 	//	g_pChooseDlg->SetAllRoleInfo( Worldinfo, byWorldNum, true );//设置跨区的角色数据
2289 	//	g_pChooseDlg->SetChooseRoleState(TRUE);
2290 	//}

I:\work\source\天空之剑\[src.cool]天空之剑\sky\Code\SrcServer\ObjectServer\9GridMan.cpp 9 KB CPP 文件 2013/5/24 13:10:14 2018/10/23 14:48:33 2018/10/23 14:48:33 6
76 }
78 //////////////////////////////////////////////////////////////////////////
79 // 描  述：返回两个TILE坐标点之间是否跨区了（即：两点在不同的九宫格内）
80 //         若跨过了九宫返回新接触的格子编号列表（格子在地图上的编号）
81 // 输  入：两个TILE坐标点ptTileFirst、ptTileSecond
80 //         若跨过了九宫返回新接触的格子编号列表（格子在地图上的编号）
81 // 输  入：两个TILE坐标点ptTileFirst、ptTileSecond
82 // 返回值：返回FALSE表示没有跨区
83 //         nOldGridCount为旧的不要了的格子数，pOldGrid存放旧的不要了的格子编号列表，
84 //         nNewGridCount为新进入的格子数，pNewGrid存放新进入的格子编号列表
98 	int nNewX = ptTileSecond.x >> GRID9_SHIFT_RIGHT;
99 	int nNewY = ptTileSecond.y >> GRID9_SHIFT_RIGHT;
101 	// 没有跨区
102 	if (nOldX == nNewX && nOldY == nNewY)
103 	{
207 //////////////////////////// 以下函数用于小九宫格 ////////////////////////
208 //////////////////////////////////////////////////////////////////////////
209 // 描  述：返回两个TILE坐标点之间是否跨区了（即：两点在不同的小九宫格内）
210 //         若跨过了九宫返回新接触的格子编号
211 // 输  入：两个TILE坐标点ptTileFirst、ptTileSecond
210 //         若跨过了九宫返回新接触的格子编号
211 // 输  入：两个TILE坐标点ptTileFirst、ptTileSecond
212 // 返回值：返回FALSE表示没有跨区
213 //         nnOldGridID为旧的格子ID，nNewGridID为新的格子ID
214 // 备  注：小九宫格一个格子的宽度为GRID9_T_SIZEX_SMALL，高度为GRID9_T_SIZEY_SMALL
221 	int nNewX = ptTileSecond.x >> GRID9_SHIFT_R_SMALL;
222 	int nNewY = ptTileSecond.y >> GRID9_SHIFT_R_SMALL;
224 	// 没有跨区
225 	if (nOldX == nNewX && nOldY == nNewY)
226 	{

I:\work\source\剑侠时代\jxsd\core\地图插件\jxsd\code\Server\GameServer\worldkernel\YyCntSvrClientSink.cpp 4 KB CPP 文件 2010/12/21 10:11:29 2018/10/19 14:11:35 2018/10/19 14:11:35 2
46 	SafeCopy( msg.szReason , szReason , sizeof(msg.szReason) ) ;
47 	SafeCopy( msg.szGmRoleName , szGmRoleName , sizeof(msg.szGmRoleName) ) ;
49 	LOGMSG( "跨区封Ip, GmAccount %d , GmRole %d , Ip %d , 理由:%s" ,
50 				dwGmAccountId , dwGmRoleId , dwIp , szReason  ) ;
52 	for(int i = MSGPORT_MAPGROUP_FIRST; i < m_pMsgPort->GetSize(); i++)
72 	SafeCopy( msg.szGmRoleName , szGmRoleName , sizeof(msg.szGmRoleName) ) ;
73 	
74 	LOGMSG( "跨区封发机超, GmAccount %d , GmRole %d , amount %d , 理由:%s" ,
75 		dwGmAccountId , dwGmRoleId , dwMinTimeOutAmount, szReason  ) ;
76 	

I:\work\source\剑侠时代\jxsd\core\地图插件\jxsd\code\Server\GameServer\mapgroupkernel\MapGroupKernel.cpp 44 KB CPP 文件 2010/12/21 10:11:30 2018/10/19 14:11:33 2018/10/19 14:11:33 3
931 		}
932 		break;
933 	case MAPGROUP_FORBID_IPROLE: // 跨区封IP上的用户 [wxy 2008-9-12 17:02]
934 		{
935 			const ST_FORBID_IP *pForbidIpRole = ( const ST_FORBID_IP*)buf ;
942 				in_addr addr ;
943 				addr.S_un.S_addr = pForbidIpRole->dwIp ;
944 				SafeSprintf( szMsg , sizeof(szMsg) , "%s跨区封IP %s:%s" , 
945 						pForbidIpRole->szGmRoleName , 
946 						inet_ntoa( addr ) , 
961 			{
962 				MSGBUF szMsg = "" ;
963 				SafeSprintf( szMsg , sizeof(szMsg) , "%s跨区封发机超 %d:%s" , 
964 					pForbidIpRole->szGmRoleName , 
965 					pForbidIpRole->dwMinTimeOutAmount , 

I:\work\source\剑侠时代\[src.cool]剑侠时代\jxsd\code\Server\GameServer\worldkernel\YyCntSvrClientSink.cpp 4 KB CPP 文件 2010/12/21 10:11:29 2018/10/19 14:11:14 2018/10/19 14:11:14 2
46 	SafeCopy( msg.szReason , szReason , sizeof(msg.szReason) ) ;
47 	SafeCopy( msg.szGmRoleName , szGmRoleName , sizeof(msg.szGmRoleName) ) ;
49 	LOGMSG( "跨区封Ip, GmAccount %d , GmRole %d , Ip %d , 理由:%s" ,
50 				dwGmAccountId , dwGmRoleId , dwIp , szReason  ) ;
52 	for(int i = MSGPORT_MAPGROUP_FIRST; i < m_pMsgPort->GetSize(); i++)
72 	SafeCopy( msg.szGmRoleName , szGmRoleName , sizeof(msg.szGmRoleName) ) ;
73 	
74 	LOGMSG( "跨区封发机超, GmAccount %d , GmRole %d , amount %d , 理由:%s" ,
75 		dwGmAccountId , dwGmRoleId , dwMinTimeOutAmount, szReason  ) ;
76 	

I:\work\source\剑侠时代\[src.cool]剑侠时代\jxsd\code\Server\GameServer\mapgroupkernel\MapGroupKernel.cpp 44 KB CPP 文件 2010/12/21 10:11:30 2018/10/19 14:11:13 2018/10/19 14:11:13 3
931 		}
932 		break;
933 	case MAPGROUP_FORBID_IPROLE: // 跨区封IP上的用户 [wxy 2008-9-12 17:02]
934 		{
935 			const ST_FORBID_IP *pForbidIpRole = ( const ST_FORBID_IP*)buf ;
942 				in_addr addr ;
943 				addr.S_un.S_addr = pForbidIpRole->dwIp ;
944 				SafeSprintf( szMsg , sizeof(szMsg) , "%s跨区封IP %s:%s" , 
945 						pForbidIpRole->szGmRoleName , 
946 						inet_ntoa( addr ) , 
961 			{
962 				MSGBUF szMsg = "" ;
963 				SafeSprintf( szMsg , sizeof(szMsg) , "%s跨区封发机超 %d:%s" , 
964 					pForbidIpRole->szGmRoleName , 
965 					pForbidIpRole->dwMinTimeOutAmount , 

