I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\ZoneServerLogic\ZoneServiceProvider.cpp 77 KB CPP 文件 2014/2/25 0:20:21 2018/10/23 20:07:19 2018/10/23 20:07:19 16
288 	// 仇恨服务器
289 	m_pEnmityServer = NULL;
291 	// 跨服服务器
292 	m_pStarTrekServer = NULL;
292 	m_pStarTrekServer = NULL;
294 	// 跨服组队撮合服务器
295 	m_pMatchServer = NULL;
297 	// 国战服务器
1458 	Trace("创建仇恨服务器成功... ..." << endl);
1459 	Trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl << endl);
1461 	// 跨服服务器
1462 	Trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl);
1462 	Trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl);
1463 	START_SERVICE("跨服服务器..");
1464 	m_pStarTrekServer = CreateStarTrekServerProc();
1465 	if(m_pStarTrekServer == NULL)
1465 	if(m_pStarTrekServer == NULL)
1466 	{
1467 		Error("创建跨服服务器失败... ..." << endl);
1468 		return false;
1469 	}
1468 		return false;
1469 	}
1470 	Trace("创建跨服服务器成功... ..." << endl);
1471 	Trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl << endl);
1471 	Trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl << endl);
1473 	// 跨服组队撮合服务器
1474 	Trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl);
1474 	Trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl);
1475 	Trace("开始创建跨服组队撮合服务器... ..." << endl);
1476 	m_pMatchServer = CreateMatchServerProc();
1477 	if(m_pMatchServer == NULL)
1477 	if(m_pMatchServer == NULL)
1478 	{
1479 		Error("创建跨服组队撮合服务器失败... ..." << endl);
1480 		return false;
1481 	}
1480 		return false;
1481 	}
1482 	Trace("创建跨服组队撮合服务器成功... ..." << endl);
1483 	Trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl << endl);
1485 	// 国战服务器
1975 	SAFE_RELEASE(m_pEnmityServer);	
1976 	CALCULATE_RELEASEMODULE("仇恨服务器");	
1978 	// 跨服服务器
1979 	SAFE_RELEASE(m_pStarTrekServer);	
1979 	SAFE_RELEASE(m_pStarTrekServer);	
1980 	CALCULATE_RELEASEMODULE("跨服服务器");
1982 	// 跨服组队撮合服务器
1983 	SAFE_RELEASE(m_pMatchServer);
1983 	SAFE_RELEASE(m_pMatchServer);
1984 	CALCULATE_RELEASEMODULE("跨服组队撮合服务器");
1986 	// 国战服务器
1987 	SAFE_RELEASE(m_pSiegeWarServer);
2807 	return m_pStarTrekServer;
2808 }
2810 /** 取得跨服组队撮合服务器
2811 @param   
2812 @param   
2817 	return m_pMatchServer;
2818 }
2820 /** 取得跨服组队撮合服务器
2821 @param   
2822 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\ZoneServer\ZoneServiceProvider.cpp 101 KB CPP 文件 2014/2/25 0:12:52 2018/10/23 20:07:10 2018/10/23 20:07:10 16
294 	// 仇恨服务器
295 	m_pEnmityServer = NULL;
297 	// 跨服服务器
298 	m_pStarTrekServer = NULL;
298 	m_pStarTrekServer = NULL;
300 	// 跨服组队撮合服务器
301 	m_pMatchServer = NULL;
303 	// 国战服务器
2152 	Trace("创建仇恨服务器成功... ..." << endl);
2153 	Trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl << endl);
2155 	// 跨服服务器
2156 	Trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl);
2156 	Trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl);
2157 	START_SERVICE("跨服服务器..");
2158 	m_pStarTrekServer = CreateStarTrekServerProc();
2159 	if(m_pStarTrekServer == NULL)
2159 	if(m_pStarTrekServer == NULL)
2160 	{
2161 		Error("创建跨服服务器失败... ..." << endl);
2162 		return false;
2163 	}
2162 		return false;
2163 	}
2164 	Trace("创建跨服服务器成功... ..." << endl);
2165 	Trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl << endl);
2165 	Trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl << endl);
2167 	// 跨服组队撮合服务器
2168 	Trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl);
2168 	Trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl);
2169 	Trace("开始创建跨服组队撮合服务器... ..." << endl);
2170 	m_pMatchServer = CreateMatchServerProc();
2171 	if(m_pMatchServer == NULL)
2171 	if(m_pMatchServer == NULL)
2172 	{
2173 		Error("创建跨服组队撮合服务器失败... ..." << endl);
2174 		return false;
2175 	}
2174 		return false;
2175 	}
2176 	Trace("创建跨服组队撮合服务器成功... ..." << endl);
2177 	Trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl << endl);
2179 	// 国战服务器
2669 	SAFE_RELEASE(m_pEnmityServer);	
2670 	CALCULATE_RELEASEMODULE("仇恨服务器");	
2672 	// 跨服服务器
2673 	SAFE_RELEASE(m_pStarTrekServer);	
2673 	SAFE_RELEASE(m_pStarTrekServer);	
2674 	CALCULATE_RELEASEMODULE("跨服服务器");
2676 	// 跨服组队撮合服务器
2677 	SAFE_RELEASE(m_pMatchServer);
2677 	SAFE_RELEASE(m_pMatchServer);
2678 	CALCULATE_RELEASEMODULE("跨服组队撮合服务器");
2680 	// 国战服务器
2681 	SAFE_RELEASE(m_pSiegeWarServer);
3522 	return m_pStarTrekServer;
3523 }
3525 /** 取得跨服组队撮合服务器
3526 @param   
3527 @param   
3532 	return m_pMatchServer;
3533 }
3535 /** 取得跨服组队撮合服务器
3536 @param   
3537 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\ZoneServerLogic\ZoneServiceProvider.cpp 77 KB CPP 文件 2014/2/25 14:30:21 2018/10/23 19:46:15 2018/10/23 19:46:15 16
288 	// 仇恨服务器
289 	m_pEnmityServer = NULL;
291 	// 跨服服务器
292 	m_pStarTrekServer = NULL;
292 	m_pStarTrekServer = NULL;
294 	// 跨服组队撮合服务器
295 	m_pMatchServer = NULL;
297 	// 国战服务器
1458 	Trace("创建仇恨服务器成功... ..." << endl);
1459 	Trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl << endl);
1461 	// 跨服服务器
1462 	Trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl);
1462 	Trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl);
1463 	START_SERVICE("跨服服务器..");
1464 	m_pStarTrekServer = CreateStarTrekServerProc();
1465 	if(m_pStarTrekServer == NULL)
1465 	if(m_pStarTrekServer == NULL)
1466 	{
1467 		Error("创建跨服服务器失败... ..." << endl);
1468 		return false;
1469 	}
1468 		return false;
1469 	}
1470 	Trace("创建跨服服务器成功... ..." << endl);
1471 	Trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl << endl);
1471 	Trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl << endl);
1473 	// 跨服组队撮合服务器
1474 	Trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl);
1474 	Trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl);
1475 	Trace("开始创建跨服组队撮合服务器... ..." << endl);
1476 	m_pMatchServer = CreateMatchServerProc();
1477 	if(m_pMatchServer == NULL)
1477 	if(m_pMatchServer == NULL)
1478 	{
1479 		Error("创建跨服组队撮合服务器失败... ..." << endl);
1480 		return false;
1481 	}
1480 		return false;
1481 	}
1482 	Trace("创建跨服组队撮合服务器成功... ..." << endl);
1483 	Trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl << endl);
1485 	// 国战服务器
1975 	SAFE_RELEASE(m_pEnmityServer);	
1976 	CALCULATE_RELEASEMODULE("仇恨服务器");	
1978 	// 跨服服务器
1979 	SAFE_RELEASE(m_pStarTrekServer);	
1979 	SAFE_RELEASE(m_pStarTrekServer);	
1980 	CALCULATE_RELEASEMODULE("跨服服务器");
1982 	// 跨服组队撮合服务器
1983 	SAFE_RELEASE(m_pMatchServer);
1983 	SAFE_RELEASE(m_pMatchServer);
1984 	CALCULATE_RELEASEMODULE("跨服组队撮合服务器");
1986 	// 国战服务器
1987 	SAFE_RELEASE(m_pSiegeWarServer);
2807 	return m_pStarTrekServer;
2808 }
2810 /** 取得跨服组队撮合服务器
2811 @param   
2812 @param   
2817 	return m_pMatchServer;
2818 }
2820 /** 取得跨服组队撮合服务器
2821 @param   
2822 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\ZoneServer\ZoneServiceProvider.cpp 101 KB CPP 文件 2014/2/25 14:29:39 2018/10/23 19:46:00 2018/10/23 19:46:00 16
294 	// 仇恨服务器
295 	m_pEnmityServer = NULL;
297 	// 跨服服务器
298 	m_pStarTrekServer = NULL;
298 	m_pStarTrekServer = NULL;
300 	// 跨服组队撮合服务器
301 	m_pMatchServer = NULL;
303 	// 国战服务器
2152 	Trace("创建仇恨服务器成功... ..." << endl);
2153 	Trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl << endl);
2155 	// 跨服服务器
2156 	Trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl);
2156 	Trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl);
2157 	START_SERVICE("跨服服务器..");
2158 	m_pStarTrekServer = CreateStarTrekServerProc();
2159 	if(m_pStarTrekServer == NULL)
2159 	if(m_pStarTrekServer == NULL)
2160 	{
2161 		Error("创建跨服服务器失败... ..." << endl);
2162 		return false;
2163 	}
2162 		return false;
2163 	}
2164 	Trace("创建跨服服务器成功... ..." << endl);
2165 	Trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl << endl);
2165 	Trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl << endl);
2167 	// 跨服组队撮合服务器
2168 	Trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl);
2168 	Trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl);
2169 	Trace("开始创建跨服组队撮合服务器... ..." << endl);
2170 	m_pMatchServer = CreateMatchServerProc();
2171 	if(m_pMatchServer == NULL)
2171 	if(m_pMatchServer == NULL)
2172 	{
2173 		Error("创建跨服组队撮合服务器失败... ..." << endl);
2174 		return false;
2175 	}
2174 		return false;
2175 	}
2176 	Trace("创建跨服组队撮合服务器成功... ..." << endl);
2177 	Trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl << endl);
2179 	// 国战服务器
2669 	SAFE_RELEASE(m_pEnmityServer);	
2670 	CALCULATE_RELEASEMODULE("仇恨服务器");	
2672 	// 跨服服务器
2673 	SAFE_RELEASE(m_pStarTrekServer);	
2673 	SAFE_RELEASE(m_pStarTrekServer);	
2674 	CALCULATE_RELEASEMODULE("跨服服务器");
2676 	// 跨服组队撮合服务器
2677 	SAFE_RELEASE(m_pMatchServer);
2677 	SAFE_RELEASE(m_pMatchServer);
2678 	CALCULATE_RELEASEMODULE("跨服组队撮合服务器");
2680 	// 国战服务器
2681 	SAFE_RELEASE(m_pSiegeWarServer);
3522 	return m_pStarTrekServer;
3523 }
3525 /** 取得跨服组队撮合服务器
3526 @param   
3527 @param   
3532 	return m_pMatchServer;
3533 }
3535 /** 取得跨服组队撮合服务器
3536 @param   
3537 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\ZoneManager\ZoneMatron.cpp 8 KB CPP 文件 2014/2/25 0:12:07 2018/10/23 20:07:02 2018/10/23 20:07:02 1
310 	return !m_pSchemeInfo.bForbidArena;
311 }
313 /** 是否允许跨服传送
314 @param   
315 @param   

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\ZoneManager\ZoneMatron.cpp 8 KB CPP 文件 2014/2/25 14:29:16 2018/10/23 19:45:53 2018/10/23 19:45:53 1
310 	return !m_pSchemeInfo.bForbidArena;
311 }
313 /** 是否允许跨服传送
314 @param   
315 @param   

I:\work\source\书剑恩仇录\书剑恩仇录_zccode.com\书剑恩仇录\金\Src\MapServer\Server\Messages\XXMapNotifyDispatch.cpp 5 KB CPP 文件 2013/3/3 14:00:08 2018/10/23 13:34:42 2018/10/23 13:34:42 1
61 		return MP_CONTINUE;
62 	}
64 	//以下是跨服的副本的处理
66 	//给报名服务器返回创建成功消息			
67 	MGMRoomBattle* Msg = CREATE_PACKET_OBJ(MGMRoomBattle,PACKET_MGM_ROOMBATTLE);

I:\work\source\书剑恩仇录\[src.cool]书剑恩仇录\Src\MapServer\Server\Messages\XXMapNotifyDispatch.cpp 5 KB CPP 文件 2013/3/3 14:00:08 2018/10/23 13:34:25 2018/10/23 13:34:25 1
61 		return MP_CONTINUE;
62 	}
64 	//以下是跨服的副本的处理
66 	//给报名服务器返回创建成功消息			
67 	MGMRoomBattle* Msg = CREATE_PACKET_OBJ(MGMRoomBattle,PACKET_MGM_ROOMBATTLE);

I:\work\source\书剑恩仇录\书剑恩仇录_zccode.com\书剑恩仇录\金\Src\Client\Game\Network\Message\XCTeamRequestInviteDispatch.cpp 8 KB CPP 文件 2013/3/3 17:29:32 2018/10/23 13:33:19 2018/10/23 13:33:19 1
29 	 */
30 	CGameTeamOrGroup	*pTeam = GAME_DATA_RELATION_PTR->GetTeamOrGroup();
32 	/* 有队伍的时候收到信息表示客户端数据出现问题; 如果是处于跨服副本,不接受入队邀请 */
33 	if(pTeam->HasTeam() || GAME_DATA_QUEST_PTR->IsRoomBattleGroupState() == TRUE)
34 	{

I:\work\source\书剑恩仇录\[src.cool]书剑恩仇录\Src\Client\Game\Network\Message\XCTeamRequestInviteDispatch.cpp 8 KB CPP 文件 2013/3/3 17:29:32 2018/10/23 13:33:08 2018/10/23 13:33:08 1
29 	 */
30 	CGameTeamOrGroup	*pTeam = GAME_DATA_RELATION_PTR->GetTeamOrGroup();
32 	/* 有队伍的时候收到信息表示客户端数据出现问题; 如果是处于跨服副本,不接受入队邀请 */
33 	if(pTeam->HasTeam() || GAME_DATA_QUEST_PTR->IsRoomBattleGroupState() == TRUE)
34 	{

I:\work\source\书剑恩仇录\书剑恩仇录_zccode.com\书剑恩仇录\金\Src\Tools\MyRobot2\PacketHandle\XCRoomBattleHandler.cpp 3 KB CPP 文件 2013/3/3 15:10:18 2018/10/23 13:38:25 2018/10/23 13:38:25 1
72 			default:
73 				{
74 					pAgent->getLuaState()->DoString("XCRetCreateBattleHandler(\"ERROR\")");//跨服失败
75 				}
76 		}

I:\work\source\书剑恩仇录\[src.cool]书剑恩仇录\Src\Tools\MyRobot2\PacketHandle\XCRoomBattleHandler.cpp 3 KB CPP 文件 2013/3/3 15:10:18 2018/10/23 13:36:26 2018/10/23 13:36:26 1
72 			default:
73 				{
74 					pAgent->getLuaState()->DoString("XCRetCreateBattleHandler(\"ERROR\")");//跨服失败
75 				}
76 		}

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\CountryService\WorldWar.cpp 100 KB CPP 文件 2014/2/25 0:21:48 2018/10/23 20:08:54 2018/10/23 20:08:54 157
5 ** 日  期:	2011-03-26
6 ** 版  本:	1.0
7 ** 描  述:	跨服国战系统部件
8 ** 应  用:  	
9 	
18 #include "WorldWar.h"
19 #include "CountryService.h"
23 // 跨服国战数据检查处理
24 CDBCheckBadWorldWar::CDBCheckBadWorldWar(void)
25 {
50 	switch(nCmdID)
51 	{
52 	case GAMEDB_REQUEST_WORLDCOUNTRY_WAR_READ:		// 查询跨服国战
53 		{
54 			OnDBReturn_ReadCheckBadWorldWar(nCmdID, nDBRetCode,pszDBRetDesc,nQueueIndex,pOutData,nOutLen);
59 	}
61 }
63 // 读出检查跨服国战信息
64 void CDBCheckBadWorldWar::OnDBReturn_ReadCheckBadWorldWar(int nCmdID, int nDBRetCode, char * pszDBRetDesc, int nQueueIndex, char * pOutData, int nOutLen)
65 {
74 	if(pOutData == NULL || nOutLen < sizeof(DB_Result_Read_WorldCountryWar))
75 	{
76 		ErrorLn("读出检查跨服国战信息数据大小非法，nOutLen = "<<nOutLen);
78 		return;		
79 	}
90 	if(nOutLen != (int)(pResult->nRecordCount * sizeof(DB_Table_WorldCountryWar) + sizeof(DB_Result_Read_WorldCountryWar)) )
91 	{
92 		ErrorLn("读出检查跨服国战信息数据条数与大小不符，nOutLen = "<<nOutLen);
93 		return;
94 	}
95 	if (pResult->nRecordCount<1)
96 	{
97 		TraceLn("读出检查跨服国战信息数据条数为0，条数 = "<<pResult->nRecordCount);
98 	}
100 	DWORD dwNowTimes = (DWORD)time(NULL);
106 		dwPublicWorldID = getThisGameWorldID();
107 	}
110 	// 临时跨服国战对象列表
111 	TMAP_CountryWorldWar mapWorldWar;
113 	DB_Table_WorldCountryWar * pDBReq = (DB_Table_WorldCountryWar *)(pOutData + sizeof(DB_Result_Read_WorldCountryWar));
117 	{
119 		SCountryWorldWarInfoNode  addNode;
121 		addNode.dwID					= pDBReq->dwID;									// 跨服国战信息ID，0为无效ID
122 		addNode.dwPublicWorldID			= pDBReq->dwPublicWorldID;						// 所属公共区世界ID
123 		addNode.dwStartTime				= pDBReq->dwStartTime;							// 开始时间
123 		addNode.dwStartTime				= pDBReq->dwStartTime;							// 开始时间
124 		addNode.dwEndTime				= pDBReq->dwEndTime;							// 结束时间
125 		addNode.dwType					= pDBReq->dwType;								// 跨服国战类型
126 		addNode.dwAttackWorldID			= pDBReq->dwAttackWorldID;						// 进攻国家所在游戏世界ID
127 		addNode.dwAttackCountryID		= pDBReq->dwAttackCountryID;					// 进攻国家ID
156 			addNode.dwState = CountryWorldWarState_None;
157 		}
159 		// 放入临时跨服国战对象列表
160 		mapWorldWar[addNode.dwID]	= addNode;
163 #ifdef COUNTRY_PRINT_DEBUG_INF
163 #ifdef COUNTRY_PRINT_DEBUG_INF
164 		// 调式代码
165 		sprintf_s(szBuf, _countof(szBuf),_NGT"%d.ID=%d,公共区世界ID=%d,开始时间=%d,结束时间=%d,跨服国战类型=%d,进攻世界ID=%d,进攻国家ID=%d,防御世界ID=%d,防御国家ID=%d,状态=%d,结果标识=%d,参数={%d,%d,%d,%d,%d}",
166 			i,addNode.dwID,addNode.dwPublicWorldID,addNode.dwStartTime,addNode.dwEndTime,addNode.dwType,addNode.dwAttackWorldID,addNode.dwAttackCountryID,addNode.dwDefendWorldID,addNode.dwDefendCountryID,
167 			addNode.dwState,addNode.dwResultFlag,addNode.dwData1,addNode.dwData2,addNode.dwData3,addNode.dwData4,addNode.dwData5);
205 				if (NULL==pBridgePart)
206 				{
207 					sprintf_s(szBuf, sizeof(szBuf), "跨服国战记录中的游戏区(%d)不存在! 记录ID=%d,所属公共区ID=%d,开始时间=%s,类型=%d,进攻世界ID=%d,进攻国家ID=%d,防御世界ID=%d,防御国家ID=%d,状态=%d",
208 						dwCheckWorldID,node.dwID,node.dwPublicWorldID,g_ExternalFacade.GetTimeString(node.dwStartTime),node.dwType,node.dwAttackWorldID,node.dwAttackCountryID,node.dwDefendWorldID,node.dwDefendCountryID,node.dwState);
210 					// 报警对应区没开
223 		if (node.dwPublicWorldID!=dwPublicWorldID)
224 		{
225 			sprintf_s(szBuf, sizeof(szBuf), "跨服国战记录中的所属公共游戏区(%d)与实际所连入的公共区(%d)不符! 记录ID=%d,所属公共区ID=%d,开始时间=%s,类型=%d,进攻世界ID=%d,进攻国家ID=%d,防御世界ID=%d,防御国家ID=%d,状态=%d",
226 				node.dwPublicWorldID,dwPublicWorldID,node.dwID,node.dwPublicWorldID,g_ExternalFacade.GetTimeString(node.dwStartTime),node.dwType,node.dwAttackWorldID,node.dwAttackCountryID,node.dwDefendWorldID,node.dwDefendCountryID,node.dwState);
228 			// 报警对应区没开
257 	DBSVR::TMSG_DBSVR_COUNTRY_WORLDWAR_GET_RSP& stRsp = pstMsg->stTMSG_DBSVR_COUNTRY_WORLDWAR_GET_RSP;
258 #ifdef TRACE_COUNTRY_DETAIL
259 	TraceLn("CDBCheckBadWorldWar::OnDBRet_ReadCheckBadCountryWorldWar 读出检查跨服国战信息  Result=" << stRsp.Result << " nTotalCount=" << stRsp.nTotalCount);
260 #endif
261 	if (stRsp.Result != 0)
261 	if (stRsp.Result != 0)
262 	{
263 		ErrorLn("读出检查跨服国战信息 失败,  Result = "<< stRsp.Result << " Err=[" << g_ExternalFacade.GetDBSvrErrStr(stRsp.Result) << "]" );
264 		return;
265 	}
273 	if (stRsp.nTotalCount < 1)
274 	{
275 		TraceLn("读出检查跨服国战信息数据条数为0，条数 = "<< stRsp.nTotalCount);
276 	}
278 	DWORD dwNowTimes = (DWORD)time(NULL);
284 		dwPublicWorldID = getThisGameWorldID();
285 	}
286 	// 临时跨服国战对象列表
287 	TMAP_CountryWorldWar mapWorldWar;
289 	DBSVR::TCountryWorldWarList_Set& stItemSet = stRsp.stItemSet;
296 		DWORD dwID = (DWORD)stItem.ID;
298 		SCountryWorldWarInfoNode  stAddNode;
300 		stAddNode.dwID					= dwID;									// 跨服国战信息ID，0为无效ID
301 		stAddNode.dwPublicWorldID		= stItem.dwPublicWorldID;						// 所属公共区世界ID
302 		stAddNode.dwStartTime			= stItem.dwStartTime;							// 开始时间
302 		stAddNode.dwStartTime			= stItem.dwStartTime;							// 开始时间
303 		stAddNode.dwEndTime				= stItem.dwEndTime;							// 结束时间
304 		stAddNode.dwType				= stItem.dwType;								// 跨服国战类型
305 		stAddNode.dwAttackWorldID		= stItem.dwAttackWorldID;						// 进攻国家所在游戏世界ID
306 		stAddNode.dwAttackCountryID		= stItem.dwAttackCountryID;					// 进攻国家ID
335 			stAddNode.dwState = CountryWorldWarState_None;
336 		}
338 		// 放入临时跨服国战对象列表
339 		mapWorldWar[stAddNode.dwID]	= stAddNode;
340 	}
370 				if (NULL==pBridgePart)
371 				{
372 					sprintf_s(szBuf, sizeof(szBuf), "跨服国战记录中的游戏区(%d)不存在! 记录ID=%d,所属公共区ID=%d,开始时间=%s,类型=%d,进攻世界ID=%d,进攻国家ID=%d,防御世界ID=%d,防御国家ID=%d,状态=%d",
373 						dwCheckWorldID,node.dwID,node.dwPublicWorldID,g_ExternalFacade.GetTimeString(node.dwStartTime),node.dwType,node.dwAttackWorldID,node.dwAttackCountryID,node.dwDefendWorldID,node.dwDefendCountryID,node.dwState);
375 					// 报警对应区没开
388 		if (node.dwPublicWorldID != dwPublicWorldID)
389 		{
390 			sprintf_s(szBuf, sizeof(szBuf), "跨服国战记录中的所属公共游戏区(%d)与实际所连入的公共区(%d)不符! 记录ID=%d,所属公共区ID=%d,开始时间=%s,类型=%d,进攻世界ID=%d,进攻国家ID=%d,防御世界ID=%d,防御国家ID=%d,状态=%d",
391 				node.dwPublicWorldID,dwPublicWorldID,node.dwID,node.dwPublicWorldID,g_ExternalFacade.GetTimeString(node.dwStartTime),node.dwType,node.dwAttackWorldID,node.dwAttackCountryID,node.dwDefendWorldID,node.dwDefendCountryID,node.dwState);
393 			// 报警对应区没开
443 	if (gGlobalCountryServer->IsCanOpenWorldWar())
444 	{
445 		// 查询跨服国战
446 		DB_Param_Read_WorldCountryWar dbParam;
446 		DB_Param_Read_WorldCountryWar dbParam;
447 		dbParam.dwID				= 0;							// 跨服国战信息ID，0为忽略
448 		dbParam.dwPublicWorldID		= (DWORD)getThisGameWorldID();				// 所属公共区世界ID，0为忽略
449 		dbParam.dwDays				= 30;						// 只读出最近多少天的记录，0为忽略
450 		dbParam.dwMaxCounts			= 600;						// 只读出最新多少条的记录，0为忽略	
451 		ReadWorldWar(dbParam);
453 		// 查询跨服国家边境连通信息
454 		DB_Param_Read_WorldCountryLink dbLink;
454 		DB_Param_Read_WorldCountryLink dbLink;
455 		dbLink.dwID				= 0;							// 跨服国战信息ID，0为忽略
456 		dbLink.dwPublicWorldID	= (DWORD)getThisGameWorldID();	// 所属公共区世界ID，0为忽略
457 		ReadWorldLink(dbLink);
631 		m_bSaved = true;
632 	}
634 	// 向数据库读取跨服国战信息记录
635 	IDBEngine * pDBEngine = g_ExternalFacade.GetDBEngine();
636 	if(pDBEngine == NULL)
638 		return;
639 	}
641 	// GAMEDB_REQUEST_COUNTRYOFFICER_SAVE 批量保存跨服国战信息 : 传入参数结构
642 	DB_Param_Save_WorldCountryWar dbParam;
644 	int nRecordCounts		= 0;					// 要保存记录数
646 	int nSaveDataSize		= sizeof(dbParam.szSaveData);					// 存入的数据长度
648 	ofixbuf obuf( (char*)dbParam.szSaveData, sizeof(dbParam.szSaveData));		// 存入的数据
650 	// 修改跨服国战信息 : 传入参数结构
651 	DB_Table_WorldCountryWar recordData;
653 	// 遍历所有记录
664 			}
666 			nRecordCounts++;		// 要保存记录数
668 			recordData.dwID						= iter->second.dwID;								// 跨服国战信息数据ID，为记录ID，找到就修改，没有就无效
669 			recordData.dwPublicWorldID			= iter->second.dwPublicWorldID;						// 所属公共区世界ID
670 			recordData.dwStartTime				= iter->second.dwStartTime;							// 开始时间
670 			recordData.dwStartTime				= iter->second.dwStartTime;							// 开始时间
671 			recordData.dwEndTime				= iter->second.dwEndTime;							// 结束时间
672 			recordData.dwType					= iter->second.dwType;								// 跨服国战类型
673 			recordData.dwAttackWorldID			= iter->second.dwAttackWorldID;						// 进攻国家所在游戏世界ID
674 			recordData.dwAttackCountryID		= iter->second.dwAttackCountryID;					// 进攻国家ID
745 	// 调式代码
746 	char szBuf[256]={0};
747 	sprintf_s(szBuf, _countof(szBuf),_NGT"CWorldWar::OnDataChanged() 跨服国战信息数据变更 m_bSaved=%d",m_bSaved);
748 	TraceLn(szBuf);
749 #endif
770 	switch(dwTimerID)
771 	{
772 	case ETimerEventID_DB_Read:			// 查询跨服国战
773 		{
774 			// kill timer
777 			if (gGlobalCountryServer->IsCanOpenWorldWar())
778 			{
779 				// 查询跨服国战
780 				DB_Param_Read_WorldCountryWar dbParam;
780 				DB_Param_Read_WorldCountryWar dbParam;
781 				dbParam.dwID				= 0;							// 跨服国战信息ID，0为忽略
782 				dbParam.dwPublicWorldID		= (DWORD)getThisGameWorldID();				// 所属公共区世界ID，0为忽略
783 				dbParam.dwDays				= 30;						// 只读出最近多少天的记录，0为忽略
811 	switch(nCmdID)
812 	{
813 	case GAMEDB_REQUEST_WORLDCOUNTRY_WAR_READ:		// 查询跨服国战
814 		{
815 			OnDBReturn_ReadWorldWar(nCmdID, nDBRetCode,pszDBRetDesc,nQueueIndex,pOutData,nOutLen);
816 		}
817 		break;
819 	case GAMEDB_REQUEST_WORLDCOUNTRY_WAR_ADD:		// 添加跨服国战
820 		{
821 			OnDBReturn_AddWorldWar(nCmdID, nDBRetCode,pszDBRetDesc,nQueueIndex,pOutData,nOutLen);
822 		}
823 		break;
825 	case GAMEDB_REQUEST_WORLDCOUNTRY_WAR_SAVE:		// 批量保存跨服国战信息
826 		{
827 			OnDBReturn_SaveWorldWar(nCmdID, nDBRetCode,pszDBRetDesc,nQueueIndex,pOutData,nOutLen);
828 		}
829 		break;
831 	case GAMEDB_REQUEST_WORLDCOUNTRY_LINK_READ:		// 查询跨服国家边境连通信息
832 		{
833 			OnDBReturn_ReadWorldLink(nCmdID, nDBRetCode,pszDBRetDesc,nQueueIndex,pOutData,nOutLen);
834 		}
835 		break;
837 	case GAMEDB_REQUEST_WORLDCOUNTRY_LINK_ADD:		// 添加跨服国家边境连通信息
838 		{
839 			OnDBReturn_AddWorldLink(nCmdID, nDBRetCode,pszDBRetDesc,nQueueIndex,pOutData,nOutLen);
850 //////////////////////////////////////////////////////////////////////////
852 /**
853 @purpose          : 读出检查跨服国战信息
854 @return		      : void
855 */
886 	}
888 	DB_Param_Read_WorldCountryWar dbParam;
889 	dbParam.dwID				= 0;						// 跨服国战信息ID，0为忽略
890 	dbParam.dwPublicWorldID		= 0;						// 所属公共区世界ID，0为忽略
891 	dbParam.dwDays				= 5;						// 只读出最近多少天的记录，0为忽略
895 		(LPCSTR)&dbParam,sizeof(DB_Param_Read_WorldCountryWar),static_cast<IDBRetSink *>(&m_DbCheckBadRet) ,getThisGameWorldID() ))
896 	{
897 		Error("读出检查跨服国战信息失败！ dwID="<<dbParam.dwID<<endl);
899 		return;
900 	}
902 }
905 /**
906 @purpose          : 查询跨服国战信息
907 @param	 DB_Param_Read_CountryWorldWar param: 查询跨服国战信息  : 传入参数结构
908 @return		      : void
909 */
946 		(LPCSTR)&dbParam,sizeof(DB_Param_Read_WorldCountryWar),static_cast<IDBRetSink *>(this) ,getThisGameWorldID() ))
947 	{
948 		Error("读取跨服国战信息失败！ dwID="<<dbParam.dwID<<endl);
950 		return;
951 	}
953 }
955 /**
956 @purpose          : 添加或修改跨服国战信息
957 @param	 DB_Param_Add_CountryWorldWar param: 添加或修改跨服国战信息 : 传入参数结构
958 @return		      : void
959 */
981 		(LPCSTR)&dbParam,sizeof(DB_Param_Add_WorldCountryWar),static_cast<IDBRetSink *>(this) ,getThisGameWorldID() ))
982 	{
983 		Error("添加或修改跨服国战信息失败！ dwMapID="<<dbParam.dwID<<endl);
985 		return;
986 	}
987 }
990 /**
991 @purpose          : 查询跨服国家边境连通信息
992 @param	 DB_Param_Read_WorldCountryLink param: 查询跨服国家边境连通信息  : 传入参数结构
993 @return		      : void
994 */
1029 		(LPCSTR)&dbParam,sizeof(DB_Param_Read_WorldCountryLink),static_cast<IDBRetSink *>(this) ,getThisGameWorldID() ))
1030 	{
1031 		Error("读取跨服国家边境连通信息失败！ dwID="<<dbParam.dwID<<endl);
1033 		return;
1034 	}
1036 }
1038 /**
1039 @purpose          : 添加或修改跨服国家边境连通信息
1040 @param	 DB_Param_Add_WorldCountryLink param: 添加或修改跨服国家边境连通信息 : 传入参数结构
1041 @return		      : void
1042 */
1059 	DBSVR::TWorldCountryLink& stItem = stReq.stItem;
1060 	
1061 	stItem.dwID				= param.dwID;								// 跨服国家边境连通信息ID，0为无效ID，找到就修改，否则就新增
1062 	// 存入的数据
1063 	stItem.dwPublicWorldID		= param.dwPublicWorldID;					// 所属公共区世界ID
1062 	// 存入的数据
1063 	stItem.dwPublicWorldID		= param.dwPublicWorldID;					// 所属公共区世界ID
1064 	stItem.dwType				= param.dwType;								// 跨服国家边境类型
1065 	stItem.dwWorldID			= param.dwWorldID;							// 国家所在游戏世界ID
1066 	stItem.dwCountryID			= param.dwCountryID;							// 国家ID
1088 		(LPCSTR)&dbParam,sizeof(DB_Param_Add_WorldCountryLink),static_cast<IDBRetSink *>(this) ,getThisGameWorldID() ))
1089 	{
1090 		Error("添加或修改跨服国家边境连通信息失败！ dwMapID="<<dbParam.dwID<<endl);
1092 		return;
1093 	}*/
1093 	}*/
1094 }
1098 /** 数据库请求返回回调方法 GAMEDB_REQUEST_WORLDCOUNTRY_LINK_READ   查询跨服国家边境连通信息
1099 @retval buffer 
1100 */	
1105 	// 调式代码
1106 	char szBuf[256]={0};
1107 	sprintf_s(szBuf, _countof(szBuf),_NGT"CWorldWar::OnDBReturn_ReadWorldLink() 查询跨服国家边境连通信息 nCmdID=%d,nDBRetCode=%d,nQueueIndex=%d,nOutLen=%d",
1108 		nCmdID,nDBRetCode,nQueueIndex,nOutLen);
1109 	TraceLn(szBuf);
1112 	if(pOutData == NULL || nOutLen < sizeof(DB_Result_Read_WorldCountryLink))
1113 	{
1114 		ErrorLn("读取跨服国家边境连通信息数据大小非法，nOutLen = "<<nOutLen);
1116 		return;		
1117 	}
1128 	if(nOutLen != (int)(pResult->nRecordCount * sizeof(DB_Table_WorldCountryLink) + sizeof(DB_Result_Read_WorldCountryLink)) )
1129 	{
1130 		ErrorLn("读取跨服国家边境连通信息数据条数与大小不符，nOutLen = "<<nOutLen);
1131 		return;
1132 	}
1133 	if (pResult->nRecordCount<1)
1134 	{
1135 		TraceLn("读取跨服国家边境连通信息数据条数为0，条数 = "<<pResult->nRecordCount);
1136 	}
1138 	m_mapWorldLink.clear();
1144 	{
1146 		SCountryWorldLinkInfo  addNode;
1148 		addNode.dwID					= pDBReq->dwID;									// 跨服国家边境连通信息ID，0为无效ID
1149 		addNode.dwPublicWorldID			= pDBReq->dwPublicWorldID;						// 所属公共区世界ID
1149 		addNode.dwPublicWorldID			= pDBReq->dwPublicWorldID;						// 所属公共区世界ID
1150 		addNode.dwType					= pDBReq->dwType;								// 跨服国家边境类型
1151 		addNode.dwWorldID				= pDBReq->dwWorldID;							// 国家所在游戏世界ID
1152 		addNode.dwCountryID				= pDBReq->dwCountryID;							// 国家ID
1162 		else
1163 		{
1164 			ErrorLn("读取跨服国家边境连通信息数据ID与内容不符，ID="<<addNode.dwID<<",dwKey = "<<dwKey);
1165 		}
1167 #ifdef COUNTRY_PRINT_DEBUG_INF
1167 #ifdef COUNTRY_PRINT_DEBUG_INF
1168 		// 调式代码
1169 		sprintf_s(szBuf, _countof(szBuf),_NGT"%d.ID=%d,公共区世界ID=%d,跨服国家边境连通类型=%d,世界ID=%d,国家ID=%d,连通国家世界ID=%d,连通国家ID=%d,状态=%d",
1170 			i,addNode.dwID,addNode.dwPublicWorldID,addNode.dwType,addNode.dwWorldID,addNode.dwCountryID,addNode.dwLinkWorldID,addNode.dwLinkCountryID,addNode.dwFlag);
1171 		TraceLn(szBuf);
1182 	SendWorldWarToServer(0,0);
1183 }
1185 /** 数据库请求返回回调方法 GAMEDB_REQUEST_WORLDCOUNTRY_LINK_ADD  添加跨服国家边境连通信息
1186 @retval buffer 
1187 */	
1192 	// 调式代码
1193 	char szBuf[256]={0};
1194 	sprintf_s(szBuf, _countof(szBuf),_NGT"CWorldWar::OnDBReturn_AddWorldLink() 添加跨服国家边境连通信息 nCmdID=%d,nDBRetCode=%d,nQueueIndex=%d,nOutLen=%d",
1195 		nCmdID,nDBRetCode,nQueueIndex,nOutLen);
1196 	TraceLn(szBuf);
1199 	if(pOutData == NULL || nOutLen != sizeof(DB_Result_Add_WorldCountryLink))
1200 	{
1201 		ErrorLn("添加修改跨服国家边境连通信息返回数据大小非法，nOutLen = "<<nOutLen);
1202 		return;		
1203 	}
1203 	}
1204 	DB_Result_Add_WorldCountryLink * pResult = (DB_Result_Add_WorldCountryLink *)(pOutData);
1206 	// 跨服国家边境连通信息ID, 0为无效ID
1207 	// 结果 0:出错,没有新增或修改; 1:新增成功,2:修改成功
1208 	if (pResult->nResult==0)
1208 	if (pResult->nResult==0)
1209 	{
1210 		ErrorLn("添加修改跨服国家边境连通信息失败！nResult="<<pResult->nResult);
1211 		return;
1212 	}
1212 	}
1213 }
1217 /** 数据库请求返回回调方法 GAMEDB_REQUEST_WORLDCOUNTRY_WAR_READ   查询跨服国战信息
1218 @retval buffer 
1219 */	
1224 	// 调式代码
1225 	char szBuf[256]={0};
1226 	sprintf_s(szBuf, _countof(szBuf),_NGT"CWorldWar::OnDBReturn_ReadWorldWar() 查询跨服国战信息 nCmdID=%d,nDBRetCode=%d,nQueueIndex=%d,nOutLen=%d",
1227 		nCmdID,nDBRetCode,nQueueIndex,nOutLen);
1228 	TraceLn(szBuf);
1231 	if(pOutData == NULL || nOutLen < sizeof(DB_Result_Read_WorldCountryWar))
1232 	{
1233 		ErrorLn("读取跨服国战信息数据大小非法，nOutLen = "<<nOutLen);
1235 		return;		
1236 	}
1247 	if(nOutLen != (int)(pResult->nRecordCount * sizeof(DB_Table_WorldCountryWar) + sizeof(DB_Result_Read_WorldCountryWar)) )
1248 	{
1249 		ErrorLn("读取跨服国战信息数据条数与大小不符，nOutLen = "<<nOutLen);
1250 		return;
1251 	}
1252 	if (pResult->nRecordCount<1)
1253 	{
1254 		TraceLn("读取跨服国战信息数据条数为0，条数 = "<<pResult->nRecordCount);
1255 	}
1256 	m_dwMaxID = 0;
1271 		}
1273 		SCountryWorldWarInfoNode  addNode;
1275 		addNode.dwID					= pDBReq->dwID;									// 跨服国战信息ID，0为无效ID
1276 		addNode.dwPublicWorldID			= pDBReq->dwPublicWorldID;						// 所属公共区世界ID
1277 		addNode.dwStartTime				= pDBReq->dwStartTime;							// 开始时间
1277 		addNode.dwStartTime				= pDBReq->dwStartTime;							// 开始时间
1278 		addNode.dwEndTime				= pDBReq->dwEndTime;							// 结束时间
1279 		addNode.dwType					= pDBReq->dwType;								// 跨服国战类型
1280 		addNode.dwAttackWorldID			= pDBReq->dwAttackWorldID;						// 进攻国家所在游戏世界ID
1281 		addNode.dwAttackCountryID		= pDBReq->dwAttackCountryID;					// 进攻国家ID
1319 #ifdef COUNTRY_PRINT_DEBUG_INF
1320 		// 调式代码
1321 		sprintf_s(szBuf, _countof(szBuf),_NGT"%d.ID=%d,公共区世界ID=%d,开始时间=%d,结束时间=%d,跨服国战类型=%d,进攻世界ID=%d,进攻国家ID=%d,防御世界ID=%d,防御国家ID=%d,状态=%d,结果标识=%d,参数={%d,%d,%d,%d,%d}",
1322 			i,addNode.dwID,addNode.dwPublicWorldID,addNode.dwStartTime,addNode.dwEndTime,addNode.dwType,addNode.dwAttackWorldID,addNode.dwAttackCountryID,addNode.dwDefendWorldID,addNode.dwDefendCountryID,
1323 			addNode.dwState,addNode.dwResultFlag,addNode.dwData1,addNode.dwData2,addNode.dwData3,addNode.dwData4,addNode.dwData5);
1337 	SendWorldWarToServer(0,0);
1338 }
1340 /** 数据库请求返回回调方法 GAMEDB_REQUEST_WORLDCOUNTRY_WAR_ADD  添加跨服国战信息
1341 @retval buffer 
1342 */	
1347 	// 调式代码
1348 	char szBuf[256]={0};
1349 	sprintf_s(szBuf, _countof(szBuf),_NGT"CWorldWar::OnDBReturn_AddWorldWar() 添加跨服国战信息 nCmdID=%d,nDBRetCode=%d,nQueueIndex=%d,nOutLen=%d",
1350 		nCmdID,nDBRetCode,nQueueIndex,nOutLen);
1351 	TraceLn(szBuf);
1354 	if(pOutData == NULL || nOutLen != sizeof(DB_Result_Add_WorldCountryWar))
1355 	{
1356 		ErrorLn("添加修改跨服国战信息返回数据大小非法，nOutLen = "<<nOutLen);
1357 		return;		
1358 	}
1358 	}
1359 	DB_Result_Add_WorldCountryWar * pResult = (DB_Result_Add_WorldCountryWar *)(pOutData);
1361 	// 跨服国战信息ID, 0为无效ID
1362 	// 结果 0:出错,没有新增或修改; 1:新增成功,2:修改成功
1363 	if (pResult->nResult==0)
1363 	if (pResult->nResult==0)
1364 	{
1365 		ErrorLn("添加修改跨服国战信息失败！nResult="<<pResult->nResult);
1366 		return;
1367 	}
1404 #ifdef COUNTRY_PRINT_DEBUG_INF
1405 	// 调式代码
1406 	sprintf_s(szBuf, _countof(szBuf),_NGT"添加修改跨服国战信息成功！ dwID=%d,nQueueIndex=%d,nResult=%d",iter->second.dwID,nQueueIndex,pResult->nResult);
1407 	TraceLn(szBuf);
1408 #endif
1408 #endif
1410 }
1413 /** 数据库请求返回回调方法 GAMEDB_REQUEST_WORLDCOUNTRY_WAR_SAVE  批量保存跨服国战信息
1414 @retval buffer 
1415 */	
1420 	// 调式代码
1421 	char szBuf[256]={0};
1422 	sprintf_s(szBuf, _countof(szBuf),_NGT"CWorldWar::OnDBReturn_SaveWorldWar() 批量保存跨服国战信息 nCmdID=%d,nDBRetCode=%d,nQueueIndex=%d,nOutLen=%d",
1423 		nCmdID,nDBRetCode,nQueueIndex,nOutLen);
1424 	TraceLn(szBuf);
1427 	if(pOutData == NULL || nOutLen < sizeof(DB_Result_Save_WorldCountryWar))
1428 	{
1429 		ErrorLn("批量保存跨服国战信息返回数据大小非法，nOutLen = "<<nOutLen);
1431 		return;		
1432 	}
1435 	if(nOutLen != pResult->nRecordCount * sizeof(DB_Result_Save_WorldCountryWar_Record) + sizeof(DB_Result_Save_WorldCountryWar))
1436 	{
1437 		ErrorLn("批量保存跨服国战信息返回数据条数与大小不符，nOutLen = "<<nOutLen);
1438 		return;
1439 	}
1440 	if (pResult->nRecordCount<1)
1441 	{
1442 		//TraceLn("批量保存跨服国战信息返回数据条数为0，条数 = "<<pResult->nRecordCount);
1443 		return;
1444 	}
1452 #ifdef COUNTRY_PRINT_DEBUG_INF
1453 		// 调式代码
1454 		sprintf_s(szBuf, _countof(szBuf),_NGT"批量保存跨服国战信息结果:%d. dwMapID=%d,nResult=%d",i,pDBReqSave->dwMapID,pDBReqSave->nResult);
1455 		TraceLn(szBuf);
1456 #endif	
1459 		if (pDBReqSave->nResult == 1 && pDBReqSave->dwID > 0 )
1460 		{
1461 			// 找到跨服国战信息记录
1462 			TMAP_CountryWorldWar::iterator iter = m_mapWorldWar.find(pDBReqSave->dwID);
1464 			if (iter!=m_mapWorldWar.end())
1684 		return false;
1685 	}
1686 	//添加或修改跨服国战信息 : 传入参数结构
1687 	DB_Param_Add_WorldCountryWar dbparam;	
1688 	// 条件参数
1687 	DB_Param_Add_WorldCountryWar dbparam;	
1688 	// 条件参数
1689 	dbparam.dwID					= SaveNodeData.dwID;									// 跨服国战信息ID，0为无效ID，为0则新增记录，否则就修改
1691 	// 存入的数据
1692 	dbparam.dwPublicWorldID			= SaveNodeData.dwPublicWorldID;						// 所属公共区世界ID
1693 	dbparam.dwStartTime				= SaveNodeData.dwStartTime;							// 开始时间
1694 	dbparam.dwEndTime				= SaveNodeData.dwEndTime;							// 结束时间
1695 	dbparam.dwType					= SaveNodeData.dwType;								// 跨服国战类型
1696 	dbparam.dwAttackWorldID			= SaveNodeData.dwAttackWorldID;						// 进攻国家所在游戏世界ID
1697 	dbparam.dwAttackCountryID		= SaveNodeData.dwAttackCountryID;					// 进攻国家ID
1725 	return true;
1726 }
1729 /** 加入跨服国战信息
1730 @param   DWORD dwStartTime			: 开始时间
1731 @param   DWORD dwFightTime			: 开战时间
1731 @param   DWORD dwFightTime			: 开战时间
1732 @param   DWORD dwEndTime			: 结束时间
1733 @param   DWORD dwType;				: 跨服国战类型 EMWarItemType
1734 @param   DWORD dwWarSceneID			: 战争场情景ID
1735 @param   DWORD dwAttackWorldID;		: 进攻国家所在游戏世界ID
1742 {
1743 	SCountryWorldWarInfoNode addNode;
1744 	addNode.dwID						= 0;									// 跨服国战信息ID，0为无效ID
1745 	addNode.dwPublicWorldID				= getThisGameWorldID();					// 所属公共区世界ID
1746 	addNode.dwStartTime					= dwStartTime;							// 开始时间
1746 	addNode.dwStartTime					= dwStartTime;							// 开始时间
1747 	addNode.dwEndTime					= dwEndTime;							// 结束时间
1748 	addNode.dwType						= dwType;								// 跨服国战类型 EMWarItemType
1749 	addNode.dwAttackWorldID				= dwAttackWorldID;						// 进攻国家所在游戏世界ID
1750 	addNode.dwAttackCountryID			= dwAttackCountryID;					// 进攻国家ID
1758 	return NewWorldWar(addNode);
1759 }
1761 /** 加入跨服国战盟国信息
1762 @param   DWORD dwMyWorldID;		: 本国家所在游戏世界ID
1763 @param   DWORD dwMyCountryID;	: 本国家ID
1859 	return true;
1860 }
1863 // 检查明天是否有跨服国战
1864 bool CWorldWar::CheckCountryWorldWar(DWORD dwFromWorldID,DWORD dwFromCountryID,DWORD dwWorldID,DWORD dwCountryID)
1865 {
1932 		if (node.dwStartTime>dwWeekStartTime && node.dwStartTime<dwWeekEndTime)
1933 		{
1934 			// 检查国家在跨服国战中的参战类型 0.无,1.攻,2.守,3.攻盟友,4.守盟友
1935 			DWORD dwMyJoinType = CheckCountryWorldWarType(dwFromWorldID,dwFromCountryID,node);	// 本国
1936 			DWORD dwJoinType = CheckCountryWorldWarType(dwWorldID,dwCountryID,node);			// 他国
1990 	
1991 	bool bRet = true;
1993 	// 检查明天已有跨服国战
1994 	if (dwMyFightCounts1+dwMyFightCounts2+dwMyFightCounts3>0)
1995 	{
1996 		bRet = false;
1997 	}
1998 	else if (dwFightCounts1+dwFightCounts2+dwFightCounts3>0)	// 检查明天已有跨服国战
1999 	{
2000 		bRet = false;
2002 	return bRet;
2004 }
2008 /** 取得跨服国家边境连通信息
2009 @return  SCountryWorldLinkInfo * 边境连通信息
2010 */
2020 	return &(iter->second);
2021 }
2023 /** 取得跨服国家边境连通信息
2024 @return  SCountryWorldLinkInfo * 边境连通信息
2025 */
2035 	return &(iter->second);
2036 }
2038 /** 跨服边境连通信息变化,保存入数据库
2039 @param   DWORD dwID:	边境连通信息ID
2040 @return  bool 成功否
2053 	DB_Param_Add_WorldCountryLink dbparam;
2054 	// 条件参数
2055 	dbparam.dwID				= node.dwID;								// 跨服国家边境连通信息ID，0为无效ID，找到就修改，否则就新增
2056 	// 存入的数据
2057 	dbparam.dwPublicWorldID		= node.dwPublicWorldID;						// 所属公共区世界ID
2056 	// 存入的数据
2057 	dbparam.dwPublicWorldID		= node.dwPublicWorldID;						// 所属公共区世界ID
2058 	dbparam.dwType				= node.dwType;								// 跨服国家边境类型
2059 	dbparam.dwWorldID			= node.dwWorldID;							// 国家所在游戏世界ID
2060 	dbparam.dwCountryID			= node.dwCountryID;							// 国家ID
2067 	return true;
2068 }
2070 /** 加入跨服边境连通信息
2071 @return   bool 成功否
2072 */
2081 	
2082 	SCountryWorldLinkInfo addNode;
2083 	addNode.dwID				= GetCountryWorldLinkKey(dwWorldID,dwCountryID,dwType);	// 跨服国家边境连通信息ID，(游戏世界ID,国家ID,类型)组合编号
2084 	addNode.dwPublicWorldID		=(DWORD)getThisGameWorldID();							// 所属公共区世界ID
2084 	addNode.dwPublicWorldID		=(DWORD)getThisGameWorldID();							// 所属公共区世界ID
2085 	addNode.dwType				= dwType;								// 跨服国家边境类型
2086 	addNode.dwWorldID			= dwWorldID;							// 国家所在游戏世界ID
2087 	addNode.dwCountryID			= dwCountryID;							// 国家ID
2163 	return true;
2164 }
2166 // 检查所有跨服国战记录有效性
2167 bool CWorldWar::CheckAllBadWorldCountryWar(void)
2168 {
2167 bool CWorldWar::CheckAllBadWorldCountryWar(void)
2168 {
2169 	// 读出检查跨服国战信息
2170 	ReadCheckBadWorldWar();
2172 	return true;
2172 	return true;
2173 }
2176 /** 加入跨服国战信息
2177 @return
2178 */
2201 	DBSVR::TWorldCountryWar& stItem = stReq.stItem;
2202 	// 条件参数
2203 	stItem.ID					= 0;												// 跨服国战信息ID，0为无效ID，为0则新增记录，否则就修改
2204 	// 存入的数据
2205 	stItem.dwPublicWorldID			= SaveNodeData.dwPublicWorldID;						// 所属公共区世界ID
2206 	stItem.dwStartTime				= SaveNodeData.dwStartTime;							// 开始时间
2207 	stItem.dwEndTime				= SaveNodeData.dwEndTime;							// 结束时间
2208 	stItem.dwType					= SaveNodeData.dwType;								// 跨服国战类型
2209 	stItem.dwAttackWorldID			= SaveNodeData.dwAttackWorldID;						// 进攻国家所在游戏世界ID
2210 	stItem.dwAttackCountryID		= SaveNodeData.dwAttackCountryID;					// 进攻国家ID
2250 	// 调式代码
2251 	char szBuf[512]={0};
2252 	sprintf_s(szBuf, _countof(szBuf),_NGT"CWorldWar::NewWorldWar() 加入跨服国战信息 m_dwMaxID=%d",m_dwMaxID);
2253 	TraceLn(szBuf);
2254 #endif
2258 	// 加入到Map中,历史数据ID为关键字,pair<TMAP_CountryWorldWar::iterator,bool> retPair=
2259 	m_mapTempWorldWar.insert(TMAP_CountryWorldWar::value_type(SaveNodeData.dwID,SaveNodeData));
2262 	//添加或修改跨服国战信息 : 传入参数结构
2263 	DB_Param_Add_WorldCountryWar dbParam;	
2264 	// 条件参数
2263 	DB_Param_Add_WorldCountryWar dbParam;	
2264 	// 条件参数
2265 	dbParam.dwID					= 0;												// 跨服国战信息ID，0为无效ID，为0则新增记录，否则就修改
2266 	// 存入的数据
2267 	dbParam.dwPublicWorldID			= SaveNodeData.dwPublicWorldID;						// 所属公共区世界ID
2268 	dbParam.dwStartTime				= SaveNodeData.dwStartTime;							// 开始时间
2269 	dbParam.dwEndTime				= SaveNodeData.dwEndTime;							// 结束时间
2270 	dbParam.dwType					= SaveNodeData.dwType;								// 跨服国战类型
2271 	dbParam.dwAttackWorldID			= SaveNodeData.dwAttackWorldID;						// 进攻国家所在游戏世界ID
2272 	dbParam.dwAttackCountryID		= SaveNodeData.dwAttackCountryID;					// 进攻国家ID
2299 		(LPCSTR)&dbParam,sizeof(DB_Param_Add_WorldCountryWar),static_cast<IDBRetSink *>(this) ,getThisGameWorldID() ))
2300 	{
2301 		Error("添加或修改跨服国战信息失败！ m_dwMaxID="<<SaveNodeData.dwID<<endl);
2303 		return false;
2304 	}
2314 	return m_bSaved;
2315 }
2318 /** 场景服 发送给 国家社会服 请求社会服跨服国战数据消息
2319 @name  : 处理发上来的执行请求 
2320 @param endpointId : 发送过来的端ID
2334 	//BuildServerSelf(endpointId);
2336 }
2338 /** 客户端 发送给 国家社会服 请求社会服跨服国战数据消息
2339 @name  : 处理发上来的执行请求 
2340 @param endpointId : 发送过来的端ID
2355 	//BuildClientSelf(endpointId);
2356 }
2359 /** 取得跨服国战信息
2360 @param   DWORD dwID:	跨服国战ID
2361 @return  SCountryWorldWarInfo 
2362 */
2363 SCountryWorldWarInfo * CWorldWar::GetWorldWarInfo( DWORD dwID)
2364 {
2365 	// 找到跨服国战ID记录
2366 	TMAP_CountryWorldWar::iterator iter = m_mapWorldWar.find(dwID);
2368 	if (iter==m_mapWorldWar.end())
2445 }
2447 /** 设定状态 
2448 @param   DWORD dwID:	跨服国战ID
2449 @param   DWORD dwState :状态 EMCountryWorldWarState
2450 @return  bool 成功否
2456 		return false;
2457 	}
2458 	// 找到跨服国战ID记录
2459 	TMAP_CountryWorldWar::iterator iter = m_mapWorldWar.find(dwID);
2461 	if (iter==m_mapWorldWar.end())
2473 	return true;
2474 }
2476 /** 跨服国战变化
2477 @param   DWORD dwID:	跨服国战ID
2478 @return  bool 成功否
2479 */
2480 bool CWorldWar::OnWorldWarInfoChanged(DWORD dwID)
2481 {
2482 	// 找到跨服国战ID记录
2483 	TMAP_CountryWorldWar::iterator iter = m_mapWorldWar.find(dwID);
2485 	if (iter==m_mapWorldWar.end())
2494 	return true;
2495 }
2499 // 跨服 更新国战记录信息
2500 void CWorldWar::OnBridgeMsgUpdateWarInfo(unsigned long actionId, SMsgBridgeHead &bridgeHead, SGameMsgHead* head, LPSTR data, size_t len)
2501 {
2572 	Link_MoveHead();
2574 }
2577 // 跨服 向公共服请求数据
2578 void CWorldWar::OnBridgeMsgRequestWarInfo(unsigned long actionId, SMsgBridgeHead &bridgeHead, SGameMsgHead* head, LPSTR data, size_t len)
2579 {
2580 	SendWorldWarToServer(bridgeHead.dwServerID,0);
2581 }
2583 // 检查国家在跨服国战中的参战类型
2584 DWORD CWorldWar::CheckCountryWorldWarType(DWORD dwWorldID,DWORD dwCountryID,SCountryWorldWarInfo &node)
2585 {
2608 	return 0;
2609 }
2611 // 取得跨服国家边境连通编号以(游戏世界ID+国家ID+类型)组数编号 为关键字
2612 DWORD CWorldWar::GetCountryWorldLinkKey(DWORD dwWorldID,DWORD dwCountryID,DWORD dwType)
2613 {
2651 	DBSVR::TMSG_DBSVR_COUNTRY_WORLDWAR_GET_RSP& stRsp = pstMsg->stTMSG_DBSVR_COUNTRY_WORLDWAR_GET_RSP;
2652 #ifdef TRACE_COUNTRY_DETAIL
2653 	TraceLn("CWorldWar::OnDBRet_ReadCountryWorldWar 查询跨服国战信息  Result=" << stRsp.Result << " nTotalCount=" << stRsp.nTotalCount);
2654 #endif
2656 	if (stRsp.Result != 0)
2656 	if (stRsp.Result != 0)
2657 	{
2658 		ErrorLn("读取跨服国战信息失败,  Result = "<< stRsp.Result << " Err=[" << g_ExternalFacade.GetDBSvrErrStr(stRsp.Result) << "]" );
2659 		return;
2660 	}
2661 	if (stRsp.nTotalCount < 1)
2662 	{
2663 		TraceLn("读取跨服国战信息数据条数为0，条数 = " << stRsp.nTotalCount );
2664 	}
2665 	m_dwMaxID = 0;
2684 		}
2685 		SCountryWorldWarInfoNode  stAddNode;
2687 		stAddNode.dwID					= dwID;									// 跨服国战信息ID，0为无效ID
2688 		stAddNode.dwPublicWorldID		= stItem.dwPublicWorldID;				// 所属公共区世界ID
2689 		stAddNode.dwStartTime			= stItem.dwStartTime;					// 开始时间
2689 		stAddNode.dwStartTime			= stItem.dwStartTime;					// 开始时间
2690 		stAddNode.dwEndTime				= stItem.dwEndTime;						// 结束时间
2691 		stAddNode.dwType				= stItem.dwType;						// 跨服国战类型
2692 		stAddNode.dwAttackWorldID		= stItem.dwAttackWorldID;				// 进攻国家所在游戏世界ID
2693 		stAddNode.dwAttackCountryID		= stItem.dwAttackCountryID;				// 进攻国家ID
2741 	DBSVR::TMSG_DBSVR_COUNTRY_WORLDWAR_ADD_RSP& stRsp = pstMsg->stTMSG_DBSVR_COUNTRY_WORLDWAR_ADD_RSP;
2742 #ifdef TRACE_COUNTRY_DETAIL
2743 	TraceLn("CWorldWar::OnDBRet_AddCountryWorldWar 添加跨服国战信息  Result=" << stRsp.Result << " ID=" << stRsp.ID);
2744 #endif
2745 	DWORD dwRecordID = stRsp.dwTmpID;
2747 	if (stRsp.Result != 0)
2748 	{
2749 		ErrorLn("添加修改跨服国战信息失败,  Result = "<< stRsp.Result << " Err=[" << g_ExternalFacade.GetDBSvrErrStr(stRsp.Result) << "]" );
2750 		m_mapTempWorldWar.erase(dwRecordID);
2751 		return;
2784 	DBSVR::TMSG_DBSVR_COUNTRY_WORLDWAR_UPD_RSP& stRsp = pstMsg->stTMSG_DBSVR_COUNTRY_WORLDWAR_UPD_RSP;
2785 #ifdef TRACE_COUNTRY_DETAIL
2786 	TraceLn("CWorldWar::OnDBRet_UpdateCountryWorldWar 批量保存跨服国战信息  Result=" << stRsp.Result << " nItemCount=" << stRsp.nItemCount);
2787 #endif
2788 	if (stRsp.Result != 0)
2788 	if (stRsp.Result != 0)
2789 	{
2790 		ErrorLn("批量保存跨服国战信息 失败,  Result = "<< stRsp.Result << " Err=[" << g_ExternalFacade.GetDBSvrErrStr(stRsp.Result) << "]" );
2791 		return;
2792 	}
2807 		{
2808 			DWORD dwID = (DWORD)stItem.ID;
2809 			// 找到跨服国战信息记录
2810 			TMAP_CountryWorldWar::iterator iter = m_mapWorldWar.find(dwID);
2812 			if (iter!=m_mapWorldWar.end())
2877 		DBSVR::TWorldCountryWar& stDbItem = stItemSet.data[nCount];
2878 		SCountryWorldWarInfoNode& stNode = iter->second;
2880 		stDbItem.ID						= stNode.dwID;								// 跨服国战信息数据ID，为记录ID，找到就修改，没有就无效
2881 		stDbItem.dwPublicWorldID		= stNode.dwPublicWorldID;					// 所属公共区世界ID
2882 		stDbItem.dwStartTime			= stNode.dwStartTime;						// 开始时间
2882 		stDbItem.dwStartTime			= stNode.dwStartTime;						// 开始时间
2883 		stDbItem.dwEndTime				= stNode.dwEndTime;							// 结束时间
2884 		stDbItem.dwType					= stNode.dwType;							// 跨服国战类型
2885 		stDbItem.dwAttackWorldID		= stNode.dwAttackWorldID;					// 进攻国家所在游戏世界ID
2886 		stDbItem.dwAttackCountryID		= stNode.dwAttackCountryID;					// 进攻国家ID
2941 	DBSVR::TMSG_DBSVR_COUNTRY_WORLDLINK_GET_RSP& stRsp = pstMsg->stTMSG_DBSVR_COUNTRY_WORLDLINK_GET_RSP;
2942 #ifdef TRACE_COUNTRY_DETAIL
2943 	TraceLn("CWorldWar::OnDBRet_ReadWorldLink 读取跨服国家边境连通信息  Result=" << stRsp.Result << " nTotalCount=" << stRsp.nTotalCount);
2944 #endif
2945 	if (stRsp.Result != 0)
2945 	if (stRsp.Result != 0)
2946 	{
2947 		ErrorLn("读取跨服国家边境连通信息 失败,  Result = "<< stRsp.Result << " Err=[" << g_ExternalFacade.GetDBSvrErrStr(stRsp.Result) << "]" );
2948 		return;
2949 	}
2950 	if (stRsp.nTotalCount < 1)
2951 	{
2952 		TraceLn("读取跨服国家边境连通信息数据条数为0，条数 = "<<stRsp.nTotalCount);
2953 	}
2955 	m_mapWorldLink.clear();
2963 		DBSVR::TWorldCountryLink& stDBItem = stItemSet.data[i];
2965 		SCountryWorldLinkInfo  stAddNode;
2967 		stAddNode.dwID					= stDBItem.dwID;									// 跨服国家边境连通信息ID，0为无效ID
2968 		stAddNode.dwPublicWorldID		= stDBItem.dwPublicWorldID;						// 所属公共区世界ID
2968 		stAddNode.dwPublicWorldID		= stDBItem.dwPublicWorldID;						// 所属公共区世界ID
2969 		stAddNode.dwType				= stDBItem.dwType;								// 跨服国家边境类型
2970 		stAddNode.dwWorldID				= stDBItem.dwWorldID;							// 国家所在游戏世界ID
2971 		stAddNode.dwCountryID			= stDBItem.dwCountryID;							// 国家ID
2981 		else
2982 		{
2983 			ErrorLn("读取跨服国家边境连通信息数据ID与内容不符，ID="<<stAddNode.dwID<<",dwKey = "<<dwKey);
2984 		}
2985 	}
2995 	DBSVR::TMSG_DBSVR_COUNTRY_WORLDLINK_ADD_RSP& stRsp = pstMsg->stTMSG_DBSVR_COUNTRY_WORLDLINK_ADD_RSP;
2996 #ifdef TRACE_COUNTRY_DETAIL
2997 	TraceLn("CWorldWar::OnDBRet_AddWorldLink 添加修改跨服国家边境连通信息  Result=" << stRsp.Result << " dwID=" << stRsp.dwID);
2998 #endif
2999 	if (stRsp.Result != 0)
2999 	if (stRsp.Result != 0)
3000 	{
3001 		ErrorLn("添加修改跨服国家边境连通信息失败！Result = "<< stRsp.Result << " Err=[" << g_ExternalFacade.GetDBSvrErrStr(stRsp.Result) << "]" );
3002 		return;
3003 	}

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\CountryService\WorldWar.cpp 100 KB CPP 文件 2014/2/25 14:31:02 2018/10/23 19:46:35 2018/10/23 19:46:35 157
5 ** 日  期:	2011-03-26
6 ** 版  本:	1.0
7 ** 描  述:	跨服国战系统部件
8 ** 应  用:  	
9 	
18 #include "WorldWar.h"
19 #include "CountryService.h"
23 // 跨服国战数据检查处理
24 CDBCheckBadWorldWar::CDBCheckBadWorldWar(void)
25 {
50 	switch(nCmdID)
51 	{
52 	case GAMEDB_REQUEST_WORLDCOUNTRY_WAR_READ:		// 查询跨服国战
53 		{
54 			OnDBReturn_ReadCheckBadWorldWar(nCmdID, nDBRetCode,pszDBRetDesc,nQueueIndex,pOutData,nOutLen);
59 	}
61 }
63 // 读出检查跨服国战信息
64 void CDBCheckBadWorldWar::OnDBReturn_ReadCheckBadWorldWar(int nCmdID, int nDBRetCode, char * pszDBRetDesc, int nQueueIndex, char * pOutData, int nOutLen)
65 {
74 	if(pOutData == NULL || nOutLen < sizeof(DB_Result_Read_WorldCountryWar))
75 	{
76 		ErrorLn("读出检查跨服国战信息数据大小非法，nOutLen = "<<nOutLen);
78 		return;		
79 	}
90 	if(nOutLen != (int)(pResult->nRecordCount * sizeof(DB_Table_WorldCountryWar) + sizeof(DB_Result_Read_WorldCountryWar)) )
91 	{
92 		ErrorLn("读出检查跨服国战信息数据条数与大小不符，nOutLen = "<<nOutLen);
93 		return;
94 	}
95 	if (pResult->nRecordCount<1)
96 	{
97 		TraceLn("读出检查跨服国战信息数据条数为0，条数 = "<<pResult->nRecordCount);
98 	}
100 	DWORD dwNowTimes = (DWORD)time(NULL);
106 		dwPublicWorldID = getThisGameWorldID();
107 	}
110 	// 临时跨服国战对象列表
111 	TMAP_CountryWorldWar mapWorldWar;
113 	DB_Table_WorldCountryWar * pDBReq = (DB_Table_WorldCountryWar *)(pOutData + sizeof(DB_Result_Read_WorldCountryWar));
117 	{
119 		SCountryWorldWarInfoNode  addNode;
121 		addNode.dwID					= pDBReq->dwID;									// 跨服国战信息ID，0为无效ID
122 		addNode.dwPublicWorldID			= pDBReq->dwPublicWorldID;						// 所属公共区世界ID
123 		addNode.dwStartTime				= pDBReq->dwStartTime;							// 开始时间
123 		addNode.dwStartTime				= pDBReq->dwStartTime;							// 开始时间
124 		addNode.dwEndTime				= pDBReq->dwEndTime;							// 结束时间
125 		addNode.dwType					= pDBReq->dwType;								// 跨服国战类型
126 		addNode.dwAttackWorldID			= pDBReq->dwAttackWorldID;						// 进攻国家所在游戏世界ID
127 		addNode.dwAttackCountryID		= pDBReq->dwAttackCountryID;					// 进攻国家ID
156 			addNode.dwState = CountryWorldWarState_None;
157 		}
159 		// 放入临时跨服国战对象列表
160 		mapWorldWar[addNode.dwID]	= addNode;
163 #ifdef COUNTRY_PRINT_DEBUG_INF
163 #ifdef COUNTRY_PRINT_DEBUG_INF
164 		// 调式代码
165 		sprintf_s(szBuf, _countof(szBuf),_NGT"%d.ID=%d,公共区世界ID=%d,开始时间=%d,结束时间=%d,跨服国战类型=%d,进攻世界ID=%d,进攻国家ID=%d,防御世界ID=%d,防御国家ID=%d,状态=%d,结果标识=%d,参数={%d,%d,%d,%d,%d}",
166 			i,addNode.dwID,addNode.dwPublicWorldID,addNode.dwStartTime,addNode.dwEndTime,addNode.dwType,addNode.dwAttackWorldID,addNode.dwAttackCountryID,addNode.dwDefendWorldID,addNode.dwDefendCountryID,
167 			addNode.dwState,addNode.dwResultFlag,addNode.dwData1,addNode.dwData2,addNode.dwData3,addNode.dwData4,addNode.dwData5);
205 				if (NULL==pBridgePart)
206 				{
207 					sprintf_s(szBuf, sizeof(szBuf), "跨服国战记录中的游戏区(%d)不存在! 记录ID=%d,所属公共区ID=%d,开始时间=%s,类型=%d,进攻世界ID=%d,进攻国家ID=%d,防御世界ID=%d,防御国家ID=%d,状态=%d",
208 						dwCheckWorldID,node.dwID,node.dwPublicWorldID,g_ExternalFacade.GetTimeString(node.dwStartTime),node.dwType,node.dwAttackWorldID,node.dwAttackCountryID,node.dwDefendWorldID,node.dwDefendCountryID,node.dwState);
210 					// 报警对应区没开
223 		if (node.dwPublicWorldID!=dwPublicWorldID)
224 		{
225 			sprintf_s(szBuf, sizeof(szBuf), "跨服国战记录中的所属公共游戏区(%d)与实际所连入的公共区(%d)不符! 记录ID=%d,所属公共区ID=%d,开始时间=%s,类型=%d,进攻世界ID=%d,进攻国家ID=%d,防御世界ID=%d,防御国家ID=%d,状态=%d",
226 				node.dwPublicWorldID,dwPublicWorldID,node.dwID,node.dwPublicWorldID,g_ExternalFacade.GetTimeString(node.dwStartTime),node.dwType,node.dwAttackWorldID,node.dwAttackCountryID,node.dwDefendWorldID,node.dwDefendCountryID,node.dwState);
228 			// 报警对应区没开
257 	DBSVR::TMSG_DBSVR_COUNTRY_WORLDWAR_GET_RSP& stRsp = pstMsg->stTMSG_DBSVR_COUNTRY_WORLDWAR_GET_RSP;
258 #ifdef TRACE_COUNTRY_DETAIL
259 	TraceLn("CDBCheckBadWorldWar::OnDBRet_ReadCheckBadCountryWorldWar 读出检查跨服国战信息  Result=" << stRsp.Result << " nTotalCount=" << stRsp.nTotalCount);
260 #endif
261 	if (stRsp.Result != 0)
261 	if (stRsp.Result != 0)
262 	{
263 		ErrorLn("读出检查跨服国战信息 失败,  Result = "<< stRsp.Result << " Err=[" << g_ExternalFacade.GetDBSvrErrStr(stRsp.Result) << "]" );
264 		return;
265 	}
273 	if (stRsp.nTotalCount < 1)
274 	{
275 		TraceLn("读出检查跨服国战信息数据条数为0，条数 = "<< stRsp.nTotalCount);
276 	}
278 	DWORD dwNowTimes = (DWORD)time(NULL);
284 		dwPublicWorldID = getThisGameWorldID();
285 	}
286 	// 临时跨服国战对象列表
287 	TMAP_CountryWorldWar mapWorldWar;
289 	DBSVR::TCountryWorldWarList_Set& stItemSet = stRsp.stItemSet;
296 		DWORD dwID = (DWORD)stItem.ID;
298 		SCountryWorldWarInfoNode  stAddNode;
300 		stAddNode.dwID					= dwID;									// 跨服国战信息ID，0为无效ID
301 		stAddNode.dwPublicWorldID		= stItem.dwPublicWorldID;						// 所属公共区世界ID
302 		stAddNode.dwStartTime			= stItem.dwStartTime;							// 开始时间
302 		stAddNode.dwStartTime			= stItem.dwStartTime;							// 开始时间
303 		stAddNode.dwEndTime				= stItem.dwEndTime;							// 结束时间
304 		stAddNode.dwType				= stItem.dwType;								// 跨服国战类型
305 		stAddNode.dwAttackWorldID		= stItem.dwAttackWorldID;						// 进攻国家所在游戏世界ID
306 		stAddNode.dwAttackCountryID		= stItem.dwAttackCountryID;					// 进攻国家ID
335 			stAddNode.dwState = CountryWorldWarState_None;
336 		}
338 		// 放入临时跨服国战对象列表
339 		mapWorldWar[stAddNode.dwID]	= stAddNode;
340 	}
370 				if (NULL==pBridgePart)
371 				{
372 					sprintf_s(szBuf, sizeof(szBuf), "跨服国战记录中的游戏区(%d)不存在! 记录ID=%d,所属公共区ID=%d,开始时间=%s,类型=%d,进攻世界ID=%d,进攻国家ID=%d,防御世界ID=%d,防御国家ID=%d,状态=%d",
373 						dwCheckWorldID,node.dwID,node.dwPublicWorldID,g_ExternalFacade.GetTimeString(node.dwStartTime),node.dwType,node.dwAttackWorldID,node.dwAttackCountryID,node.dwDefendWorldID,node.dwDefendCountryID,node.dwState);
375 					// 报警对应区没开
388 		if (node.dwPublicWorldID != dwPublicWorldID)
389 		{
390 			sprintf_s(szBuf, sizeof(szBuf), "跨服国战记录中的所属公共游戏区(%d)与实际所连入的公共区(%d)不符! 记录ID=%d,所属公共区ID=%d,开始时间=%s,类型=%d,进攻世界ID=%d,进攻国家ID=%d,防御世界ID=%d,防御国家ID=%d,状态=%d",
391 				node.dwPublicWorldID,dwPublicWorldID,node.dwID,node.dwPublicWorldID,g_ExternalFacade.GetTimeString(node.dwStartTime),node.dwType,node.dwAttackWorldID,node.dwAttackCountryID,node.dwDefendWorldID,node.dwDefendCountryID,node.dwState);
393 			// 报警对应区没开
443 	if (gGlobalCountryServer->IsCanOpenWorldWar())
444 	{
445 		// 查询跨服国战
446 		DB_Param_Read_WorldCountryWar dbParam;
446 		DB_Param_Read_WorldCountryWar dbParam;
447 		dbParam.dwID				= 0;							// 跨服国战信息ID，0为忽略
448 		dbParam.dwPublicWorldID		= (DWORD)getThisGameWorldID();				// 所属公共区世界ID，0为忽略
449 		dbParam.dwDays				= 30;						// 只读出最近多少天的记录，0为忽略
450 		dbParam.dwMaxCounts			= 600;						// 只读出最新多少条的记录，0为忽略	
451 		ReadWorldWar(dbParam);
453 		// 查询跨服国家边境连通信息
454 		DB_Param_Read_WorldCountryLink dbLink;
454 		DB_Param_Read_WorldCountryLink dbLink;
455 		dbLink.dwID				= 0;							// 跨服国战信息ID，0为忽略
456 		dbLink.dwPublicWorldID	= (DWORD)getThisGameWorldID();	// 所属公共区世界ID，0为忽略
457 		ReadWorldLink(dbLink);
631 		m_bSaved = true;
632 	}
634 	// 向数据库读取跨服国战信息记录
635 	IDBEngine * pDBEngine = g_ExternalFacade.GetDBEngine();
636 	if(pDBEngine == NULL)
638 		return;
639 	}
641 	// GAMEDB_REQUEST_COUNTRYOFFICER_SAVE 批量保存跨服国战信息 : 传入参数结构
642 	DB_Param_Save_WorldCountryWar dbParam;
644 	int nRecordCounts		= 0;					// 要保存记录数
646 	int nSaveDataSize		= sizeof(dbParam.szSaveData);					// 存入的数据长度
648 	ofixbuf obuf( (char*)dbParam.szSaveData, sizeof(dbParam.szSaveData));		// 存入的数据
650 	// 修改跨服国战信息 : 传入参数结构
651 	DB_Table_WorldCountryWar recordData;
653 	// 遍历所有记录
664 			}
666 			nRecordCounts++;		// 要保存记录数
668 			recordData.dwID						= iter->second.dwID;								// 跨服国战信息数据ID，为记录ID，找到就修改，没有就无效
669 			recordData.dwPublicWorldID			= iter->second.dwPublicWorldID;						// 所属公共区世界ID
670 			recordData.dwStartTime				= iter->second.dwStartTime;							// 开始时间
670 			recordData.dwStartTime				= iter->second.dwStartTime;							// 开始时间
671 			recordData.dwEndTime				= iter->second.dwEndTime;							// 结束时间
672 			recordData.dwType					= iter->second.dwType;								// 跨服国战类型
673 			recordData.dwAttackWorldID			= iter->second.dwAttackWorldID;						// 进攻国家所在游戏世界ID
674 			recordData.dwAttackCountryID		= iter->second.dwAttackCountryID;					// 进攻国家ID
745 	// 调式代码
746 	char szBuf[256]={0};
747 	sprintf_s(szBuf, _countof(szBuf),_NGT"CWorldWar::OnDataChanged() 跨服国战信息数据变更 m_bSaved=%d",m_bSaved);
748 	TraceLn(szBuf);
749 #endif
770 	switch(dwTimerID)
771 	{
772 	case ETimerEventID_DB_Read:			// 查询跨服国战
773 		{
774 			// kill timer
777 			if (gGlobalCountryServer->IsCanOpenWorldWar())
778 			{
779 				// 查询跨服国战
780 				DB_Param_Read_WorldCountryWar dbParam;
780 				DB_Param_Read_WorldCountryWar dbParam;
781 				dbParam.dwID				= 0;							// 跨服国战信息ID，0为忽略
782 				dbParam.dwPublicWorldID		= (DWORD)getThisGameWorldID();				// 所属公共区世界ID，0为忽略
783 				dbParam.dwDays				= 30;						// 只读出最近多少天的记录，0为忽略
811 	switch(nCmdID)
812 	{
813 	case GAMEDB_REQUEST_WORLDCOUNTRY_WAR_READ:		// 查询跨服国战
814 		{
815 			OnDBReturn_ReadWorldWar(nCmdID, nDBRetCode,pszDBRetDesc,nQueueIndex,pOutData,nOutLen);
816 		}
817 		break;
819 	case GAMEDB_REQUEST_WORLDCOUNTRY_WAR_ADD:		// 添加跨服国战
820 		{
821 			OnDBReturn_AddWorldWar(nCmdID, nDBRetCode,pszDBRetDesc,nQueueIndex,pOutData,nOutLen);
822 		}
823 		break;
825 	case GAMEDB_REQUEST_WORLDCOUNTRY_WAR_SAVE:		// 批量保存跨服国战信息
826 		{
827 			OnDBReturn_SaveWorldWar(nCmdID, nDBRetCode,pszDBRetDesc,nQueueIndex,pOutData,nOutLen);
828 		}
829 		break;
831 	case GAMEDB_REQUEST_WORLDCOUNTRY_LINK_READ:		// 查询跨服国家边境连通信息
832 		{
833 			OnDBReturn_ReadWorldLink(nCmdID, nDBRetCode,pszDBRetDesc,nQueueIndex,pOutData,nOutLen);
834 		}
835 		break;
837 	case GAMEDB_REQUEST_WORLDCOUNTRY_LINK_ADD:		// 添加跨服国家边境连通信息
838 		{
839 			OnDBReturn_AddWorldLink(nCmdID, nDBRetCode,pszDBRetDesc,nQueueIndex,pOutData,nOutLen);
850 //////////////////////////////////////////////////////////////////////////
852 /**
853 @purpose          : 读出检查跨服国战信息
854 @return		      : void
855 */
886 	}
888 	DB_Param_Read_WorldCountryWar dbParam;
889 	dbParam.dwID				= 0;						// 跨服国战信息ID，0为忽略
890 	dbParam.dwPublicWorldID		= 0;						// 所属公共区世界ID，0为忽略
891 	dbParam.dwDays				= 5;						// 只读出最近多少天的记录，0为忽略
895 		(LPCSTR)&dbParam,sizeof(DB_Param_Read_WorldCountryWar),static_cast<IDBRetSink *>(&m_DbCheckBadRet) ,getThisGameWorldID() ))
896 	{
897 		Error("读出检查跨服国战信息失败！ dwID="<<dbParam.dwID<<endl);
899 		return;
900 	}
902 }
905 /**
906 @purpose          : 查询跨服国战信息
907 @param	 DB_Param_Read_CountryWorldWar param: 查询跨服国战信息  : 传入参数结构
908 @return		      : void
909 */
946 		(LPCSTR)&dbParam,sizeof(DB_Param_Read_WorldCountryWar),static_cast<IDBRetSink *>(this) ,getThisGameWorldID() ))
947 	{
948 		Error("读取跨服国战信息失败！ dwID="<<dbParam.dwID<<endl);
950 		return;
951 	}
953 }
955 /**
956 @purpose          : 添加或修改跨服国战信息
957 @param	 DB_Param_Add_CountryWorldWar param: 添加或修改跨服国战信息 : 传入参数结构
958 @return		      : void
959 */
981 		(LPCSTR)&dbParam,sizeof(DB_Param_Add_WorldCountryWar),static_cast<IDBRetSink *>(this) ,getThisGameWorldID() ))
982 	{
983 		Error("添加或修改跨服国战信息失败！ dwMapID="<<dbParam.dwID<<endl);
985 		return;
986 	}
987 }
990 /**
991 @purpose          : 查询跨服国家边境连通信息
992 @param	 DB_Param_Read_WorldCountryLink param: 查询跨服国家边境连通信息  : 传入参数结构
993 @return		      : void
994 */
1029 		(LPCSTR)&dbParam,sizeof(DB_Param_Read_WorldCountryLink),static_cast<IDBRetSink *>(this) ,getThisGameWorldID() ))
1030 	{
1031 		Error("读取跨服国家边境连通信息失败！ dwID="<<dbParam.dwID<<endl);
1033 		return;
1034 	}
1036 }
1038 /**
1039 @purpose          : 添加或修改跨服国家边境连通信息
1040 @param	 DB_Param_Add_WorldCountryLink param: 添加或修改跨服国家边境连通信息 : 传入参数结构
1041 @return		      : void
1042 */
1059 	DBSVR::TWorldCountryLink& stItem = stReq.stItem;
1060 	
1061 	stItem.dwID				= param.dwID;								// 跨服国家边境连通信息ID，0为无效ID，找到就修改，否则就新增
1062 	// 存入的数据
1063 	stItem.dwPublicWorldID		= param.dwPublicWorldID;					// 所属公共区世界ID
1062 	// 存入的数据
1063 	stItem.dwPublicWorldID		= param.dwPublicWorldID;					// 所属公共区世界ID
1064 	stItem.dwType				= param.dwType;								// 跨服国家边境类型
1065 	stItem.dwWorldID			= param.dwWorldID;							// 国家所在游戏世界ID
1066 	stItem.dwCountryID			= param.dwCountryID;							// 国家ID
1088 		(LPCSTR)&dbParam,sizeof(DB_Param_Add_WorldCountryLink),static_cast<IDBRetSink *>(this) ,getThisGameWorldID() ))
1089 	{
1090 		Error("添加或修改跨服国家边境连通信息失败！ dwMapID="<<dbParam.dwID<<endl);
1092 		return;
1093 	}*/
1093 	}*/
1094 }
1098 /** 数据库请求返回回调方法 GAMEDB_REQUEST_WORLDCOUNTRY_LINK_READ   查询跨服国家边境连通信息
1099 @retval buffer 
1100 */	
1105 	// 调式代码
1106 	char szBuf[256]={0};
1107 	sprintf_s(szBuf, _countof(szBuf),_NGT"CWorldWar::OnDBReturn_ReadWorldLink() 查询跨服国家边境连通信息 nCmdID=%d,nDBRetCode=%d,nQueueIndex=%d,nOutLen=%d",
1108 		nCmdID,nDBRetCode,nQueueIndex,nOutLen);
1109 	TraceLn(szBuf);
1112 	if(pOutData == NULL || nOutLen < sizeof(DB_Result_Read_WorldCountryLink))
1113 	{
1114 		ErrorLn("读取跨服国家边境连通信息数据大小非法，nOutLen = "<<nOutLen);
1116 		return;		
1117 	}
1128 	if(nOutLen != (int)(pResult->nRecordCount * sizeof(DB_Table_WorldCountryLink) + sizeof(DB_Result_Read_WorldCountryLink)) )
1129 	{
1130 		ErrorLn("读取跨服国家边境连通信息数据条数与大小不符，nOutLen = "<<nOutLen);
1131 		return;
1132 	}
1133 	if (pResult->nRecordCount<1)
1134 	{
1135 		TraceLn("读取跨服国家边境连通信息数据条数为0，条数 = "<<pResult->nRecordCount);
1136 	}
1138 	m_mapWorldLink.clear();
1144 	{
1146 		SCountryWorldLinkInfo  addNode;
1148 		addNode.dwID					= pDBReq->dwID;									// 跨服国家边境连通信息ID，0为无效ID
1149 		addNode.dwPublicWorldID			= pDBReq->dwPublicWorldID;						// 所属公共区世界ID
1149 		addNode.dwPublicWorldID			= pDBReq->dwPublicWorldID;						// 所属公共区世界ID
1150 		addNode.dwType					= pDBReq->dwType;								// 跨服国家边境类型
1151 		addNode.dwWorldID				= pDBReq->dwWorldID;							// 国家所在游戏世界ID
1152 		addNode.dwCountryID				= pDBReq->dwCountryID;							// 国家ID
1162 		else
1163 		{
1164 			ErrorLn("读取跨服国家边境连通信息数据ID与内容不符，ID="<<addNode.dwID<<",dwKey = "<<dwKey);
1165 		}
1167 #ifdef COUNTRY_PRINT_DEBUG_INF
1167 #ifdef COUNTRY_PRINT_DEBUG_INF
1168 		// 调式代码
1169 		sprintf_s(szBuf, _countof(szBuf),_NGT"%d.ID=%d,公共区世界ID=%d,跨服国家边境连通类型=%d,世界ID=%d,国家ID=%d,连通国家世界ID=%d,连通国家ID=%d,状态=%d",
1170 			i,addNode.dwID,addNode.dwPublicWorldID,addNode.dwType,addNode.dwWorldID,addNode.dwCountryID,addNode.dwLinkWorldID,addNode.dwLinkCountryID,addNode.dwFlag);
1171 		TraceLn(szBuf);
1182 	SendWorldWarToServer(0,0);
1183 }
1185 /** 数据库请求返回回调方法 GAMEDB_REQUEST_WORLDCOUNTRY_LINK_ADD  添加跨服国家边境连通信息
1186 @retval buffer 
1187 */	
1192 	// 调式代码
1193 	char szBuf[256]={0};
1194 	sprintf_s(szBuf, _countof(szBuf),_NGT"CWorldWar::OnDBReturn_AddWorldLink() 添加跨服国家边境连通信息 nCmdID=%d,nDBRetCode=%d,nQueueIndex=%d,nOutLen=%d",
1195 		nCmdID,nDBRetCode,nQueueIndex,nOutLen);
1196 	TraceLn(szBuf);
1199 	if(pOutData == NULL || nOutLen != sizeof(DB_Result_Add_WorldCountryLink))
1200 	{
1201 		ErrorLn("添加修改跨服国家边境连通信息返回数据大小非法，nOutLen = "<<nOutLen);
1202 		return;		
1203 	}
1203 	}
1204 	DB_Result_Add_WorldCountryLink * pResult = (DB_Result_Add_WorldCountryLink *)(pOutData);
1206 	// 跨服国家边境连通信息ID, 0为无效ID
1207 	// 结果 0:出错,没有新增或修改; 1:新增成功,2:修改成功
1208 	if (pResult->nResult==0)
1208 	if (pResult->nResult==0)
1209 	{
1210 		ErrorLn("添加修改跨服国家边境连通信息失败！nResult="<<pResult->nResult);
1211 		return;
1212 	}
1212 	}
1213 }
1217 /** 数据库请求返回回调方法 GAMEDB_REQUEST_WORLDCOUNTRY_WAR_READ   查询跨服国战信息
1218 @retval buffer 
1219 */	
1224 	// 调式代码
1225 	char szBuf[256]={0};
1226 	sprintf_s(szBuf, _countof(szBuf),_NGT"CWorldWar::OnDBReturn_ReadWorldWar() 查询跨服国战信息 nCmdID=%d,nDBRetCode=%d,nQueueIndex=%d,nOutLen=%d",
1227 		nCmdID,nDBRetCode,nQueueIndex,nOutLen);
1228 	TraceLn(szBuf);
1231 	if(pOutData == NULL || nOutLen < sizeof(DB_Result_Read_WorldCountryWar))
1232 	{
1233 		ErrorLn("读取跨服国战信息数据大小非法，nOutLen = "<<nOutLen);
1235 		return;		
1236 	}
1247 	if(nOutLen != (int)(pResult->nRecordCount * sizeof(DB_Table_WorldCountryWar) + sizeof(DB_Result_Read_WorldCountryWar)) )
1248 	{
1249 		ErrorLn("读取跨服国战信息数据条数与大小不符，nOutLen = "<<nOutLen);
1250 		return;
1251 	}
1252 	if (pResult->nRecordCount<1)
1253 	{
1254 		TraceLn("读取跨服国战信息数据条数为0，条数 = "<<pResult->nRecordCount);
1255 	}
1256 	m_dwMaxID = 0;
1271 		}
1273 		SCountryWorldWarInfoNode  addNode;
1275 		addNode.dwID					= pDBReq->dwID;									// 跨服国战信息ID，0为无效ID
1276 		addNode.dwPublicWorldID			= pDBReq->dwPublicWorldID;						// 所属公共区世界ID
1277 		addNode.dwStartTime				= pDBReq->dwStartTime;							// 开始时间
1277 		addNode.dwStartTime				= pDBReq->dwStartTime;							// 开始时间
1278 		addNode.dwEndTime				= pDBReq->dwEndTime;							// 结束时间
1279 		addNode.dwType					= pDBReq->dwType;								// 跨服国战类型
1280 		addNode.dwAttackWorldID			= pDBReq->dwAttackWorldID;						// 进攻国家所在游戏世界ID
1281 		addNode.dwAttackCountryID		= pDBReq->dwAttackCountryID;					// 进攻国家ID
1319 #ifdef COUNTRY_PRINT_DEBUG_INF
1320 		// 调式代码
1321 		sprintf_s(szBuf, _countof(szBuf),_NGT"%d.ID=%d,公共区世界ID=%d,开始时间=%d,结束时间=%d,跨服国战类型=%d,进攻世界ID=%d,进攻国家ID=%d,防御世界ID=%d,防御国家ID=%d,状态=%d,结果标识=%d,参数={%d,%d,%d,%d,%d}",
1322 			i,addNode.dwID,addNode.dwPublicWorldID,addNode.dwStartTime,addNode.dwEndTime,addNode.dwType,addNode.dwAttackWorldID,addNode.dwAttackCountryID,addNode.dwDefendWorldID,addNode.dwDefendCountryID,
1323 			addNode.dwState,addNode.dwResultFlag,addNode.dwData1,addNode.dwData2,addNode.dwData3,addNode.dwData4,addNode.dwData5);
1337 	SendWorldWarToServer(0,0);
1338 }
1340 /** 数据库请求返回回调方法 GAMEDB_REQUEST_WORLDCOUNTRY_WAR_ADD  添加跨服国战信息
1341 @retval buffer 
1342 */	
1347 	// 调式代码
1348 	char szBuf[256]={0};
1349 	sprintf_s(szBuf, _countof(szBuf),_NGT"CWorldWar::OnDBReturn_AddWorldWar() 添加跨服国战信息 nCmdID=%d,nDBRetCode=%d,nQueueIndex=%d,nOutLen=%d",
1350 		nCmdID,nDBRetCode,nQueueIndex,nOutLen);
1351 	TraceLn(szBuf);
1354 	if(pOutData == NULL || nOutLen != sizeof(DB_Result_Add_WorldCountryWar))
1355 	{
1356 		ErrorLn("添加修改跨服国战信息返回数据大小非法，nOutLen = "<<nOutLen);
1357 		return;		
1358 	}
1358 	}
1359 	DB_Result_Add_WorldCountryWar * pResult = (DB_Result_Add_WorldCountryWar *)(pOutData);
1361 	// 跨服国战信息ID, 0为无效ID
1362 	// 结果 0:出错,没有新增或修改; 1:新增成功,2:修改成功
1363 	if (pResult->nResult==0)
1363 	if (pResult->nResult==0)
1364 	{
1365 		ErrorLn("添加修改跨服国战信息失败！nResult="<<pResult->nResult);
1366 		return;
1367 	}
1404 #ifdef COUNTRY_PRINT_DEBUG_INF
1405 	// 调式代码
1406 	sprintf_s(szBuf, _countof(szBuf),_NGT"添加修改跨服国战信息成功！ dwID=%d,nQueueIndex=%d,nResult=%d",iter->second.dwID,nQueueIndex,pResult->nResult);
1407 	TraceLn(szBuf);
1408 #endif
1408 #endif
1410 }
1413 /** 数据库请求返回回调方法 GAMEDB_REQUEST_WORLDCOUNTRY_WAR_SAVE  批量保存跨服国战信息
1414 @retval buffer 
1415 */	
1420 	// 调式代码
1421 	char szBuf[256]={0};
1422 	sprintf_s(szBuf, _countof(szBuf),_NGT"CWorldWar::OnDBReturn_SaveWorldWar() 批量保存跨服国战信息 nCmdID=%d,nDBRetCode=%d,nQueueIndex=%d,nOutLen=%d",
1423 		nCmdID,nDBRetCode,nQueueIndex,nOutLen);
1424 	TraceLn(szBuf);
1427 	if(pOutData == NULL || nOutLen < sizeof(DB_Result_Save_WorldCountryWar))
1428 	{
1429 		ErrorLn("批量保存跨服国战信息返回数据大小非法，nOutLen = "<<nOutLen);
1431 		return;		
1432 	}
1435 	if(nOutLen != pResult->nRecordCount * sizeof(DB_Result_Save_WorldCountryWar_Record) + sizeof(DB_Result_Save_WorldCountryWar))
1436 	{
1437 		ErrorLn("批量保存跨服国战信息返回数据条数与大小不符，nOutLen = "<<nOutLen);
1438 		return;
1439 	}
1440 	if (pResult->nRecordCount<1)
1441 	{
1442 		//TraceLn("批量保存跨服国战信息返回数据条数为0，条数 = "<<pResult->nRecordCount);
1443 		return;
1444 	}
1452 #ifdef COUNTRY_PRINT_DEBUG_INF
1453 		// 调式代码
1454 		sprintf_s(szBuf, _countof(szBuf),_NGT"批量保存跨服国战信息结果:%d. dwMapID=%d,nResult=%d",i,pDBReqSave->dwMapID,pDBReqSave->nResult);
1455 		TraceLn(szBuf);
1456 #endif	
1459 		if (pDBReqSave->nResult == 1 && pDBReqSave->dwID > 0 )
1460 		{
1461 			// 找到跨服国战信息记录
1462 			TMAP_CountryWorldWar::iterator iter = m_mapWorldWar.find(pDBReqSave->dwID);
1464 			if (iter!=m_mapWorldWar.end())
1684 		return false;
1685 	}
1686 	//添加或修改跨服国战信息 : 传入参数结构
1687 	DB_Param_Add_WorldCountryWar dbparam;	
1688 	// 条件参数
1687 	DB_Param_Add_WorldCountryWar dbparam;	
1688 	// 条件参数
1689 	dbparam.dwID					= SaveNodeData.dwID;									// 跨服国战信息ID，0为无效ID，为0则新增记录，否则就修改
1691 	// 存入的数据
1692 	dbparam.dwPublicWorldID			= SaveNodeData.dwPublicWorldID;						// 所属公共区世界ID
1693 	dbparam.dwStartTime				= SaveNodeData.dwStartTime;							// 开始时间
1694 	dbparam.dwEndTime				= SaveNodeData.dwEndTime;							// 结束时间
1695 	dbparam.dwType					= SaveNodeData.dwType;								// 跨服国战类型
1696 	dbparam.dwAttackWorldID			= SaveNodeData.dwAttackWorldID;						// 进攻国家所在游戏世界ID
1697 	dbparam.dwAttackCountryID		= SaveNodeData.dwAttackCountryID;					// 进攻国家ID
1725 	return true;
1726 }
1729 /** 加入跨服国战信息
1730 @param   DWORD dwStartTime			: 开始时间
1731 @param   DWORD dwFightTime			: 开战时间
1731 @param   DWORD dwFightTime			: 开战时间
1732 @param   DWORD dwEndTime			: 结束时间
1733 @param   DWORD dwType;				: 跨服国战类型 EMWarItemType
1734 @param   DWORD dwWarSceneID			: 战争场情景ID
1735 @param   DWORD dwAttackWorldID;		: 进攻国家所在游戏世界ID
1742 {
1743 	SCountryWorldWarInfoNode addNode;
1744 	addNode.dwID						= 0;									// 跨服国战信息ID，0为无效ID
1745 	addNode.dwPublicWorldID				= getThisGameWorldID();					// 所属公共区世界ID
1746 	addNode.dwStartTime					= dwStartTime;							// 开始时间
1746 	addNode.dwStartTime					= dwStartTime;							// 开始时间
1747 	addNode.dwEndTime					= dwEndTime;							// 结束时间
1748 	addNode.dwType						= dwType;								// 跨服国战类型 EMWarItemType
1749 	addNode.dwAttackWorldID				= dwAttackWorldID;						// 进攻国家所在游戏世界ID
1750 	addNode.dwAttackCountryID			= dwAttackCountryID;					// 进攻国家ID
1758 	return NewWorldWar(addNode);
1759 }
1761 /** 加入跨服国战盟国信息
1762 @param   DWORD dwMyWorldID;		: 本国家所在游戏世界ID
1763 @param   DWORD dwMyCountryID;	: 本国家ID
1859 	return true;
1860 }
1863 // 检查明天是否有跨服国战
1864 bool CWorldWar::CheckCountryWorldWar(DWORD dwFromWorldID,DWORD dwFromCountryID,DWORD dwWorldID,DWORD dwCountryID)
1865 {
1932 		if (node.dwStartTime>dwWeekStartTime && node.dwStartTime<dwWeekEndTime)
1933 		{
1934 			// 检查国家在跨服国战中的参战类型 0.无,1.攻,2.守,3.攻盟友,4.守盟友
1935 			DWORD dwMyJoinType = CheckCountryWorldWarType(dwFromWorldID,dwFromCountryID,node);	// 本国
1936 			DWORD dwJoinType = CheckCountryWorldWarType(dwWorldID,dwCountryID,node);			// 他国
1990 	
1991 	bool bRet = true;
1993 	// 检查明天已有跨服国战
1994 	if (dwMyFightCounts1+dwMyFightCounts2+dwMyFightCounts3>0)
1995 	{
1996 		bRet = false;
1997 	}
1998 	else if (dwFightCounts1+dwFightCounts2+dwFightCounts3>0)	// 检查明天已有跨服国战
1999 	{
2000 		bRet = false;
2002 	return bRet;
2004 }
2008 /** 取得跨服国家边境连通信息
2009 @return  SCountryWorldLinkInfo * 边境连通信息
2010 */
2020 	return &(iter->second);
2021 }
2023 /** 取得跨服国家边境连通信息
2024 @return  SCountryWorldLinkInfo * 边境连通信息
2025 */
2035 	return &(iter->second);
2036 }
2038 /** 跨服边境连通信息变化,保存入数据库
2039 @param   DWORD dwID:	边境连通信息ID
2040 @return  bool 成功否
2053 	DB_Param_Add_WorldCountryLink dbparam;
2054 	// 条件参数
2055 	dbparam.dwID				= node.dwID;								// 跨服国家边境连通信息ID，0为无效ID，找到就修改，否则就新增
2056 	// 存入的数据
2057 	dbparam.dwPublicWorldID		= node.dwPublicWorldID;						// 所属公共区世界ID
2056 	// 存入的数据
2057 	dbparam.dwPublicWorldID		= node.dwPublicWorldID;						// 所属公共区世界ID
2058 	dbparam.dwType				= node.dwType;								// 跨服国家边境类型
2059 	dbparam.dwWorldID			= node.dwWorldID;							// 国家所在游戏世界ID
2060 	dbparam.dwCountryID			= node.dwCountryID;							// 国家ID
2067 	return true;
2068 }
2070 /** 加入跨服边境连通信息
2071 @return   bool 成功否
2072 */
2081 	
2082 	SCountryWorldLinkInfo addNode;
2083 	addNode.dwID				= GetCountryWorldLinkKey(dwWorldID,dwCountryID,dwType);	// 跨服国家边境连通信息ID，(游戏世界ID,国家ID,类型)组合编号
2084 	addNode.dwPublicWorldID		=(DWORD)getThisGameWorldID();							// 所属公共区世界ID
2084 	addNode.dwPublicWorldID		=(DWORD)getThisGameWorldID();							// 所属公共区世界ID
2085 	addNode.dwType				= dwType;								// 跨服国家边境类型
2086 	addNode.dwWorldID			= dwWorldID;							// 国家所在游戏世界ID
2087 	addNode.dwCountryID			= dwCountryID;							// 国家ID
2163 	return true;
2164 }
2166 // 检查所有跨服国战记录有效性
2167 bool CWorldWar::CheckAllBadWorldCountryWar(void)
2168 {
2167 bool CWorldWar::CheckAllBadWorldCountryWar(void)
2168 {
2169 	// 读出检查跨服国战信息
2170 	ReadCheckBadWorldWar();
2172 	return true;
2172 	return true;
2173 }
2176 /** 加入跨服国战信息
2177 @return
2178 */
2201 	DBSVR::TWorldCountryWar& stItem = stReq.stItem;
2202 	// 条件参数
2203 	stItem.ID					= 0;												// 跨服国战信息ID，0为无效ID，为0则新增记录，否则就修改
2204 	// 存入的数据
2205 	stItem.dwPublicWorldID			= SaveNodeData.dwPublicWorldID;						// 所属公共区世界ID
2206 	stItem.dwStartTime				= SaveNodeData.dwStartTime;							// 开始时间
2207 	stItem.dwEndTime				= SaveNodeData.dwEndTime;							// 结束时间
2208 	stItem.dwType					= SaveNodeData.dwType;								// 跨服国战类型
2209 	stItem.dwAttackWorldID			= SaveNodeData.dwAttackWorldID;						// 进攻国家所在游戏世界ID
2210 	stItem.dwAttackCountryID		= SaveNodeData.dwAttackCountryID;					// 进攻国家ID
2250 	// 调式代码
2251 	char szBuf[512]={0};
2252 	sprintf_s(szBuf, _countof(szBuf),_NGT"CWorldWar::NewWorldWar() 加入跨服国战信息 m_dwMaxID=%d",m_dwMaxID);
2253 	TraceLn(szBuf);
2254 #endif
2258 	// 加入到Map中,历史数据ID为关键字,pair<TMAP_CountryWorldWar::iterator,bool> retPair=
2259 	m_mapTempWorldWar.insert(TMAP_CountryWorldWar::value_type(SaveNodeData.dwID,SaveNodeData));
2262 	//添加或修改跨服国战信息 : 传入参数结构
2263 	DB_Param_Add_WorldCountryWar dbParam;	
2264 	// 条件参数
2263 	DB_Param_Add_WorldCountryWar dbParam;	
2264 	// 条件参数
2265 	dbParam.dwID					= 0;												// 跨服国战信息ID，0为无效ID，为0则新增记录，否则就修改
2266 	// 存入的数据
2267 	dbParam.dwPublicWorldID			= SaveNodeData.dwPublicWorldID;						// 所属公共区世界ID
2268 	dbParam.dwStartTime				= SaveNodeData.dwStartTime;							// 开始时间
2269 	dbParam.dwEndTime				= SaveNodeData.dwEndTime;							// 结束时间
2270 	dbParam.dwType					= SaveNodeData.dwType;								// 跨服国战类型
2271 	dbParam.dwAttackWorldID			= SaveNodeData.dwAttackWorldID;						// 进攻国家所在游戏世界ID
2272 	dbParam.dwAttackCountryID		= SaveNodeData.dwAttackCountryID;					// 进攻国家ID
2299 		(LPCSTR)&dbParam,sizeof(DB_Param_Add_WorldCountryWar),static_cast<IDBRetSink *>(this) ,getThisGameWorldID() ))
2300 	{
2301 		Error("添加或修改跨服国战信息失败！ m_dwMaxID="<<SaveNodeData.dwID<<endl);
2303 		return false;
2304 	}
2314 	return m_bSaved;
2315 }
2318 /** 场景服 发送给 国家社会服 请求社会服跨服国战数据消息
2319 @name  : 处理发上来的执行请求 
2320 @param endpointId : 发送过来的端ID
2334 	//BuildServerSelf(endpointId);
2336 }
2338 /** 客户端 发送给 国家社会服 请求社会服跨服国战数据消息
2339 @name  : 处理发上来的执行请求 
2340 @param endpointId : 发送过来的端ID
2355 	//BuildClientSelf(endpointId);
2356 }
2359 /** 取得跨服国战信息
2360 @param   DWORD dwID:	跨服国战ID
2361 @return  SCountryWorldWarInfo 
2362 */
2363 SCountryWorldWarInfo * CWorldWar::GetWorldWarInfo( DWORD dwID)
2364 {
2365 	// 找到跨服国战ID记录
2366 	TMAP_CountryWorldWar::iterator iter = m_mapWorldWar.find(dwID);
2368 	if (iter==m_mapWorldWar.end())
2445 }
2447 /** 设定状态 
2448 @param   DWORD dwID:	跨服国战ID
2449 @param   DWORD dwState :状态 EMCountryWorldWarState
2450 @return  bool 成功否
2456 		return false;
2457 	}
2458 	// 找到跨服国战ID记录
2459 	TMAP_CountryWorldWar::iterator iter = m_mapWorldWar.find(dwID);
2461 	if (iter==m_mapWorldWar.end())
2473 	return true;
2474 }
2476 /** 跨服国战变化
2477 @param   DWORD dwID:	跨服国战ID
2478 @return  bool 成功否
2479 */
2480 bool CWorldWar::OnWorldWarInfoChanged(DWORD dwID)
2481 {
2482 	// 找到跨服国战ID记录
2483 	TMAP_CountryWorldWar::iterator iter = m_mapWorldWar.find(dwID);
2485 	if (iter==m_mapWorldWar.end())
2494 	return true;
2495 }
2499 // 跨服 更新国战记录信息
2500 void CWorldWar::OnBridgeMsgUpdateWarInfo(unsigned long actionId, SMsgBridgeHead &bridgeHead, SGameMsgHead* head, LPSTR data, size_t len)
2501 {
2572 	Link_MoveHead();
2574 }
2577 // 跨服 向公共服请求数据
2578 void CWorldWar::OnBridgeMsgRequestWarInfo(unsigned long actionId, SMsgBridgeHead &bridgeHead, SGameMsgHead* head, LPSTR data, size_t len)
2579 {
2580 	SendWorldWarToServer(bridgeHead.dwServerID,0);
2581 }
2583 // 检查国家在跨服国战中的参战类型
2584 DWORD CWorldWar::CheckCountryWorldWarType(DWORD dwWorldID,DWORD dwCountryID,SCountryWorldWarInfo &node)
2585 {
2608 	return 0;
2609 }
2611 // 取得跨服国家边境连通编号以(游戏世界ID+国家ID+类型)组数编号 为关键字
2612 DWORD CWorldWar::GetCountryWorldLinkKey(DWORD dwWorldID,DWORD dwCountryID,DWORD dwType)
2613 {
2651 	DBSVR::TMSG_DBSVR_COUNTRY_WORLDWAR_GET_RSP& stRsp = pstMsg->stTMSG_DBSVR_COUNTRY_WORLDWAR_GET_RSP;
2652 #ifdef TRACE_COUNTRY_DETAIL
2653 	TraceLn("CWorldWar::OnDBRet_ReadCountryWorldWar 查询跨服国战信息  Result=" << stRsp.Result << " nTotalCount=" << stRsp.nTotalCount);
2654 #endif
2656 	if (stRsp.Result != 0)
2656 	if (stRsp.Result != 0)
2657 	{
2658 		ErrorLn("读取跨服国战信息失败,  Result = "<< stRsp.Result << " Err=[" << g_ExternalFacade.GetDBSvrErrStr(stRsp.Result) << "]" );
2659 		return;
2660 	}
2661 	if (stRsp.nTotalCount < 1)
2662 	{
2663 		TraceLn("读取跨服国战信息数据条数为0，条数 = " << stRsp.nTotalCount );
2664 	}
2665 	m_dwMaxID = 0;
2684 		}
2685 		SCountryWorldWarInfoNode  stAddNode;
2687 		stAddNode.dwID					= dwID;									// 跨服国战信息ID，0为无效ID
2688 		stAddNode.dwPublicWorldID		= stItem.dwPublicWorldID;				// 所属公共区世界ID
2689 		stAddNode.dwStartTime			= stItem.dwStartTime;					// 开始时间
2689 		stAddNode.dwStartTime			= stItem.dwStartTime;					// 开始时间
2690 		stAddNode.dwEndTime				= stItem.dwEndTime;						// 结束时间
2691 		stAddNode.dwType				= stItem.dwType;						// 跨服国战类型
2692 		stAddNode.dwAttackWorldID		= stItem.dwAttackWorldID;				// 进攻国家所在游戏世界ID
2693 		stAddNode.dwAttackCountryID		= stItem.dwAttackCountryID;				// 进攻国家ID
2741 	DBSVR::TMSG_DBSVR_COUNTRY_WORLDWAR_ADD_RSP& stRsp = pstMsg->stTMSG_DBSVR_COUNTRY_WORLDWAR_ADD_RSP;
2742 #ifdef TRACE_COUNTRY_DETAIL
2743 	TraceLn("CWorldWar::OnDBRet_AddCountryWorldWar 添加跨服国战信息  Result=" << stRsp.Result << " ID=" << stRsp.ID);
2744 #endif
2745 	DWORD dwRecordID = stRsp.dwTmpID;
2747 	if (stRsp.Result != 0)
2748 	{
2749 		ErrorLn("添加修改跨服国战信息失败,  Result = "<< stRsp.Result << " Err=[" << g_ExternalFacade.GetDBSvrErrStr(stRsp.Result) << "]" );
2750 		m_mapTempWorldWar.erase(dwRecordID);
2751 		return;
2784 	DBSVR::TMSG_DBSVR_COUNTRY_WORLDWAR_UPD_RSP& stRsp = pstMsg->stTMSG_DBSVR_COUNTRY_WORLDWAR_UPD_RSP;
2785 #ifdef TRACE_COUNTRY_DETAIL
2786 	TraceLn("CWorldWar::OnDBRet_UpdateCountryWorldWar 批量保存跨服国战信息  Result=" << stRsp.Result << " nItemCount=" << stRsp.nItemCount);
2787 #endif
2788 	if (stRsp.Result != 0)
2788 	if (stRsp.Result != 0)
2789 	{
2790 		ErrorLn("批量保存跨服国战信息 失败,  Result = "<< stRsp.Result << " Err=[" << g_ExternalFacade.GetDBSvrErrStr(stRsp.Result) << "]" );
2791 		return;
2792 	}
2807 		{
2808 			DWORD dwID = (DWORD)stItem.ID;
2809 			// 找到跨服国战信息记录
2810 			TMAP_CountryWorldWar::iterator iter = m_mapWorldWar.find(dwID);
2812 			if (iter!=m_mapWorldWar.end())
2877 		DBSVR::TWorldCountryWar& stDbItem = stItemSet.data[nCount];
2878 		SCountryWorldWarInfoNode& stNode = iter->second;
2880 		stDbItem.ID						= stNode.dwID;								// 跨服国战信息数据ID，为记录ID，找到就修改，没有就无效
2881 		stDbItem.dwPublicWorldID		= stNode.dwPublicWorldID;					// 所属公共区世界ID
2882 		stDbItem.dwStartTime			= stNode.dwStartTime;						// 开始时间
2882 		stDbItem.dwStartTime			= stNode.dwStartTime;						// 开始时间
2883 		stDbItem.dwEndTime				= stNode.dwEndTime;							// 结束时间
2884 		stDbItem.dwType					= stNode.dwType;							// 跨服国战类型
2885 		stDbItem.dwAttackWorldID		= stNode.dwAttackWorldID;					// 进攻国家所在游戏世界ID
2886 		stDbItem.dwAttackCountryID		= stNode.dwAttackCountryID;					// 进攻国家ID
2941 	DBSVR::TMSG_DBSVR_COUNTRY_WORLDLINK_GET_RSP& stRsp = pstMsg->stTMSG_DBSVR_COUNTRY_WORLDLINK_GET_RSP;
2942 #ifdef TRACE_COUNTRY_DETAIL
2943 	TraceLn("CWorldWar::OnDBRet_ReadWorldLink 读取跨服国家边境连通信息  Result=" << stRsp.Result << " nTotalCount=" << stRsp.nTotalCount);
2944 #endif
2945 	if (stRsp.Result != 0)
2945 	if (stRsp.Result != 0)
2946 	{
2947 		ErrorLn("读取跨服国家边境连通信息 失败,  Result = "<< stRsp.Result << " Err=[" << g_ExternalFacade.GetDBSvrErrStr(stRsp.Result) << "]" );
2948 		return;
2949 	}
2950 	if (stRsp.nTotalCount < 1)
2951 	{
2952 		TraceLn("读取跨服国家边境连通信息数据条数为0，条数 = "<<stRsp.nTotalCount);
2953 	}
2955 	m_mapWorldLink.clear();
2963 		DBSVR::TWorldCountryLink& stDBItem = stItemSet.data[i];
2965 		SCountryWorldLinkInfo  stAddNode;
2967 		stAddNode.dwID					= stDBItem.dwID;									// 跨服国家边境连通信息ID，0为无效ID
2968 		stAddNode.dwPublicWorldID		= stDBItem.dwPublicWorldID;						// 所属公共区世界ID
2968 		stAddNode.dwPublicWorldID		= stDBItem.dwPublicWorldID;						// 所属公共区世界ID
2969 		stAddNode.dwType				= stDBItem.dwType;								// 跨服国家边境类型
2970 		stAddNode.dwWorldID				= stDBItem.dwWorldID;							// 国家所在游戏世界ID
2971 		stAddNode.dwCountryID			= stDBItem.dwCountryID;							// 国家ID
2981 		else
2982 		{
2983 			ErrorLn("读取跨服国家边境连通信息数据ID与内容不符，ID="<<stAddNode.dwID<<",dwKey = "<<dwKey);
2984 		}
2985 	}
2995 	DBSVR::TMSG_DBSVR_COUNTRY_WORLDLINK_ADD_RSP& stRsp = pstMsg->stTMSG_DBSVR_COUNTRY_WORLDLINK_ADD_RSP;
2996 #ifdef TRACE_COUNTRY_DETAIL
2997 	TraceLn("CWorldWar::OnDBRet_AddWorldLink 添加修改跨服国家边境连通信息  Result=" << stRsp.Result << " dwID=" << stRsp.dwID);
2998 #endif
2999 	if (stRsp.Result != 0)
2999 	if (stRsp.Result != 0)
3000 	{
3001 		ErrorLn("添加修改跨服国家边境连通信息失败！Result = "<< stRsp.Result << " Err=[" << g_ExternalFacade.GetDBSvrErrStr(stRsp.Result) << "]" );
3002 		return;
3003 	}

I:\work\source\盛世OL\[src.cool]盛世OL\Server\GameServer\worldkernel\WorldKernel1.cpp 91 KB CPP 文件 2014/2/25 15:44:26 2018/10/23 13:19:22 2018/10/23 13:19:22 1
2830 	return m_Msgsock.SendPacket((LPCTSTR)&msg, msg.unMsgSize, true);
2831 }
2833 //系统公告以及跨服聊天的处理
2834 bool CWorldKernel::SendMsgGame(OBJID idAccount,LPCTSTR pTragetName,WORD wMsgType,LPCTSTR pName,LPCTSTR pBuf,WORD wServerId,BOOL bIsBack)
2835 {

I:\work\source\预言OL\yl code\code\Server\GameServer\worldkernel\WorldKernel.cpp 89 KB CPP 文件 2010/1/6 16:09:02 2018/10/23 19:32:12 2018/10/23 19:32:12 1
2701 	return m_Msgsock.SendPacket((LPCTSTR)&msg, msg.unMsgSize, true);
2702 }
2704 //系统公告以及跨服聊天的处理
2705 bool CWorldKernel::SendMsgGame(OBJID idAccount,LPCTSTR pTragetName,WORD wMsgType,LPCTSTR pName,LPCTSTR pBuf,WORD wServerId,BOOL bIsBack)
2706 {

I:\work\source\预言OL\[src.cool]预言OL\yuyancode\code\Server\GameServer\worldkernel\WorldKernel.cpp 89 KB CPP 文件 2010/1/6 16:09:02 2018/10/23 19:32:55 2018/10/23 19:32:55 1
2701 	return m_Msgsock.SendPacket((LPCTSTR)&msg, msg.unMsgSize, true);
2702 }
2704 //系统公告以及跨服聊天的处理
2705 bool CWorldKernel::SendMsgGame(OBJID idAccount,LPCTSTR pTragetName,WORD wMsgType,LPCTSTR pName,LPCTSTR pBuf,WORD wServerId,BOOL bIsBack)
2706 {

I:\work\source\盛世OL\[src.cool]盛世OL\Server\GameServer\worldkernel\WorldKernel.cpp 95 KB CPP 文件 2014/2/25 15:44:24 2018/10/23 13:19:22 2018/10/23 13:19:22 1
2921 	return m_Msgsock.SendPacket((LPCTSTR)&msg, msg.unMsgSize, true);
2922 }
2924 //系统公告以及跨服聊天的处理
2925 bool CWorldKernel::SendMsgGame(OBJID idAccount,LPCTSTR pTragetName,WORD wMsgType,LPCTSTR pName,LPCTSTR pBuf,WORD wServerId,BOOL bIsBack)
2926 {

I:\work\source\剑侠时代\jxsd\core\地图插件\jxsd\code\Server\GameServer\worldkernel\WorldKernel.cpp 89 KB CPP 文件 2010/12/21 10:13:13 2018/10/19 14:11:35 2018/10/19 14:11:35 1
2703 	return m_Msgsock.SendPacket((LPCTSTR)&msg, msg.unMsgSize, true);
2704 }
2706 //系统公告以及跨服聊天的处理
2707 bool CWorldKernel::SendMsgGame(OBJID idAccount,LPCTSTR pTragetName,WORD wMsgType,LPCTSTR pName,LPCTSTR pBuf,WORD wServerId,BOOL bIsBack)
2708 {

I:\work\source\剑侠时代\[src.cool]剑侠时代\jxsd\code\Server\GameServer\worldkernel\WorldKernel.cpp 89 KB CPP 文件 2010/12/21 10:13:13 2018/10/19 14:11:14 2018/10/19 14:11:14 1
2703 	return m_Msgsock.SendPacket((LPCTSTR)&msg, msg.unMsgSize, true);
2704 }
2706 //系统公告以及跨服聊天的处理
2707 bool CWorldKernel::SendMsgGame(OBJID idAccount,LPCTSTR pTragetName,WORD wMsgType,LPCTSTR pName,LPCTSTR pBuf,WORD wServerId,BOOL bIsBack)
2708 {

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\MatchService\WarService.cpp 152 KB CPP 文件 2014/2/25 0:23:13 2018/10/23 20:09:05 2018/10/23 20:09:05 205
37 	// 最大领地Boss开战场撮合序号
38 	m_dwBossWarMatchMaxID = 0;
39 	// 最大跨服边境连通序号
40 	m_dwWorldBorderLinkMaxID = 0;
40 	m_dwWorldBorderLinkMaxID = 0;
41 	// 最近创建跨服边境连通时间，用来冷却
42 	m_dwLastAddWorldBorderWarTimes = 0;
43 }
54 bool CWarService::Create()
55 {
56 	// 本区是否能开跨服国战
57 	if (g_pMatchService->IsCanOpenWorldWar())
58 	{
59 		// 主任务处理定时器
60 		g_ExternalFacade.SetTimer(ETimerEventID_DoTask, MATCH_ONETEAM_TIMEOUT, static_cast<ITimerHandler *>(this), "CWarService::Create");
61 		// 检测跨服国战记录任务处理定时器 
62 		g_ExternalFacade.SetTimer(ETimerEventID_DoCheckBadCountryWar, MATCH_CHECKBADWAR_INTERVAL, static_cast<ITimerHandler *>(this), "CWarService::Create");
63 		
113 			// 主任务处理
114 			DoTask();
115 			// 跨服边境主任务处理
116 			DoBorderWarTask();
117 		}
130 		}
131 		break;
132 	case ETimerEventID_DoCheckBadCountryWar:		// 检测跨服国战记录任务处理定时器 
133 		{
134 			DoCheckBadCountryWar();
215 	if (bZeroRemoveAll==true && dwWarID==0)
216 	{
217 		ErrorLn("删除场景服["<<dwServerID<<"]的所有跨服战场信息，可能是该场景服关闭或当机了！");
218 		for(TMAP_WarDataInfoList::iterator iter = m_mapWarList.begin(); iter != m_mapWarList.end();)
219 		{
501 		return;
502 	}
504 	// 所有客户端同步跨服国战活动追踪信息
505 	SendClientWorldWarTracker(info,0,false);
506 }
505 	SendClientWorldWarTracker(info,0,false);
506 }
508 // 所有客户端同步跨服战场活动追踪信息
509 bool CWarService::SendClientWorldWarTracker(UserInfo& userInfo,DWORD dwWarID,bool bRemoveTracker)
510 {
512 	DWORD dwID = 0;
513 	DWORD dwCount = 0;
515 	// 客户端同步跨服国战活动追踪信息
516 	if (dwWarID==0 || dwWarID==WarType_Country1)
517 	{
524 		}		
525 	}
527 	// 客户端同步跨服领地BOSS战活动追踪信息
528 	if (dwWarID==0 || dwWarID==WarType_ClanBoss)
529 	{
537 	}
538 	
539 	// 客户端同步跨服跨服边境战活动追踪信息
540 	if (dwWarID==0 || dwWarID==WarType_CountryBorder)
541 	{
556 	return true;
557 }
559 // 客户端同步跨服国战活动追踪信息
560 bool CWarService::SendClientCoutryWarTracker(UserInfo& userInfo)
561 {
566 		return false;
567 	}
569 	// 取地跨服国战系统接口
570 	IWorldWar* pWorldWar = pCountryService->GetWorldWarPart();
571 	if (pWorldWar==NULL)
615 		if (node.dwStartTime>=dwTodayTime && (node.dwState==CountryWorldWarState_New || node.dwState==CountryWorldWarState_Ready || node.dwState==CountryWorldWarState_Doing) )
616 		{
617 			// 检查国家在跨服国战中的参战类型 0.无,1.攻,2.守,3.攻盟友,4.守盟友
618 			DWORD dwMyJoinType = CheckCountryWorldWarType(dwFromWorldID,dwFromCountryID,node);	// 本国
619 			if (dwMyJoinType > 0)
630 	return bFound;
631 }
633 // 客户端同步跨服领地BOSS战活动追踪信息
634 bool CWarService::SendClientCastleBossWarTracker(UserInfo& userInfo)
635 {
660 	return g_pMatchService->SendDataToLocalServer(dwServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_BossWarTracker,dwClanID,dwPlayerID,0, (LPSTR)&clanNode, sizeof(clanNode));
661 }
663 // 客户端同步跨服跨服边境战活动追踪信息
664 bool CWarService::SendClientBorderWarTracker(UserInfo& userInfo)
665 {
670 		return false;
671 	}
673 	// 取地跨服国战系统接口
674 	IWorldWar* pWorldWar = pCountryService->GetWorldWarPart();
675 	if (pWorldWar==NULL)
677 		return false;
678 	}
680 	// 取得跨服国家边境连通信息
681 	SCountryWorldLinkInfo * pWarLinkInfo = pWorldWar->GetCountryWorldLinkInfo(userInfo.worldId,userInfo.nation,WarType_CountryBorder);
682 	if (pWarLinkInfo ==NULL)
710 		return false;
711 	}
713 	// 发送跨服国家边境信息到场景服
714 	return g_pMatchService->SendDataToLocalServer(userInfo.svrId,MSG_MATCH_DATE_WARMSG,Match_WarMsg_BorderWarTracker,userInfo.worldId,userInfo.nation,userInfo.id, (LPCSTR)pWarLinkInfo, sizeof(SCountryWorldLinkInfo));
715 }
714 	return g_pMatchService->SendDataToLocalServer(userInfo.svrId,MSG_MATCH_DATE_WARMSG,Match_WarMsg_BorderWarTracker,userInfo.worldId,userInfo.nation,userInfo.id, (LPCSTR)pWarLinkInfo, sizeof(SCountryWorldLinkInfo));
715 }
717 // 更新跨服国战活动追踪信息,dwWarID=0为发全部战场追踪信息
718 bool CWarService::OnUpdateWorldWarTracker(DWORD dwWarID)
719 {
736 	while (pUserInfo != NULL)
737 	{
738 		// 客户端同步跨服战场活动追踪信息
739 		SendClientWorldWarTracker( (*pUserInfo), dwWarID,true);
741 		pUserInfo = pUserManager->findNextUser();
819 	// 可持续时间长度 3分钟
820 	const DWORD dwContinueTimeLen = 5*60;
822 	// 新开跨服国战数据
823 	SCheckCountryWorldWarDataInfo node;
824 	node.warInfo	= warInfo;									// 国战节点数据
889 			continue;
890 		}
892 		// 取得跨服国战日期
893 		tm nexttm;
894 		memset(&nexttm,0,sizeof(nexttm));
912 				time_t	war_long_time = (time_t)(pSiegeWar->nDawnTime); 
913 				localtime_s(&wartm,&war_long_time);
915 				// 在明天，本区国战的战斗时间和跨服国战的开战日期一样
916 				if (wartm.tm_year == nexttm.tm_year && wartm.tm_yday == nexttm.tm_yday)
917 				{
934 				time_t	war_long_time = (time_t)(pSiegeWar->nDawnTime); 
935 				localtime_s(&wartm,&war_long_time);
937 				// 在明天，本区国战的战斗时间和跨服国战的开战日期一样
938 				if (wartm.tm_year == nexttm.tm_year && wartm.tm_yday == nexttm.tm_yday)
939 				{
982 	}
983 }
986 // 检测跨服国战记录任务处理定时器
987 void CWarService::DoCheckBadCountryWar()
988 {
1011 		return;
1012 	}
1014 	// 取地跨服国战系统接口
1015 	IWorldWar* pWorldWar = pCountryService->GetWorldWarPart();
1016 	if (NULL == pWorldWar)
1019 		return;
1020 	}
1022 	// 检查所有跨服国战记录有效性
1023 	pWorldWar->CheckAllBadWorldCountryWar();
1024 }
1065 		return;
1066 	}
1068 	// 取地跨服国战系统接口
1069 	IWorldWar* pWorldWar = pCountryService->GetWorldWarPart();
1070 	if (NULL == pWorldWar)
1074 	}
1075 	
1076 	// 取得跨服国战信息
1077 	SCountryWorldWarInfo * pCountryWarInfo = pWorldWar->GetWorldWarInfo(dwWarID);
1078 	if (NULL == pCountryWarInfo)
1088 	DWORD dwDefendWorldID	= warInfo.dwDefendWorldID;			// 防御国家所在游戏世界ID
1089 	DWORD dwDefendCountryID	= warInfo.dwDefendCountryID;		// 防御国家ID
1091 	sprintf_s(szMsgBuf, sizeof(szMsgBuf), "CWarService::OnBridgeMsgExistCountryWarData(): 收到跨服国战与本地国战有冲突,ID=%d,攻方(WorldID=%d,CountryID=%d),守方(WorldID=%d,CountryID=%d),冲突阵营ID=%d,开始时间=%s,结束时间=%s,跨服国战类型=%d,状态=%d",
1092 		dwWarID,dwAttackWorldID,dwAttackCountryID,dwDefendWorldID,dwDefendCountryID,dwClashCampID,
1093 		g_ExternalFacade.GetTimeString(warInfo.dwStartTime), g_ExternalFacade.GetTimeString(warInfo.dwEndTime),
1095 	ErrorLn(szMsgBuf);
1097 	// 发送提示给GM管理员
1098 	sprintf_s(szMsgBuf, sizeof(szMsgBuf), "跨服国战与本地国战有冲突,ID=%d,攻方(%s),守方(%s),阵营ID=%d,开始=%s,结束=%s,类型=%d,状态=%d",
1099 		dwWarID,g_ExternalFacade.GetWorldCountryName(dwAttackWorldID,dwAttackCountryID,false).c_str() ,g_ExternalFacade.GetWorldCountryName(dwDefendWorldID,dwDefendCountryID,false).c_str(), 
1100 		dwClashCampID,g_ExternalFacade.GetTimeString(warInfo.dwStartTime), g_ExternalFacade.GetTimeString(warInfo.dwEndTime),
1110 	sendData.strReporterName	= "系统举报";											// 角色名
1111 	sendData.dwCheaterID		= 0;													// 举报对象玩家角色ID
1112 	sendData.strCheaterName		= "跨服国战举报";										// 举报对象角色名
1113 	sendData.strTitle			= buffer.str();											// 举报证据（最大长度和聊天内容长短一致）
1114 	sendData.strMsg				= "社会服自动举报";										// 附加说明
1120 	warInfo.dwStartTime	= 0;		// 开始时间
1121 	warInfo.dwEndTime	= 0;		// 结束时间
1122 	// 设置国战记录状态为无效跨服国战并广播到其他区
1123 	pWorldWar->SetState(dwWarID,CountryWorldWarState_None);
1125 	// 给发布的国王进行提示
1123 	pWorldWar->SetState(dwWarID,CountryWorldWarState_None);
1125 	// 给发布的国王进行提示
1127 	// 取得攻方的跨服信息
1128 	IBridgeSocialPart* pMySocialPart = (IBridgeSocialPart*)pBridgeConnector->GetGameServerPartByTypeSubID(dwAttackWorldID,MSG_ENDPOINT_SOCIAL,0);
1129 	if (NULL == pMySocialPart)
1159 	if (dwClashCampID==1)
1160 	{
1161 		sprintf_s(szMsgBuf, sizeof(szMsgBuf), "<rich color='#FFFF0000'>由于本国已有国战，本次发起攻打[%s]跨服国战失效！<rich color='default'>",strCountryName.c_str());
1162 	}
1163 	else
1163 	else
1164 	{
1165 		sprintf_s(szMsgBuf, sizeof(szMsgBuf), "<rich color='#FFFF0000'>由于被进攻国已有国战，本次发起攻打[%s]跨服国战失效！<rich color='default'>",strCountryName.c_str());
1166 	}	
1168 	gGlobalSocialServer->getChatService()->worldSendSystemTips(dwAttackWorldID,TipType_Operate, dwPlayerID, InfoPos_ChatWindow|InfoPos_ActorRight, szMsgBuf);
1169 }
1172 // 增加本区国战占用电脑信息
1173 //dwWarType:国战类型；dwComputerID:计算机id; dwValue:过期时间，0表示函数内部计算； nType:0表示跨服，1表示本区
1174 void CWarService::AddWarComputerInfo(DWORD dwWarType, DWORD dwComputerID, DWORD dwValue/*=0*/, int nType/*=0*/)
1175 {
1208 	if (nType==0)
1209 	{
1210 		WarningLn("AddWarComputeInfo() 增加跨服战场占用电脑信息, WarType="<< dwWarType << ", ComputerID="<< dwComputerID << ", dwDirtyTime="<<dwDirtyTime);
1211 	}
1212 	else
1432 		}
1433 		break;
1434 	case Match_WarMsg_RequestAddCountryWar:		// 玩家请求发起跨服国战
1435 		{
1436 			if (nNewlen>0 || head->SrcEndPoint!=MSG_ENDPOINT_CLIENT)
1438 				break;
1439 			}
1440 			// 玩家请求发起跨服国战 DWORD dwFlag 操作标识 0.开战,1.结盟
1441 			OnMsgRequestAddCountryWar(endpointId,pMsg->dwUserData1,pMsg->dwUserData2,pMsg->dwUserData3);
1442 		}
1477 	switch(pMsg->dwMsgCode)
1478 	{
1479 	case Match_WarMsg_RequestCheckCountryWar:		// 请求检查跨服国战对方是否本区有国战
1480 		{
1481 			if (nNewlen!=sizeof(SMsgWarRequestAddCountryWar_O))
1481 			if (nNewlen!=sizeof(SMsgWarRequestAddCountryWar_O))
1482 			{
1483 				ErrorLn("收到桥服务器请求检查跨服国战对方是否本区有国战数据大小不符，nLen = "<<nNewlen);
1484 				break;
1485 			}
1485 			}
1487 			SMsgWarRequestAddCountryWar_O * pInfo = (SMsgWarRequestAddCountryWar_O *)pMsgData;
1488 			// 请求检查跨服国战对方是否本区有国战
1489 			OnMsgRequestCheckCountryWar(*pInfo);
1490 		}
1490 		}
1491 		break;
1492 	case Match_WarMsg_CheckCountryWarResult:		// 请求检查跨服国战对方是否本区有国战结果
1493 		{
1494 			if (nNewlen!=sizeof(SMsgWarRequestAddCountryWar_O))
1494 			if (nNewlen!=sizeof(SMsgWarRequestAddCountryWar_O))
1495 			{
1496 				ErrorLn("收到桥服务器请求检查跨服国战对方是否本区有国战结果 数据大小不符，nLen = "<<nNewlen);
1497 				break;
1498 			}
1498 			}
1500 			SMsgWarRequestAddCountryWar_O * pInfo = (SMsgWarRequestAddCountryWar_O *)pMsgData;
1501 			// 请求检查跨服国战对方是否本区有国战结果
1502 			OnMsgRequestCheckCountryWarResult(*pInfo,pMsg->dwUserData1);
1503 		}
1503 		}
1504 		break;
1505 	case Match_WarMsg_RequestAddCountryWar:		// 玩家请求发起跨服国战
1506 		{
1507 			if (nNewlen!=sizeof(SMsgWarRequestAddCountryWar_O))
1507 			if (nNewlen!=sizeof(SMsgWarRequestAddCountryWar_O))
1508 			{
1509 				ErrorLn("收到桥服务器玩家请求发起跨服国战信息数据大小不符，nLen = "<<nNewlen);
1510 				break;
1511 			}
1516 			}
1517 			SMsgWarRequestAddCountryWar_O * pInfo = (SMsgWarRequestAddCountryWar_O *)pMsgData;
1518 			// 玩家请求发起跨服国战 
1519 			RequestAddCountryWar(pInfo->dwPlayerID,pInfo->dwActorWorldID,pInfo->dwFromWorldID,pInfo->dwFromCountryID,pInfo->dwWorldID,pInfo->dwCountryID,pInfo->dwFlag);
1520 		}
1520 		}
1521 		break;
1522 	case Match_WarMsg_RequestNewCountryWar:		// 新建跨服国战
1523 		{
1524 			if (nNewlen!=sizeof(SCountryWorldWarInfo))
1524 			if (nNewlen!=sizeof(SCountryWorldWarInfo))
1525 			{
1526 				ErrorLn("收到桥服务器新建跨服国战信息数据大小不符，nLen = "<<nNewlen);
1527 				break;
1528 			}
1531 		}
1532 		break;
1533 	case Match_WarMsg_WorldCountryWarState:		// 跨服国战状态变化
1534 		{
1535 			if (nNewlen!=2*sizeof(DWORD))
1556 				break;
1557 			}
1558 			// 取地跨服国战系统接口
1559 			IWorldWar* pWorldWar = pCountryService->GetWorldWarPart();
1560 			if (pWorldWar==NULL)
1562 				break;
1563 			}
1564 			// 取得跨服国战信息
1565 			SCountryWorldWarInfo *pWarInfo = pWorldWar->GetWorldWarInfo(dwTaskWorldWarID);
1566 			if (pWarInfo!=NULL)
1645 				break;
1646 			}
1648 			// 刷新跨服共享国家信息
1649 			pBasePart->UpdateWorldCountryInfo();
1651 		}
1730 		}
1731 		break;
1732 	case Match_WarMsg_RequestKingInfo:	// 请求获取跨服国王信息
1733 		{
1734 			if (nNewlen>0)
1834 			}
1836 			// 加入国家GDP
1837 			pCountry->GetBasePart()->AddCountryPiont(nGetGDPValue,0,OssResAdd_CountryWar,"跨服国战加国家GDP");
1839 		}
1840 		break;
1839 		}
1840 		break;
1841 	case Match_WarMsg_RequestAddCountryWarResult:			// 玩家请求发起跨服国战结果
1842 		{
1843 			if (nNewlen>0)
1849 			DWORD dwCountryID	= pMsg->dwUserData2;		// 国家ID
1850 			DWORD dwFlag		= pMsg->dwUserData3;		// 标识
1852 			// 跨服国战延长国战任期
1853 			OnAddCountryWarKingTimeout(dwWorldID, dwCountryID);
1854 		}
1854 		}
1855 		break;
1856 	case Match_WarMsg_RequestAddClanBossWar:			// 请求发起跨服帮会领地BOSS战信息
1857 		{
1857 		{
1858 			// 加入跨服Boss战发起信息
1859 			AddCastleBossWarTask(pMsgData,nNewlen);
1860 		}
1894 	}
1896 }
1898 // 新建跨服国战
1899 bool CWarService::NewCountryWorldWar(bool bIsPublic,SCountryWorldWarInfo &node)
1900 {
1925 	if (dwServerID==0 || dwServerID==INVALID_SERVER_ID)
1926 	{
1927 		ErrorLn("开启跨服国战失败，原因：找不到合适的场景服服务器！ID="<<node.dwID<<",WarItemType="<<node.dwType<<",情景ID="<<node.dwData2<<",进攻方（WorldID="<<node.dwAttackWorldID <<",CountryID="<<node.dwAttackCountryID<<"）,防御方（WorldID="<<node.dwDefendWorldID<<",CountryID="<<node.dwDefendCountryID<<"）,副本开启时间="<<g_ExternalFacade.GetTimeString(node.dwStartTime)<<",开战时间="<<g_ExternalFacade.GetTimeString(node.dwData1)<<",结束时间="<<g_ExternalFacade.GetTimeString(node.dwEndTime) );
1928 		return false;
1929 	}
1928 		return false;
1929 	}
1930 	ErrorLn("CWarService::NewCountryWorldWar() :"<< dwServerID <<"号场景服上成功开启跨服国战！ID="<<node.dwID<<",WarItemType="<<node.dwType<<",情景ID="<<node.dwData2<<",进攻方（WorldID="<<node.dwAttackWorldID <<",CountryID="<<node.dwAttackCountryID<<"）,防御方（WorldID="<<node.dwDefendWorldID<<",CountryID="<<node.dwDefendCountryID<<"）,副本开启时间="<<g_ExternalFacade.GetTimeString(node.dwStartTime)<<",开战时间="<<g_ExternalFacade.GetTimeString(node.dwData1)<<",结束时间="<<g_ExternalFacade.GetTimeString(node.dwEndTime) );
1932 	// 加入服务器开战场信息
1933 	AddServerOpenWarInfo(dwServerID,node.dwType);
1932 	// 加入服务器开战场信息
1933 	AddServerOpenWarInfo(dwServerID,node.dwType);
1935 	// 请求开跨服国战
1936 	g_pMatchService->SendDataToLocalServer(dwServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_RequestNewCountryWar,node.dwType,0,0,(const char *)&node,sizeof(node));
1938 	return true;
1938 	return true;
1939 }
1941 // 新建跨服边境
1942 bool CWarService::NewCountryWorldBorderWar(bool bIsPublic,SCountryWorldWarInfo &node)
1943 {
1952 	if (dwServerID==0 || dwServerID==INVALID_SERVER_ID)
1953 	{
1954 		ErrorLn("开启跨服边境失败，原因：找不到合适的场景服服务器！ID="<<node.dwID<<",WarItemType="<<node.dwType<<",情景ID="<<node.dwData2<<",进攻方（WorldID="<<node.dwAttackWorldID <<",CountryID="<<node.dwAttackCountryID<<"）,防御方（WorldID="<<node.dwDefendWorldID<<",CountryID="<<node.dwDefendCountryID<<"）,副本开启时间="<<g_ExternalFacade.GetTimeString(node.dwStartTime)<<",开战时间="<<g_ExternalFacade.GetTimeString(node.dwData1)<<",结束时间="<<g_ExternalFacade.GetTimeString(node.dwEndTime) );
1955 		return false;
1956 	}
1955 		return false;
1956 	}
1957 	ErrorLn("CWarService::NewCountryWorldBorderWar() :"<< dwServerID <<"号场景服上成功开启跨服边境！ID="<<node.dwID<<",WarItemType="<<node.dwType<<",情景ID="<<node.dwData2<<",进攻方（WorldID="<<node.dwAttackWorldID <<",CountryID="<<node.dwAttackCountryID<<"）,防御方（WorldID="<<node.dwDefendWorldID<<",CountryID="<<node.dwDefendCountryID<<"）,副本开启时间="<<g_ExternalFacade.GetTimeString(node.dwStartTime)<<",开战时间="<<g_ExternalFacade.GetTimeString(node.dwData1)<<",结束时间="<<g_ExternalFacade.GetTimeString(node.dwEndTime) );
1959 	// 加入服务器开战场信息
1960 	AddServerOpenWarInfo(dwServerID,node.dwType);
1959 	// 加入服务器开战场信息
1960 	AddServerOpenWarInfo(dwServerID,node.dwType);
1962 	// 请求开跨服国战
1963 	g_pMatchService->SendDataToLocalServer(dwServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_RequestNewBorderWar,node.dwType,0,0,(const char *)&node,sizeof(node));
1965 	return true;
1965 	return true;
1966 }
1969 // 检查国家在跨服国战中的参战类型
1970 DWORD CWarService::CheckCountryWorldWarType(DWORD dwWorldID,DWORD dwCountryID,SCountryWorldWarInfo &node)
1971 {
1994 	return 0;
1995 }
1998 // 检查是否能发起跨服国战 DWORD dwFlag 操作标识 0.开战,1.结盟
1999 bool CWarService::CheckCountryWorldWar(bool IsLocal,DWORD dwPlayerID,DWORD dwActorWorldID,DWORD dwFromWorldID,DWORD dwFromCountryID,DWORD dwWorldID,DWORD dwCountryID,DWORD dwFlag)
2000 {
1999 bool CWarService::CheckCountryWorldWar(bool IsLocal,DWORD dwPlayerID,DWORD dwActorWorldID,DWORD dwFromWorldID,DWORD dwFromCountryID,DWORD dwWorldID,DWORD dwCountryID,DWORD dwFlag)
2000 {
2001 	// 如果跨服国战开战时间为0,表示测试版，不检测
2002 	int nStartHourMin = g_pMatchService->GetWarConfigNumber(WarCfgNum_StartHourMin);		// 跨服国战开战时间：小时*100+分钟
2003 	if (nStartHourMin==0 && getThisGameWorldID()>=3000)
2004 	{
2024 		return false;
2025 	}
2027 	// 取地跨服国战系统接口
2028 	IWorldWar* pWorldWar = pCountryService->GetWorldWarPart();
2029 	if (pWorldWar==NULL)
2046 		goto EndCheckWar;	// 跳到结束计算任务
2047 	}
2049 	// 取得双方的跨服信息
2050 	IBridgeSocialPart* pMySocialPart = (IBridgeSocialPart*)pBridgeConnector->GetGameServerPartByTypeSubID(dwFromWorldID,MSG_ENDPOINT_SOCIAL,0);
2051 	IBridgeSocialPart* pSocialPart = (IBridgeSocialPart*)pBridgeConnector->GetGameServerPartByTypeSubID(dwWorldID,MSG_ENDPOINT_SOCIAL,0);
2052 	if (pMySocialPart==NULL || pSocialPart==NULL)
2053 	{
2054 		sprintf_s(szBuf, sizeof(szBuf), "找不到跨服相关信息！");
2055 		goto EndCheckWar;	// 跳到结束计算任务
2056 	}
2060 	if (pMyBridgeCountry==NULL || pBridgeCountry==NULL)
2061 	{
2062 		sprintf_s(szBuf, sizeof(szBuf), "找不到跨服相关国家信息！");
2063 		goto EndCheckWar;	// 跳到结束计算任务
2064 	}
2064 	}
2065 	
2066 	// 检查对方国是否能开跨服国战
2067 	if (g_pMatchService->IsCloseWorldCountryWar(dwFromWorldID))
2068 	{
2067 	if (g_pMatchService->IsCloseWorldCountryWar(dwFromWorldID))
2068 	{
2069 		sprintf_s(szBuf, sizeof(szBuf), "你所在游戏区暂时关闭跨服国战！");
2070 		goto EndCheckWar;	// 跳到结束计算任务
2071 	}
2072 	if (g_pMatchService->IsCloseWorldCountryWar(dwWorldID))
2073 	{
2074 		sprintf_s(szBuf, sizeof(szBuf), "指定国家所在游戏区暂时关闭跨服国战！");
2075 		goto EndCheckWar;	// 跳到结束计算任务
2076 	}
2078 	DWORD dwCivilGrade = pBridgeCountry->GetCivilGrade();			// 他国世界文明等级
2079 	DWORD dwMyCivilGrade = pMyBridgeCountry->GetCivilGrade();		// 本国世界文明等级
2081 	DWORD dwCivilGradeLoRange = g_pMatchService->GetWarConfigNumber(WarCfgNum_CivilGradeLoRang);	// 跨服国战能跨文明等级下限
2082 	DWORD dwCivilGradeHiRange = g_pMatchService->GetWarConfigNumber(WarCfgNum_CivilGradeHiRang);	// 跨服国战能跨文明等级上限
2084 	// 检查攻防指数是否匹配
2085 	if (dwFlag==1)	// 结盟
2178 		}
2179 	}
2181 	// 检查跨服国战相关次数 
2182 	DWORD dwDayMaxWar	= (DWORD)g_pMatchService->GetWarConfigNumber(WarCfgNum_RunWorldWarMax);			// 一天最多数
2183 	DWORD dwMaxAttack	= (DWORD)g_pMatchService->GetWarConfigNumber(WarCfgNum_WeekAttackMax);			// 最多进攻数
2244 		if (node.dwStartTime>dwWeekStartTime && node.dwStartTime<dwWeekEndTime)
2245 		{
2246 			// 检查国家在跨服国战中的参战类型 0.无,1.攻,2.守,3.攻盟友,4.守盟友
2247 			DWORD dwMyJoinType = CheckCountryWorldWarType(dwFromWorldID,dwFromCountryID,node);	// 本国
2248 			DWORD dwJoinType = CheckCountryWorldWarType(dwWorldID,dwCountryID,node);			// 他国
2304 		if (dwMyFightCounts1+dwMyFightCounts2<=0)
2305 		{
2306 			sprintf_s(szBuf, sizeof(szBuf), "本国没有跨服国战，不能指定国战结盟！");
2307 		}
2308 		else if (dwFightCounts1+dwFightCounts2+dwFightCounts3>0)
2308 		else if (dwFightCounts1+dwFightCounts2+dwFightCounts3>0)
2309 		{
2310 			sprintf_s(szBuf, sizeof(szBuf), "指定国家明天已有跨服国战！");
2311 		}
2312 		else if (dwHelpCounts>=dwMaxHelp)
2312 		else if (dwHelpCounts>=dwMaxHelp)
2313 		{
2314 			sprintf_s(szBuf, sizeof(szBuf), "指定国家本周参于跨服国战结盟次数已达上限，请换其它国家结盟！");
2315 		}
2316 		else
2320 		goto EndCheckWar;	// 跳到结束计算任务
2321 	}
2323 	// 检查明天已有跨服国战
2324 	if (nowtm.tm_wday==4)
2325 	{
2324 	if (nowtm.tm_wday==4)
2325 	{
2326 		sprintf_s(szBuf, sizeof(szBuf), "明天是国王争霸赛时间，不能发起跨服国战！");
2327 		goto EndCheckWar;	// 跳到结束计算任务
2328 	}
2327 		goto EndCheckWar;	// 跳到结束计算任务
2328 	}
2330 	// 检查是否在天的结束或开始时间段,就不能发起,解决服务器时间不同步导致本国和跨服同时发起的问题
2331 	if ( (nowtm.tm_hour==23 && nowtm.tm_min>50) || (nowtm.tm_hour==0 && nowtm.tm_min<10) )
2332 	{
2331 	if ( (nowtm.tm_hour==23 && nowtm.tm_min>50) || (nowtm.tm_hour==0 && nowtm.tm_min<10) )
2332 	{
2333 		sprintf_s(szBuf, sizeof(szBuf), "现在时间处于[23:50~0:10]时间段，不能发起跨服国战！");
2334 		goto EndCheckWar;	// 跳到结束计算任务
2335 	}
2334 		goto EndCheckWar;	// 跳到结束计算任务
2335 	}
2337 	// 检查明天已有跨服国战
2338 	if (dwMyFightCounts1+dwMyFightCounts2+dwMyFightCounts3>0)
2339 	{
2338 	if (dwMyFightCounts1+dwMyFightCounts2+dwMyFightCounts3>0)
2339 	{
2340 		sprintf_s(szBuf, sizeof(szBuf), "本国明天已有跨服国战！");
2341 		goto EndCheckWar;	// 跳到结束计算任务
2342 	}
2341 		goto EndCheckWar;	// 跳到结束计算任务
2342 	}
2344 	// 检查明天已有跨服国战
2345 	if (dwFightCounts1+dwFightCounts2+dwFightCounts3>0)
2346 	{
2345 	if (dwFightCounts1+dwFightCounts2+dwFightCounts3>0)
2346 	{
2347 		sprintf_s(szBuf, sizeof(szBuf), "指定国家明天已有跨服国战！");
2348 		goto EndCheckWar;	// 跳到结束计算任务
2349 	}
2348 		goto EndCheckWar;	// 跳到结束计算任务
2349 	}
2351 	// 检查明天跨服国战次数
2352 	if (dwOnWarCounts>=dwDayMaxWar)
2353 	{
2352 	if (dwOnWarCounts>=dwDayMaxWar)
2353 	{
2354 		sprintf_s(szBuf, sizeof(szBuf), "明天开跨服国战数已到上限，请明天再来！");
2355 		goto EndCheckWar;	// 跳到结束计算任务
2356 	}
2355 		goto EndCheckWar;	// 跳到结束计算任务
2356 	}
2358 	// 检查本国是否已用完本周所有跨服国战次数
2359 	if (dwMyAttackCounts>=dwMaxAttack)
2360 	{
2359 	if (dwMyAttackCounts>=dwMaxAttack)
2360 	{
2361 		sprintf_s(szBuf, sizeof(szBuf), "本周发起跨服国战次数已达上限！");
2362 		goto EndCheckWar;	// 跳到结束计算任务
2363 	}
2362 		goto EndCheckWar;	// 跳到结束计算任务
2363 	}
2364 	// 检查对方国是否已用完本周所有跨服国战次数
2365 	if (dwDefendCounts>=dwMaxDefend)
2366 	{
2380 			if ((DWORD)(pSiegeWar->nDawnTime)>dwStartTaskTime && (DWORD)(pSiegeWar->nDawnTime)<dwEndTaskTime)
2381 			{
2382 				sprintf_s(szBuf, sizeof(szBuf), "本国明天有本区国战，不能发起跨服国战！");
2383 				goto EndCheckWar;	// 跳到结束计算任务
2384 			}
2401 	return bRetFlag;
2402 }
2405 // 玩家请求发起跨服国战 DWORD dwFlag 操作标识 0.开战,1.结盟
2406 void CWarService::OnMsgRequestAddCountryWar(DWORD dwClientID,DWORD dwWorldID,DWORD dwCountryID,DWORD dwFlag)
2407 {
2408 	if (dwFlag>1)
2409 	{
2410 		ErrorLn("玩家请求发起跨服国战 操作标识(0.开战,1.结盟)无效： "<< dwFlag);
2411 		return;
2412 	}
2436 		return;
2437 	}
2439 	// 取地跨服国战系统接口
2440 	IWorldWar* pWorldWar = pCountryService->GetWorldWarPart();
2441 	if (pWorldWar==NULL)
2475 	if (pOfficerInfo==NULL)
2476 	{
2477 		sprintf_s(szBuf, sizeof(szBuf), "不是国家官员没有跨服国战相关权限！");
2478 	}
2479 	else if( !pOfficerPart->GetEnableFlag(COUNTRY_RIGHT_WAR) )
2479 	else if( !pOfficerPart->GetEnableFlag(COUNTRY_RIGHT_WAR) )
2480 	{	
2481 		sprintf_s(szBuf, sizeof(szBuf), "跨服国战相关功能暂时被禁用！");
2482 	}
2483 	else if( !pOfficerPart->HaveRight(pOfficerInfo->dwPlayerID,COUNTRY_RIGHT_WAR) )
2483 	else if( !pOfficerPart->HaveRight(pOfficerInfo->dwPlayerID,COUNTRY_RIGHT_WAR) )
2484 	{	
2485 		sprintf_s(szBuf, sizeof(szBuf), "没有跨服国战相关权限！");
2486 	}
2487 	else if (g_pMatchService->GetWarConfigSchemeInfo()->nWarOpen==0)
2487 	else if (g_pMatchService->GetWarConfigSchemeInfo()->nWarOpen==0)
2488 	{
2489 		sprintf_s(szBuf, sizeof(szBuf), "跨服国战相关功能禁用！");
2490 	}
2491 	else
2499 		return;
2500 	}
2502 	// 检查是否能发起跨服国战
2503 	if (!CheckCountryWorldWar(true,pUserInfo->id,pUserInfo->worldId,pUserInfo->worldId,pUserInfo->nation,dwWorldID,dwCountryID,dwFlag))
2504 	{
2517 			if (nInBudoTime == 1)
2518 			{
2519 				sprintf_s(szBuf, sizeof(szBuf), "武道会决赛期间，跨服国战相关功能禁用！");
2520 				gGlobalSocialServer->getChatService()->sendSystemTips(TipType_Operate, pUserInfo->id, InfoPos_ChatWindow|InfoPos_ActorRight, szBuf);
2521 				return;
2535 		sendData.dwCountryID		= dwCountryID;				// 目标国家ID
2536 		sendData.dwFlag				= dwFlag;					// 操作标识
2538 		//  请求检查跨服国战对方是否本区有国战 dwServerID:服务器ID ,跨区信息专用
2539 		g_pMatchService->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_RequestCheckCountryWar,0,0,0,(const char *)&sendData,sizeof(sendData));
2540 	}
2540 	}
2542 }
2543 // 请求检查跨服国战对方是否本区有国战
2544 void CWarService::OnMsgRequestCheckCountryWar(SMsgWarRequestAddCountryWar_O &node)
2545 {
2607 	if (dwSendServerID>0)
2608 	{
2609 		//  请求检查跨服国战对方是否本区有国战结果 dwServerID:服务器ID ,跨区信息专用
2610 		g_pMatchService->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_CheckCountryWarResult,dwResultFlag,0,0,(const char *)&node,sizeof(node));
2611 	}
2611 	}
2612 }
2614 // 请求检查跨服国战对方是否本区有国战结果
2615 void CWarService::OnMsgRequestCheckCountryWarResult(SMsgWarRequestAddCountryWar_O &node,DWORD dwResultFlag)
2616 {
2684 	}
2686 }
2688 // 发送参战跨服国战请求结果给本区社会服
2689 bool CWarService::OnBridgeRequestWarResultToLocal(DWORD dwWorldID, DWORD dwCountryID, DWORD dwFlag)
2690 {
2710 	return g_pMatchService->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_RequestAddCountryWarResult,dwWorldID,dwCountryID,dwFlag);
2711 }
2713 // 跨服国战延长国战任期
2714 bool CWarService::OnAddCountryWarKingTimeout(DWORD dwWorldID, DWORD dwCountryID)
2715 {
2785 			// 提示国王
2786 			char szBuf[512]={0};
2787 			sprintf_s(szBuf, sizeof(szBuf), "<rich color='#FF80FF'>参与跨服国战，您的任期延长至%d天后<rich color='default'>",pSiegeWarConfig->nKingOutDay);
2788 			gGlobalSocialServer->getChatService()->sendSystemTips(TipType_Operate, dwPlayerID, InfoPos_ChatWindow|InfoPos_ActorRight, szBuf);
2789 		}
2792 	return bFlag;
2793 }
2795 // purpose:		判断是否为跨服国战 交战国
2796 bool CWarService::IsCountryWarFight(UserInfo* MyInfo,UserInfo* TrageInfo)
2797 {
2813 		return false;
2814 	}
2816 	// 取地跨服国战系统接口
2817 	IWorldWar* pWorldWar = pCountryService->GetWorldWarPart();
2818 	if (pWorldWar==NULL)
2952 	}
2953 }
2956 // 玩家请求发起跨服国战 DWORD dwFlag 操作标识 0.开战,1.结盟
2957 void CWarService::RequestAddCountryWar(DWORD dwPlayerID,DWORD dwActorWorldID,DWORD dwFromWorldID,DWORD dwFromCountryID,DWORD dwWorldID,DWORD dwCountryID,DWORD dwFlag)
2958 {
2957 void CWarService::RequestAddCountryWar(DWORD dwPlayerID,DWORD dwActorWorldID,DWORD dwFromWorldID,DWORD dwFromCountryID,DWORD dwWorldID,DWORD dwCountryID,DWORD dwFlag)
2958 {
2959 	// 检查是否能发起跨服国战
2960 	if (!CheckCountryWorldWar(false,dwPlayerID,dwActorWorldID,dwFromWorldID,dwFromCountryID,dwWorldID,dwCountryID,dwFlag))
2961 	{
2969 		return;
2970 	}
2972 	// 取地跨服国战系统接口
2973 	IWorldWar* pWorldWar = pCountryService->GetWorldWarPart();
2974 	if (pWorldWar==NULL)
3014 		// 明天时间段
3015 		DWORD dwStartTaskTime =dwTodayTime+86400;
3017 		int nStartHourMin = g_pMatchService->GetWarConfigNumber(WarCfgNum_StartHourMin);		// 跨服国战开战时间：小时*100+分钟
3018 	
3019 		DWORD dwStartTimes = dwNowTimes;	// 开启时间
3059 		if (pSchemeInfo->nEnabled!=1)
3060 		{
3061 			sprintf_s(szBuf, sizeof(szBuf), "发起攻打[%s%s]跨服国战失败！跨服国战功能关闭",g_ExternalFacade.GetWorldName(dwWorldID),getCountryNameByID(dwCountryID,dwWorldID));
3062 		}
3063 		else
3063 		else
3064 		{
3065 			// 加入跨服国战信息
3066 			bool bOK = pWorldWar->AddWorldCountryWar(dwStartTimes,dwFightTimes,dwEndTimes,dwItemType,dwWarSceneID,dwFromWorldID,dwFromCountryID,dwWorldID,dwCountryID);
3067 			if (bOK)
3067 			if (bOK)
3068 			{
3069 				sprintf_s(szBuf, sizeof(szBuf), "发起攻打[%s%s]跨服国战成功！",g_ExternalFacade.GetWorldName(dwWorldID),getCountryNameByID(dwCountryID,dwWorldID));
3071 				// 发送参战跨服国战请求结果给攻方本区社会服
3072 				OnBridgeRequestWarResultToLocal(dwFromWorldID, dwFromCountryID, 1);
3072 				OnBridgeRequestWarResultToLocal(dwFromWorldID, dwFromCountryID, 1);
3073 				// 发送参战跨服国战请求结果给守方本区社会服
3074 				OnBridgeRequestWarResultToLocal(dwWorldID, dwCountryID, 1);
3075 			}
3076 			else
3077 			{
3078 				sprintf_s(szBuf, sizeof(szBuf), "发起攻打[%s%s]跨服国战失败！",g_ExternalFacade.GetWorldName(dwWorldID),getCountryNameByID(dwCountryID,dwWorldID));
3079 			}
3080 		}
3083 	else if(dwFlag==1)	//1.结盟
3084 	{
3085 		// 加入跨服国战盟国信息
3086 		bool bOK = pWorldWar->AddWarFriend(dwFromWorldID,dwFromCountryID,dwWorldID,dwCountryID);
3087 		if (bOK)
3087 		if (bOK)
3088 		{
3089 			sprintf_s(szBuf, sizeof(szBuf), "加[%s%s]为跨服国战盟国成功！",g_ExternalFacade.GetWorldName(dwWorldID),getCountryNameByID(dwCountryID,dwWorldID));
3090 		}
3091 		else
3091 		else
3092 		{
3093 			sprintf_s(szBuf, sizeof(szBuf), "加[%s%s]为跨服国战盟国失败！",g_ExternalFacade.GetWorldName(dwWorldID),getCountryNameByID(dwCountryID,dwWorldID));
3094 		}
3095 		gGlobalSocialServer->getChatService()->worldSendSystemTips(dwActorWorldID,TipType_Operate, dwPlayerID, InfoPos_ChatWindow|InfoPos_ActorRight, szBuf);
3098 }
3100 //////////////////////////////////////////////////////////////////////////
3102 // 新建跨服领地Boss战
3103 bool CWarService::NewCastleBossWar(bool bIsPublic,SCastleBossWarTaskInfo &node)
3104 {
3113 	if (dwServerID==0 || dwServerID==INVALID_SERVER_ID)
3114 	{
3115 		ErrorLn("开启跨服领地Boss战失败，原因：找不到合适的场景服服务器！");
3116 		return false;
3117 	}
3116 		return false;
3117 	}
3118 	ErrorLn("CWarService::NewCastleBossWar() :"<< dwServerID <<"号场景服上成功开启跨服领地Boss战！");
3119 	ostrbuf osb;
3120 	osb <<"加入时间="<<g_ExternalFacade.GetTimeString(node.dwAddTime)<<",开战时间="<<g_ExternalFacade.GetTimeString(node.dwStartTime)<<",文明等级="<<node.dwCivilGrade<<",BOSS_ID="<<node.dwBossID<<"，参战帮会：\r\n";
3135 	SCastleBossWarAddContext sendData;
3136 	sendData = node;
3138 	// 请求开跨服领地Boss战
3139 	g_pMatchService->SendDataToLocalServer(dwServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_RequestNewClanBossWar,node.dwWarTypeID,0,0,(const char *)&sendData,sizeof(sendData));
3141 	return true;
3141 	return true;
3142 }
3144 /** 加入跨服Boss战发起信息
3145 @param   LPSTR data : 上下文数据,为SCastleBossWarAddContext
3146 @param   size_t len	: 上下文数据长度
3162 	if (pMsg->dwCivilGrade==0 || pMsg->dwStartTime==0 || pMsg->dwSize==0 || pMsg->dwSize>COUNTRY_MAXID || pMsg->dwBossID==0 || pMsg->dwWarTypeID==WarType_None || pMsg->dwWarTypeID>=WarType_MaxID || COUNTRY_MAXID<3)
3163 	{
3164 		sprintf_s(szBuf, sizeof(szBuf), "加入跨服领地Boss战发起信息参数无效,世界文明等级=%d,战争场ID=%d,开战时间=%d,战场BOSSID=%d,是否在公共区开战=%d,参战阵营数量=%d,",
3165 			pMsg->dwCivilGrade,pMsg->dwWarTypeID,pMsg->dwStartTime,pMsg->dwBossID,pMsg->bIsPublic,pMsg->dwSize);
3166 		ErrorLn(szBuf);
3175 		{
3176 			bCheckListOK = false;
3177 			sprintf_s(szBuf, sizeof(szBuf), "加入跨服领地Boss战发起信息帮会参数无效,序号=%d,游戏世界ID=%d,国家ID=%d,帮会ID=%d,领地ID号=%d,帮会名称=%s,领地名称=%s",
3178 				i,clanNode.dwWorldID,clanNode.dwCountryID,clanNode.dwClanID,clanNode.dwCastleID,clanNode.szName,clanNode.szCastleName);
3179 			ErrorLn(szBuf);
3247 	return true;
3248 }
3250 // 取得跨服国家边境连通编号以(游戏世界ID+国家ID+类型)组数编号 为关键字
3251 DWORD CWarService::GetCountryWorldLinkKey(DWORD dwWorldID,DWORD dwCountryID,DWORD dwType)
3252 {
3312 	}
3314 	//// 世界文明 MatchWorldCountryLinkScore_Grade //////////////////////////////////////////////////////////////////////
3316 	DWORD dwCivilGradeLoRange = g_pMatchService->GetWarConfigNumber(WarCfgNum_CivilGradeLoRang);	// 跨服国战能跨文明等级下限 0
3317 	DWORD dwCivilGradeHiRange = g_pMatchService->GetWarConfigNumber(WarCfgNum_CivilGradeHiRang);	// 跨服国战能跨文明等级上限 1
3319 	// 检查对方国世界文明等级,用下限
3320 	if (node.dwCivilGrade>(matchNode.dwCivilGrade+dwCivilGradeLoRange))
3400 EndTask:
3402 	// 返回结果
3403 	matchResult.dwID			= matchNode.dwID;				// 撮合的跨服国家连通信息ID，(游戏世界ID,国家ID,类型)组合编号
3404 	matchResult.dwWorldID		= matchNode.dwWorldID;			// 撮合的国家所在游戏世界ID
3405 	matchResult.dwCountryID		= matchNode.dwCountryID;		// 撮合的国家ID
3404 	matchResult.dwWorldID		= matchNode.dwWorldID;			// 撮合的国家所在游戏世界ID
3405 	matchResult.dwCountryID		= matchNode.dwCountryID;		// 撮合的国家ID
3406 	matchResult.dwType			= matchNode.dwType;				// 撮合的跨服国家边境类型
3407 	matchResult.bMatchOK		= bRetFlag;						// 匹配结果
3408 	matchResult.dwScore			= (DWORD)fTotalScore;			// 匹配得分
3469 		return;
3470 	}
3472 	double fPowerRateMin	= (double)g_pMatchService->GetWarConfigNumber(WarCfgNum_ClanBoss_PowerRateMin)/COUNTRY_RATE_FNUM;		// 跨服撮合最小实力比 * 1/1000 (0~1000,默认700)
3473 	double fRandPowRate		= (double)g_pMatchService->GetWarConfigNumber(WarCfgNum_ClanBoss_RandPowRate)/COUNTRY_RATE_FNUM;		// 实力比随机调节系数，为实力比的pow指数 * 1/1000 (1000~10000,默认3000)
3473 	double fRandPowRate		= (double)g_pMatchService->GetWarConfigNumber(WarCfgNum_ClanBoss_RandPowRate)/COUNTRY_RATE_FNUM;		// 实力比随机调节系数，为实力比的pow指数 * 1/1000 (1000~10000,默认3000)
3475 	DWORD dwCivilGradeLoRange = g_pMatchService->GetWarConfigNumber(WarCfgNum_CivilGradeLoRang);	// 跨服国战能跨文明等级下限 0
3476 	DWORD dwCivilGradeHiRange = g_pMatchService->GetWarConfigNumber(WarCfgNum_CivilGradeHiRang);	// 跨服国战能跨文明等级上限 1
3478 	// 领地Boss战撮合处理,状态为 CastleBossWarTaskState_New表示等待撮合，CastleBossWarTaskState_Ready 表示已撮合成功了
3479 	for (TMAP_CastleBossWarTaskInfoList::iterator iter = m_mapCastleBossWarMatchList.begin(); iter != m_mapCastleBossWarMatchList.end(); iter++)
3655 		return;
3656 	}
3657 	// 取地跨服国战系统接口
3658 	IWorldWar* pWorldWar = pCountryService->GetWorldWarPart();
3659 	if (pWorldWar==NULL)
3693 		switch(node.dwState)
3694 		{
3695 		case CountryWorldWarState_None:		// 无效跨服国战
3696 			{
3697 			}
3697 			}
3698 			break;
3699 		case CountryWorldWarState_New:		// 新跨服国战（未启动）
3700 			{
3701 				// 开始战前准备
3733 	}while(pWorldWar->MoveNext());
3735 }
3738 // 跨服边境主任务处理
3739 void CWarService::DoBorderWarTask()
3740 {
3761 	DWORD dwNowTimes = (DWORD)time(NULL);
3763 	//char szBuf[512]={0};
3765 	// 处理创建跨服边境战任务
3766 	DWORD dwStartTimes	= 0;			// 开启时间
3767 	DWORD dwFightTimes	= 0;			// 开打时间
3767 	DWORD dwFightTimes	= 0;			// 开打时间
3768 	DWORD dwEndTimes	= 0;			// 战斗结束时间
3770 	bool bCanAddBorderWar = false;	// 是否能加入跨服边境
3771 	// 开启后冷却1小时,和生成创建跨服边境战任务时间段(开启前10分钟时段)配合，使系统只能进入处理一次
3772 	if (dwNowTimes>m_dwLastAddWorldBorderWarTimes+3600)
3773 	{
3792 			// 今天开始时间
3793 			DWORD dwTodayTime		= (DWORD) t_of_day;
3794 			DWORD dwStartHourMin	= (DWORD)pSchemeInfo->nOpenTime;		// 开跨服边境时间
3795 			dwFightTimes	= dwTodayTime+3600*(dwStartHourMin/100)+60*(dwStartHourMin%100);	// 开打时间
3796 			dwStartTimes	= dwFightTimes-(DWORD)pWarSchemeInfo->nReadyTime;			// 开启时间
3799 			if (dwNowTimes+600>dwStartTimes && dwNowTimes<dwStartTimes)
3800 			{
3801 				bCanAddBorderWar = true;	// 是否能加入跨服边境
3802 			}
3803 		}
3803 		}
3804 	}
3806 	// 可创建跨服边境战任务
3807 	if (bCanAddBorderWar)
3808 	{
3807 	if (bCanAddBorderWar)
3808 	{
3809 		// 最近创建跨服边境连通时间，用来冷却,和生成创建跨服边境战任务时间段(开启前10分钟时段)配合，使系统只能进入处理一次
3810 		m_dwLastAddWorldBorderWarTimes = dwNowTimes;
3812 		// 取得桥服务器连接器
3816 		if (pCountryService!=NULL && pBridgeConnector != NULL)
3817 		{
3818 			// 取地跨服国战系统接口
3819 			IWorldWar* pWorldWar = pCountryService->GetWorldWarPart();
3820 			if (pWorldWar!=NULL)
3845 						continue;
3846 					}
3848 					// 确定要创建跨服边境信息
3849 					m_dwWorldBorderLinkMaxID++;	// 最大跨服边境连通序号
3851 					SCountryWorldWarInfo addNode;	// 创建跨服边境信息
3852 					addNode.dwID				= m_dwWorldBorderLinkMaxID;				// 跨服国战信息ID，0为无效ID
3853 					addNode.dwPublicWorldID		= getThisGameWorldID();					// 所属公共区世界ID
3854 					addNode.dwStartTime			= dwStartTimes;							// 开始时间
3854 					addNode.dwStartTime			= dwStartTimes;							// 开始时间
3855 					addNode.dwEndTime			= dwEndTimes;							// 结束时间
3856 					addNode.dwType				= pSchemeInfo->nWarID;					// 跨服国战类型 EMWarItemType
3857 					addNode.dwState				= CountryWorldWarState_New;				// 状态 EMCountryWorldWarState
3858 					addNode.dwResultFlag		= 0;									// 结果标识 EMWarRaceResultType
3911 		switch(node.dwState)
3912 		{
3913 		case CountryWorldWarState_New:		// 新跨服边境（未启动）
3914 			{
3915 				// 开始战前准备
3917 				{
3918 					node.dwState = CountryWorldWarState_Ready;
3919 					// 开始创建跨服边境
3920 					NewCountryWorldBorderWar(bIsPublic,node);
3921 					// 开起后就删除节点
3956 	time(&long_time);
3957 	localtime_s(&local_time,&long_time);
3958 	// 周二重连跨服边境数据
3959 	if (bCheckWeekDay && local_time.tm_wday!=3)
3960 	{
3977 		return;
3978 	}
3979 	// 取地跨服国战系统接口
3980 	IWorldWar* pWorldWar = pCountryService->GetWorldWarPart();
3981 	if (pWorldWar==NULL)
4054 							node.dwWorldID			= pSocialPart->GetWorldID();				// 国家所在游戏世界ID
4055 							node.dwCountryID		= pCountry->GetID();						// 国家ID
4056 							node.dwType				= dwWarTypeID;								// 跨服国家边境类型
4057 							node.dwID				= GetCountryWorldLinkKey(node.dwWorldID,node.dwCountryID,node.dwType);	// 跨服国家连通信息ID，(游戏世界ID,国家ID,类型)组合编号
4058 							node.dwStateFlag		= MatchWorldCountryLink_Wait;				// 撮合状态 EMMatchWorldCountryLinkState
4059 							// 国家基本信息
4067 							node.dwCivilGrade		= pCountry->GetCivilGrade();				// 世界文明等级
4068 							node.dwCivilDot			= pCountry->GetCivilDot();					// 世界文明点数
4069 							// 取得跨服国家边境连通信息
4070 							SCountryWorldLinkInfo * pLinkInfo =	pWorldWar->GetCountryWorldLinkInfo(node.dwWorldID,node.dwCountryID,node.dwType);
4071 							if (pLinkInfo!=NULL)
4080 							
4081 							SMatchWorldCountryLinkOrderNode addNode;
4082 							addNode.dwID			= node.dwID;			// 跨服国家连通信息ID，(游戏世界ID,国家ID,类型)组合编号
4083 							addNode.dwWorldAttack	= node.dwWorldAttack;	// 国家综合攻击力
4084 							listMathLinkSort.push_back(addNode);
4152 			node.dwLinkWorldID		= 0;					// 连通国家所在游戏世界ID
4153 			node.dwLinkCountryID	= 0;					// 连通国家ID
4155 			// 跨服边境连通信息变化,保存入数据库
4156 			pWorldWar->OnWorldLinkInfoChanged(node.dwID);
4158 		}while(pWorldWar->Link_MoveNext());
4162 		{
4163 			SMathcWorldCountryLinkNode &node = iter->second;
4164 			// 取得跨服国家边境连通信息
4165 			SCountryWorldLinkInfo * pLinkInfo =	pWorldWar->GetCountryWorldLinkInfo(node.dwWorldID,node.dwCountryID,node.dwType);
4166 			// 发现没有，就新加一个节点
4167 			if (pLinkInfo==NULL)
4168 			{
4169 				// 加入跨服边境连通信息
4170 				SCountryWorldLinkInfo * pAddLinkInfo = pWorldWar->AddCountryWorldLinkInfo(node.dwWorldID,node.dwCountryID,node.dwType);
4171 				if (pAddLinkInfo!=NULL)
4171 				if (pAddLinkInfo!=NULL)
4172 				{
4173 					// 跨服边境连通信息变化,保存入数据库
4174 					pWorldWar->OnWorldLinkInfoChanged(pAddLinkInfo->dwID);
4175 				}
4176 				else
4177 				{
4178 					sprintf_s(szBuf, sizeof(szBuf), "加入跨服边境连通信息失败！,游戏世界ID=%d,国家ID=%d,战场项目类型=%d",node.dwWorldID,node.dwCountryID,node.dwType);
4179 					ErrorLn(szBuf);
4180 				}
4293 		{
4294 			SMathcWorldCountryLinkNode &node = iter->second;
4295 			// 取得跨服国家边境连通信息
4296 			SCountryWorldLinkInfo * pLinkInfo =	pWorldWar->GetCountryWorldLinkInfoByID(node.dwID);
4297 			// 发现没有，就新加一个节点
4312 				pLinkInfo->dwLinkCountryID	= 0;								// 连通国家ID
4313 			}
4315 			// 跨服边境连通信息变化,保存入数据库
4316 			pWorldWar->OnWorldLinkInfoChanged(pLinkInfo->dwID);
4317 		}
4322 	pWorldWar->UpdateAllServerData();
4323 }
4326 // 检查跨服连接和跨服国战信息是否正确,有问题报警
4327 void CWarService::CheckWorldAlert()
4328 {
4348 		return;
4349 	}
4350 	// 取地跨服国战系统接口
4351 	IWorldWar* pWorldWar = pCountryService->GetWorldWarPart();
4352 	if (pWorldWar==NULL)
4357 	// 以实际物理连接为准,来检查所有数据的有效
4359 	//////////////////////////////////////////////////////////////////////////
4360 	// 检查跨服国战记录
4362 	// 遍历所有记录
4363 	pWorldWar->MoveHead();
4390 			if (NULL==pBridgePart)
4391 			{
4392 				sprintf_s(szBuf, sizeof(szBuf), "跨服国战记录中的游戏区(%d)不存在! 记录ID=%d,所属公共区ID=%d,开始时间=%s,类型=%d,进攻世界ID=%d,进攻国家ID=%d,防御世界ID=%d,防御国家ID=%d,状态=%d",
4393 					dwCheckWorldID,node.dwID,node.dwPublicWorldID,g_ExternalFacade.GetTimeString(node.dwStartTime),node.dwType,node.dwAttackWorldID,node.dwAttackCountryID,node.dwDefendWorldID,node.dwDefendCountryID,node.dwState);
4395 				// 报警对应区没开
4402 	
4403 	//////////////////////////////////////////////////////////////////////////
4404 	// 检查跨服连接记录
4405 	// 要连接的战场配置项定义
4406 	static DWORD dwMatchLinkTypeList[1] =
4470 					continue;
4471 				}
4473 				// 取得跨服国家边境连通信息
4474 				SCountryWorldLinkInfo * pLinkInfo =	pWorldWar->GetCountryWorldLinkInfo(dwCheckWorldID,j,dwWarTypeID);
4475 				if (pLinkInfo==NULL)
4475 				if (pLinkInfo==NULL)
4476 				{
4477 					sprintf_s(szBuf, sizeof(szBuf), "跨服国家边境连通记录中没找到此国家的连接记录,这将导致这个国家进不了跨服边境,边境类型=%d,世界ID=%d,国家ID=%d",dwWarTypeID,dwCheckWorldID,j);
4479 					// 报警对应区没开
4480 					AlertBad(MG_AlertSrcType_DataBase,szBuf);
4496 		return;
4497 	}
4498 	// 取地跨服国战系统接口
4499 	IWorldWar* pWorldWar = pCountryService->GetWorldWarPart();
4500 	if (NULL == pWorldWar)
4587 	}
4588 }
4591 /* 强制让本区的跨服国战记录失效，用于处理公共区异常导致本区缓存的数据还运行的问题，不让客户端显示活动追踪及DIDA
4592 @Param	: DWORD dwDBID		跨服国战数据库记录ID
4593 */
4594 bool CWarService::AbandLocalCountryWorldWarInfo(DWORD dwDBID, DWORD dwState, DWORD dwRunStep)
4604 		return false;
4605 	}
4606 	// 取地跨服国战系统接口
4607 	IWorldWar* pWorldWar = pCountryService->GetWorldWarPart();
4608 	if (NULL == pWorldWar)
4611 	}
4613 	//////////////////////////////////////////////////////////////////////////
4614 	// 取得跨服国战信息
4615 	SCountryWorldWarInfo * pCountryWorldWarInfo = pWorldWar->GetWorldWarInfo(dwDBID);
4616 	if (pCountryWorldWarInfo == NULL)
4618 		return false;
4619 	}
4621 	// 使跨服国战记录无效
4622 	pCountryWorldWarInfo->dwState = CountryWorldWarState_None;	// 无效跨服国战 状态 EMCountryWorldWarState
4624 	//////////////////////////////////////////////////////////////////////////
4625 	// 广播国战状态给本区所有场景服
4632 void CWarService::OnEventNewDay(void)
4633 {
4634 	// 更新跨服国战活动追踪信息,dwWarID=0为发全部战场追踪信息
4635 	OnUpdateWorldWarTracker();
4635 	OnUpdateWorldWarTracker();
4637 	// 检查跨服连接和跨服国战信息是否正确,有问题报警
4638 	CheckWorldAlert();
4639 }

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\MatchService\WarService.cpp 152 KB CPP 文件 2014/2/25 14:31:44 2018/10/23 19:46:42 2018/10/23 19:46:42 205
37 	// 最大领地Boss开战场撮合序号
38 	m_dwBossWarMatchMaxID = 0;
39 	// 最大跨服边境连通序号
40 	m_dwWorldBorderLinkMaxID = 0;
40 	m_dwWorldBorderLinkMaxID = 0;
41 	// 最近创建跨服边境连通时间，用来冷却
42 	m_dwLastAddWorldBorderWarTimes = 0;
43 }
54 bool CWarService::Create()
55 {
56 	// 本区是否能开跨服国战
57 	if (g_pMatchService->IsCanOpenWorldWar())
58 	{
59 		// 主任务处理定时器
60 		g_ExternalFacade.SetTimer(ETimerEventID_DoTask, MATCH_ONETEAM_TIMEOUT, static_cast<ITimerHandler *>(this), "CWarService::Create");
61 		// 检测跨服国战记录任务处理定时器 
62 		g_ExternalFacade.SetTimer(ETimerEventID_DoCheckBadCountryWar, MATCH_CHECKBADWAR_INTERVAL, static_cast<ITimerHandler *>(this), "CWarService::Create");
63 		
113 			// 主任务处理
114 			DoTask();
115 			// 跨服边境主任务处理
116 			DoBorderWarTask();
117 		}
130 		}
131 		break;
132 	case ETimerEventID_DoCheckBadCountryWar:		// 检测跨服国战记录任务处理定时器 
133 		{
134 			DoCheckBadCountryWar();
215 	if (bZeroRemoveAll==true && dwWarID==0)
216 	{
217 		ErrorLn("删除场景服["<<dwServerID<<"]的所有跨服战场信息，可能是该场景服关闭或当机了！");
218 		for(TMAP_WarDataInfoList::iterator iter = m_mapWarList.begin(); iter != m_mapWarList.end();)
219 		{
501 		return;
502 	}
504 	// 所有客户端同步跨服国战活动追踪信息
505 	SendClientWorldWarTracker(info,0,false);
506 }
505 	SendClientWorldWarTracker(info,0,false);
506 }
508 // 所有客户端同步跨服战场活动追踪信息
509 bool CWarService::SendClientWorldWarTracker(UserInfo& userInfo,DWORD dwWarID,bool bRemoveTracker)
510 {
512 	DWORD dwID = 0;
513 	DWORD dwCount = 0;
515 	// 客户端同步跨服国战活动追踪信息
516 	if (dwWarID==0 || dwWarID==WarType_Country1)
517 	{
524 		}		
525 	}
527 	// 客户端同步跨服领地BOSS战活动追踪信息
528 	if (dwWarID==0 || dwWarID==WarType_ClanBoss)
529 	{
537 	}
538 	
539 	// 客户端同步跨服跨服边境战活动追踪信息
540 	if (dwWarID==0 || dwWarID==WarType_CountryBorder)
541 	{
556 	return true;
557 }
559 // 客户端同步跨服国战活动追踪信息
560 bool CWarService::SendClientCoutryWarTracker(UserInfo& userInfo)
561 {
566 		return false;
567 	}
569 	// 取地跨服国战系统接口
570 	IWorldWar* pWorldWar = pCountryService->GetWorldWarPart();
571 	if (pWorldWar==NULL)
615 		if (node.dwStartTime>=dwTodayTime && (node.dwState==CountryWorldWarState_New || node.dwState==CountryWorldWarState_Ready || node.dwState==CountryWorldWarState_Doing) )
616 		{
617 			// 检查国家在跨服国战中的参战类型 0.无,1.攻,2.守,3.攻盟友,4.守盟友
618 			DWORD dwMyJoinType = CheckCountryWorldWarType(dwFromWorldID,dwFromCountryID,node);	// 本国
619 			if (dwMyJoinType > 0)
630 	return bFound;
631 }
633 // 客户端同步跨服领地BOSS战活动追踪信息
634 bool CWarService::SendClientCastleBossWarTracker(UserInfo& userInfo)
635 {
660 	return g_pMatchService->SendDataToLocalServer(dwServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_BossWarTracker,dwClanID,dwPlayerID,0, (LPSTR)&clanNode, sizeof(clanNode));
661 }
663 // 客户端同步跨服跨服边境战活动追踪信息
664 bool CWarService::SendClientBorderWarTracker(UserInfo& userInfo)
665 {
670 		return false;
671 	}
673 	// 取地跨服国战系统接口
674 	IWorldWar* pWorldWar = pCountryService->GetWorldWarPart();
675 	if (pWorldWar==NULL)
677 		return false;
678 	}
680 	// 取得跨服国家边境连通信息
681 	SCountryWorldLinkInfo * pWarLinkInfo = pWorldWar->GetCountryWorldLinkInfo(userInfo.worldId,userInfo.nation,WarType_CountryBorder);
682 	if (pWarLinkInfo ==NULL)
710 		return false;
711 	}
713 	// 发送跨服国家边境信息到场景服
714 	return g_pMatchService->SendDataToLocalServer(userInfo.svrId,MSG_MATCH_DATE_WARMSG,Match_WarMsg_BorderWarTracker,userInfo.worldId,userInfo.nation,userInfo.id, (LPCSTR)pWarLinkInfo, sizeof(SCountryWorldLinkInfo));
715 }
714 	return g_pMatchService->SendDataToLocalServer(userInfo.svrId,MSG_MATCH_DATE_WARMSG,Match_WarMsg_BorderWarTracker,userInfo.worldId,userInfo.nation,userInfo.id, (LPCSTR)pWarLinkInfo, sizeof(SCountryWorldLinkInfo));
715 }
717 // 更新跨服国战活动追踪信息,dwWarID=0为发全部战场追踪信息
718 bool CWarService::OnUpdateWorldWarTracker(DWORD dwWarID)
719 {
736 	while (pUserInfo != NULL)
737 	{
738 		// 客户端同步跨服战场活动追踪信息
739 		SendClientWorldWarTracker( (*pUserInfo), dwWarID,true);
741 		pUserInfo = pUserManager->findNextUser();
819 	// 可持续时间长度 3分钟
820 	const DWORD dwContinueTimeLen = 5*60;
822 	// 新开跨服国战数据
823 	SCheckCountryWorldWarDataInfo node;
824 	node.warInfo	= warInfo;									// 国战节点数据
889 			continue;
890 		}
892 		// 取得跨服国战日期
893 		tm nexttm;
894 		memset(&nexttm,0,sizeof(nexttm));
912 				time_t	war_long_time = (time_t)(pSiegeWar->nDawnTime); 
913 				localtime_s(&wartm,&war_long_time);
915 				// 在明天，本区国战的战斗时间和跨服国战的开战日期一样
916 				if (wartm.tm_year == nexttm.tm_year && wartm.tm_yday == nexttm.tm_yday)
917 				{
934 				time_t	war_long_time = (time_t)(pSiegeWar->nDawnTime); 
935 				localtime_s(&wartm,&war_long_time);
937 				// 在明天，本区国战的战斗时间和跨服国战的开战日期一样
938 				if (wartm.tm_year == nexttm.tm_year && wartm.tm_yday == nexttm.tm_yday)
939 				{
982 	}
983 }
986 // 检测跨服国战记录任务处理定时器
987 void CWarService::DoCheckBadCountryWar()
988 {
1011 		return;
1012 	}
1014 	// 取地跨服国战系统接口
1015 	IWorldWar* pWorldWar = pCountryService->GetWorldWarPart();
1016 	if (NULL == pWorldWar)
1019 		return;
1020 	}
1022 	// 检查所有跨服国战记录有效性
1023 	pWorldWar->CheckAllBadWorldCountryWar();
1024 }
1065 		return;
1066 	}
1068 	// 取地跨服国战系统接口
1069 	IWorldWar* pWorldWar = pCountryService->GetWorldWarPart();
1070 	if (NULL == pWorldWar)
1074 	}
1075 	
1076 	// 取得跨服国战信息
1077 	SCountryWorldWarInfo * pCountryWarInfo = pWorldWar->GetWorldWarInfo(dwWarID);
1078 	if (NULL == pCountryWarInfo)
1088 	DWORD dwDefendWorldID	= warInfo.dwDefendWorldID;			// 防御国家所在游戏世界ID
1089 	DWORD dwDefendCountryID	= warInfo.dwDefendCountryID;		// 防御国家ID
1091 	sprintf_s(szMsgBuf, sizeof(szMsgBuf), "CWarService::OnBridgeMsgExistCountryWarData(): 收到跨服国战与本地国战有冲突,ID=%d,攻方(WorldID=%d,CountryID=%d),守方(WorldID=%d,CountryID=%d),冲突阵营ID=%d,开始时间=%s,结束时间=%s,跨服国战类型=%d,状态=%d",
1092 		dwWarID,dwAttackWorldID,dwAttackCountryID,dwDefendWorldID,dwDefendCountryID,dwClashCampID,
1093 		g_ExternalFacade.GetTimeString(warInfo.dwStartTime), g_ExternalFacade.GetTimeString(warInfo.dwEndTime),
1095 	ErrorLn(szMsgBuf);
1097 	// 发送提示给GM管理员
1098 	sprintf_s(szMsgBuf, sizeof(szMsgBuf), "跨服国战与本地国战有冲突,ID=%d,攻方(%s),守方(%s),阵营ID=%d,开始=%s,结束=%s,类型=%d,状态=%d",
1099 		dwWarID,g_ExternalFacade.GetWorldCountryName(dwAttackWorldID,dwAttackCountryID,false).c_str() ,g_ExternalFacade.GetWorldCountryName(dwDefendWorldID,dwDefendCountryID,false).c_str(), 
1100 		dwClashCampID,g_ExternalFacade.GetTimeString(warInfo.dwStartTime), g_ExternalFacade.GetTimeString(warInfo.dwEndTime),
1110 	sendData.strReporterName	= "系统举报";											// 角色名
1111 	sendData.dwCheaterID		= 0;													// 举报对象玩家角色ID
1112 	sendData.strCheaterName		= "跨服国战举报";										// 举报对象角色名
1113 	sendData.strTitle			= buffer.str();											// 举报证据（最大长度和聊天内容长短一致）
1114 	sendData.strMsg				= "社会服自动举报";										// 附加说明
1120 	warInfo.dwStartTime	= 0;		// 开始时间
1121 	warInfo.dwEndTime	= 0;		// 结束时间
1122 	// 设置国战记录状态为无效跨服国战并广播到其他区
1123 	pWorldWar->SetState(dwWarID,CountryWorldWarState_None);
1125 	// 给发布的国王进行提示
1123 	pWorldWar->SetState(dwWarID,CountryWorldWarState_None);
1125 	// 给发布的国王进行提示
1127 	// 取得攻方的跨服信息
1128 	IBridgeSocialPart* pMySocialPart = (IBridgeSocialPart*)pBridgeConnector->GetGameServerPartByTypeSubID(dwAttackWorldID,MSG_ENDPOINT_SOCIAL,0);
1129 	if (NULL == pMySocialPart)
1159 	if (dwClashCampID==1)
1160 	{
1161 		sprintf_s(szMsgBuf, sizeof(szMsgBuf), "<rich color='#FFFF0000'>由于本国已有国战，本次发起攻打[%s]跨服国战失效！<rich color='default'>",strCountryName.c_str());
1162 	}
1163 	else
1163 	else
1164 	{
1165 		sprintf_s(szMsgBuf, sizeof(szMsgBuf), "<rich color='#FFFF0000'>由于被进攻国已有国战，本次发起攻打[%s]跨服国战失效！<rich color='default'>",strCountryName.c_str());
1166 	}	
1168 	gGlobalSocialServer->getChatService()->worldSendSystemTips(dwAttackWorldID,TipType_Operate, dwPlayerID, InfoPos_ChatWindow|InfoPos_ActorRight, szMsgBuf);
1169 }
1172 // 增加本区国战占用电脑信息
1173 //dwWarType:国战类型；dwComputerID:计算机id; dwValue:过期时间，0表示函数内部计算； nType:0表示跨服，1表示本区
1174 void CWarService::AddWarComputerInfo(DWORD dwWarType, DWORD dwComputerID, DWORD dwValue/*=0*/, int nType/*=0*/)
1175 {
1208 	if (nType==0)
1209 	{
1210 		WarningLn("AddWarComputeInfo() 增加跨服战场占用电脑信息, WarType="<< dwWarType << ", ComputerID="<< dwComputerID << ", dwDirtyTime="<<dwDirtyTime);
1211 	}
1212 	else
1432 		}
1433 		break;
1434 	case Match_WarMsg_RequestAddCountryWar:		// 玩家请求发起跨服国战
1435 		{
1436 			if (nNewlen>0 || head->SrcEndPoint!=MSG_ENDPOINT_CLIENT)
1438 				break;
1439 			}
1440 			// 玩家请求发起跨服国战 DWORD dwFlag 操作标识 0.开战,1.结盟
1441 			OnMsgRequestAddCountryWar(endpointId,pMsg->dwUserData1,pMsg->dwUserData2,pMsg->dwUserData3);
1442 		}
1477 	switch(pMsg->dwMsgCode)
1478 	{
1479 	case Match_WarMsg_RequestCheckCountryWar:		// 请求检查跨服国战对方是否本区有国战
1480 		{
1481 			if (nNewlen!=sizeof(SMsgWarRequestAddCountryWar_O))
1481 			if (nNewlen!=sizeof(SMsgWarRequestAddCountryWar_O))
1482 			{
1483 				ErrorLn("收到桥服务器请求检查跨服国战对方是否本区有国战数据大小不符，nLen = "<<nNewlen);
1484 				break;
1485 			}
1485 			}
1487 			SMsgWarRequestAddCountryWar_O * pInfo = (SMsgWarRequestAddCountryWar_O *)pMsgData;
1488 			// 请求检查跨服国战对方是否本区有国战
1489 			OnMsgRequestCheckCountryWar(*pInfo);
1490 		}
1490 		}
1491 		break;
1492 	case Match_WarMsg_CheckCountryWarResult:		// 请求检查跨服国战对方是否本区有国战结果
1493 		{
1494 			if (nNewlen!=sizeof(SMsgWarRequestAddCountryWar_O))
1494 			if (nNewlen!=sizeof(SMsgWarRequestAddCountryWar_O))
1495 			{
1496 				ErrorLn("收到桥服务器请求检查跨服国战对方是否本区有国战结果 数据大小不符，nLen = "<<nNewlen);
1497 				break;
1498 			}
1498 			}
1500 			SMsgWarRequestAddCountryWar_O * pInfo = (SMsgWarRequestAddCountryWar_O *)pMsgData;
1501 			// 请求检查跨服国战对方是否本区有国战结果
1502 			OnMsgRequestCheckCountryWarResult(*pInfo,pMsg->dwUserData1);
1503 		}
1503 		}
1504 		break;
1505 	case Match_WarMsg_RequestAddCountryWar:		// 玩家请求发起跨服国战
1506 		{
1507 			if (nNewlen!=sizeof(SMsgWarRequestAddCountryWar_O))
1507 			if (nNewlen!=sizeof(SMsgWarRequestAddCountryWar_O))
1508 			{
1509 				ErrorLn("收到桥服务器玩家请求发起跨服国战信息数据大小不符，nLen = "<<nNewlen);
1510 				break;
1511 			}
1516 			}
1517 			SMsgWarRequestAddCountryWar_O * pInfo = (SMsgWarRequestAddCountryWar_O *)pMsgData;
1518 			// 玩家请求发起跨服国战 
1519 			RequestAddCountryWar(pInfo->dwPlayerID,pInfo->dwActorWorldID,pInfo->dwFromWorldID,pInfo->dwFromCountryID,pInfo->dwWorldID,pInfo->dwCountryID,pInfo->dwFlag);
1520 		}
1520 		}
1521 		break;
1522 	case Match_WarMsg_RequestNewCountryWar:		// 新建跨服国战
1523 		{
1524 			if (nNewlen!=sizeof(SCountryWorldWarInfo))
1524 			if (nNewlen!=sizeof(SCountryWorldWarInfo))
1525 			{
1526 				ErrorLn("收到桥服务器新建跨服国战信息数据大小不符，nLen = "<<nNewlen);
1527 				break;
1528 			}
1531 		}
1532 		break;
1533 	case Match_WarMsg_WorldCountryWarState:		// 跨服国战状态变化
1534 		{
1535 			if (nNewlen!=2*sizeof(DWORD))
1556 				break;
1557 			}
1558 			// 取地跨服国战系统接口
1559 			IWorldWar* pWorldWar = pCountryService->GetWorldWarPart();
1560 			if (pWorldWar==NULL)
1562 				break;
1563 			}
1564 			// 取得跨服国战信息
1565 			SCountryWorldWarInfo *pWarInfo = pWorldWar->GetWorldWarInfo(dwTaskWorldWarID);
1566 			if (pWarInfo!=NULL)
1645 				break;
1646 			}
1648 			// 刷新跨服共享国家信息
1649 			pBasePart->UpdateWorldCountryInfo();
1651 		}
1730 		}
1731 		break;
1732 	case Match_WarMsg_RequestKingInfo:	// 请求获取跨服国王信息
1733 		{
1734 			if (nNewlen>0)
1834 			}
1836 			// 加入国家GDP
1837 			pCountry->GetBasePart()->AddCountryPiont(nGetGDPValue,0,OssResAdd_CountryWar,"跨服国战加国家GDP");
1839 		}
1840 		break;
1839 		}
1840 		break;
1841 	case Match_WarMsg_RequestAddCountryWarResult:			// 玩家请求发起跨服国战结果
1842 		{
1843 			if (nNewlen>0)
1849 			DWORD dwCountryID	= pMsg->dwUserData2;		// 国家ID
1850 			DWORD dwFlag		= pMsg->dwUserData3;		// 标识
1852 			// 跨服国战延长国战任期
1853 			OnAddCountryWarKingTimeout(dwWorldID, dwCountryID);
1854 		}
1854 		}
1855 		break;
1856 	case Match_WarMsg_RequestAddClanBossWar:			// 请求发起跨服帮会领地BOSS战信息
1857 		{
1857 		{
1858 			// 加入跨服Boss战发起信息
1859 			AddCastleBossWarTask(pMsgData,nNewlen);
1860 		}
1894 	}
1896 }
1898 // 新建跨服国战
1899 bool CWarService::NewCountryWorldWar(bool bIsPublic,SCountryWorldWarInfo &node)
1900 {
1925 	if (dwServerID==0 || dwServerID==INVALID_SERVER_ID)
1926 	{
1927 		ErrorLn("开启跨服国战失败，原因：找不到合适的场景服服务器！ID="<<node.dwID<<",WarItemType="<<node.dwType<<",情景ID="<<node.dwData2<<",进攻方（WorldID="<<node.dwAttackWorldID <<",CountryID="<<node.dwAttackCountryID<<"）,防御方（WorldID="<<node.dwDefendWorldID<<",CountryID="<<node.dwDefendCountryID<<"）,副本开启时间="<<g_ExternalFacade.GetTimeString(node.dwStartTime)<<",开战时间="<<g_ExternalFacade.GetTimeString(node.dwData1)<<",结束时间="<<g_ExternalFacade.GetTimeString(node.dwEndTime) );
1928 		return false;
1929 	}
1928 		return false;
1929 	}
1930 	ErrorLn("CWarService::NewCountryWorldWar() :"<< dwServerID <<"号场景服上成功开启跨服国战！ID="<<node.dwID<<",WarItemType="<<node.dwType<<",情景ID="<<node.dwData2<<",进攻方（WorldID="<<node.dwAttackWorldID <<",CountryID="<<node.dwAttackCountryID<<"）,防御方（WorldID="<<node.dwDefendWorldID<<",CountryID="<<node.dwDefendCountryID<<"）,副本开启时间="<<g_ExternalFacade.GetTimeString(node.dwStartTime)<<",开战时间="<<g_ExternalFacade.GetTimeString(node.dwData1)<<",结束时间="<<g_ExternalFacade.GetTimeString(node.dwEndTime) );
1932 	// 加入服务器开战场信息
1933 	AddServerOpenWarInfo(dwServerID,node.dwType);
1932 	// 加入服务器开战场信息
1933 	AddServerOpenWarInfo(dwServerID,node.dwType);
1935 	// 请求开跨服国战
1936 	g_pMatchService->SendDataToLocalServer(dwServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_RequestNewCountryWar,node.dwType,0,0,(const char *)&node,sizeof(node));
1938 	return true;
1938 	return true;
1939 }
1941 // 新建跨服边境
1942 bool CWarService::NewCountryWorldBorderWar(bool bIsPublic,SCountryWorldWarInfo &node)
1943 {
1952 	if (dwServerID==0 || dwServerID==INVALID_SERVER_ID)
1953 	{
1954 		ErrorLn("开启跨服边境失败，原因：找不到合适的场景服服务器！ID="<<node.dwID<<",WarItemType="<<node.dwType<<",情景ID="<<node.dwData2<<",进攻方（WorldID="<<node.dwAttackWorldID <<",CountryID="<<node.dwAttackCountryID<<"）,防御方（WorldID="<<node.dwDefendWorldID<<",CountryID="<<node.dwDefendCountryID<<"）,副本开启时间="<<g_ExternalFacade.GetTimeString(node.dwStartTime)<<",开战时间="<<g_ExternalFacade.GetTimeString(node.dwData1)<<",结束时间="<<g_ExternalFacade.GetTimeString(node.dwEndTime) );
1955 		return false;
1956 	}
1955 		return false;
1956 	}
1957 	ErrorLn("CWarService::NewCountryWorldBorderWar() :"<< dwServerID <<"号场景服上成功开启跨服边境！ID="<<node.dwID<<",WarItemType="<<node.dwType<<",情景ID="<<node.dwData2<<",进攻方（WorldID="<<node.dwAttackWorldID <<",CountryID="<<node.dwAttackCountryID<<"）,防御方（WorldID="<<node.dwDefendWorldID<<",CountryID="<<node.dwDefendCountryID<<"）,副本开启时间="<<g_ExternalFacade.GetTimeString(node.dwStartTime)<<",开战时间="<<g_ExternalFacade.GetTimeString(node.dwData1)<<",结束时间="<<g_ExternalFacade.GetTimeString(node.dwEndTime) );
1959 	// 加入服务器开战场信息
1960 	AddServerOpenWarInfo(dwServerID,node.dwType);
1959 	// 加入服务器开战场信息
1960 	AddServerOpenWarInfo(dwServerID,node.dwType);
1962 	// 请求开跨服国战
1963 	g_pMatchService->SendDataToLocalServer(dwServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_RequestNewBorderWar,node.dwType,0,0,(const char *)&node,sizeof(node));
1965 	return true;
1965 	return true;
1966 }
1969 // 检查国家在跨服国战中的参战类型
1970 DWORD CWarService::CheckCountryWorldWarType(DWORD dwWorldID,DWORD dwCountryID,SCountryWorldWarInfo &node)
1971 {
1994 	return 0;
1995 }
1998 // 检查是否能发起跨服国战 DWORD dwFlag 操作标识 0.开战,1.结盟
1999 bool CWarService::CheckCountryWorldWar(bool IsLocal,DWORD dwPlayerID,DWORD dwActorWorldID,DWORD dwFromWorldID,DWORD dwFromCountryID,DWORD dwWorldID,DWORD dwCountryID,DWORD dwFlag)
2000 {
1999 bool CWarService::CheckCountryWorldWar(bool IsLocal,DWORD dwPlayerID,DWORD dwActorWorldID,DWORD dwFromWorldID,DWORD dwFromCountryID,DWORD dwWorldID,DWORD dwCountryID,DWORD dwFlag)
2000 {
2001 	// 如果跨服国战开战时间为0,表示测试版，不检测
2002 	int nStartHourMin = g_pMatchService->GetWarConfigNumber(WarCfgNum_StartHourMin);		// 跨服国战开战时间：小时*100+分钟
2003 	if (nStartHourMin==0 && getThisGameWorldID()>=3000)
2004 	{
2024 		return false;
2025 	}
2027 	// 取地跨服国战系统接口
2028 	IWorldWar* pWorldWar = pCountryService->GetWorldWarPart();
2029 	if (pWorldWar==NULL)
2046 		goto EndCheckWar;	// 跳到结束计算任务
2047 	}
2049 	// 取得双方的跨服信息
2050 	IBridgeSocialPart* pMySocialPart = (IBridgeSocialPart*)pBridgeConnector->GetGameServerPartByTypeSubID(dwFromWorldID,MSG_ENDPOINT_SOCIAL,0);
2051 	IBridgeSocialPart* pSocialPart = (IBridgeSocialPart*)pBridgeConnector->GetGameServerPartByTypeSubID(dwWorldID,MSG_ENDPOINT_SOCIAL,0);
2052 	if (pMySocialPart==NULL || pSocialPart==NULL)
2053 	{
2054 		sprintf_s(szBuf, sizeof(szBuf), "找不到跨服相关信息！");
2055 		goto EndCheckWar;	// 跳到结束计算任务
2056 	}
2060 	if (pMyBridgeCountry==NULL || pBridgeCountry==NULL)
2061 	{
2062 		sprintf_s(szBuf, sizeof(szBuf), "找不到跨服相关国家信息！");
2063 		goto EndCheckWar;	// 跳到结束计算任务
2064 	}
2064 	}
2065 	
2066 	// 检查对方国是否能开跨服国战
2067 	if (g_pMatchService->IsCloseWorldCountryWar(dwFromWorldID))
2068 	{
2067 	if (g_pMatchService->IsCloseWorldCountryWar(dwFromWorldID))
2068 	{
2069 		sprintf_s(szBuf, sizeof(szBuf), "你所在游戏区暂时关闭跨服国战！");
2070 		goto EndCheckWar;	// 跳到结束计算任务
2071 	}
2072 	if (g_pMatchService->IsCloseWorldCountryWar(dwWorldID))
2073 	{
2074 		sprintf_s(szBuf, sizeof(szBuf), "指定国家所在游戏区暂时关闭跨服国战！");
2075 		goto EndCheckWar;	// 跳到结束计算任务
2076 	}
2078 	DWORD dwCivilGrade = pBridgeCountry->GetCivilGrade();			// 他国世界文明等级
2079 	DWORD dwMyCivilGrade = pMyBridgeCountry->GetCivilGrade();		// 本国世界文明等级
2081 	DWORD dwCivilGradeLoRange = g_pMatchService->GetWarConfigNumber(WarCfgNum_CivilGradeLoRang);	// 跨服国战能跨文明等级下限
2082 	DWORD dwCivilGradeHiRange = g_pMatchService->GetWarConfigNumber(WarCfgNum_CivilGradeHiRang);	// 跨服国战能跨文明等级上限
2084 	// 检查攻防指数是否匹配
2085 	if (dwFlag==1)	// 结盟
2178 		}
2179 	}
2181 	// 检查跨服国战相关次数 
2182 	DWORD dwDayMaxWar	= (DWORD)g_pMatchService->GetWarConfigNumber(WarCfgNum_RunWorldWarMax);			// 一天最多数
2183 	DWORD dwMaxAttack	= (DWORD)g_pMatchService->GetWarConfigNumber(WarCfgNum_WeekAttackMax);			// 最多进攻数
2244 		if (node.dwStartTime>dwWeekStartTime && node.dwStartTime<dwWeekEndTime)
2245 		{
2246 			// 检查国家在跨服国战中的参战类型 0.无,1.攻,2.守,3.攻盟友,4.守盟友
2247 			DWORD dwMyJoinType = CheckCountryWorldWarType(dwFromWorldID,dwFromCountryID,node);	// 本国
2248 			DWORD dwJoinType = CheckCountryWorldWarType(dwWorldID,dwCountryID,node);			// 他国
2304 		if (dwMyFightCounts1+dwMyFightCounts2<=0)
2305 		{
2306 			sprintf_s(szBuf, sizeof(szBuf), "本国没有跨服国战，不能指定国战结盟！");
2307 		}
2308 		else if (dwFightCounts1+dwFightCounts2+dwFightCounts3>0)
2308 		else if (dwFightCounts1+dwFightCounts2+dwFightCounts3>0)
2309 		{
2310 			sprintf_s(szBuf, sizeof(szBuf), "指定国家明天已有跨服国战！");
2311 		}
2312 		else if (dwHelpCounts>=dwMaxHelp)
2312 		else if (dwHelpCounts>=dwMaxHelp)
2313 		{
2314 			sprintf_s(szBuf, sizeof(szBuf), "指定国家本周参于跨服国战结盟次数已达上限，请换其它国家结盟！");
2315 		}
2316 		else
2320 		goto EndCheckWar;	// 跳到结束计算任务
2321 	}
2323 	// 检查明天已有跨服国战
2324 	if (nowtm.tm_wday==4)
2325 	{
2324 	if (nowtm.tm_wday==4)
2325 	{
2326 		sprintf_s(szBuf, sizeof(szBuf), "明天是国王争霸赛时间，不能发起跨服国战！");
2327 		goto EndCheckWar;	// 跳到结束计算任务
2328 	}
2327 		goto EndCheckWar;	// 跳到结束计算任务
2328 	}
2330 	// 检查是否在天的结束或开始时间段,就不能发起,解决服务器时间不同步导致本国和跨服同时发起的问题
2331 	if ( (nowtm.tm_hour==23 && nowtm.tm_min>50) || (nowtm.tm_hour==0 && nowtm.tm_min<10) )
2332 	{
2331 	if ( (nowtm.tm_hour==23 && nowtm.tm_min>50) || (nowtm.tm_hour==0 && nowtm.tm_min<10) )
2332 	{
2333 		sprintf_s(szBuf, sizeof(szBuf), "现在时间处于[23:50~0:10]时间段，不能发起跨服国战！");
2334 		goto EndCheckWar;	// 跳到结束计算任务
2335 	}
2334 		goto EndCheckWar;	// 跳到结束计算任务
2335 	}
2337 	// 检查明天已有跨服国战
2338 	if (dwMyFightCounts1+dwMyFightCounts2+dwMyFightCounts3>0)
2339 	{
2338 	if (dwMyFightCounts1+dwMyFightCounts2+dwMyFightCounts3>0)
2339 	{
2340 		sprintf_s(szBuf, sizeof(szBuf), "本国明天已有跨服国战！");
2341 		goto EndCheckWar;	// 跳到结束计算任务
2342 	}
2341 		goto EndCheckWar;	// 跳到结束计算任务
2342 	}
2344 	// 检查明天已有跨服国战
2345 	if (dwFightCounts1+dwFightCounts2+dwFightCounts3>0)
2346 	{
2345 	if (dwFightCounts1+dwFightCounts2+dwFightCounts3>0)
2346 	{
2347 		sprintf_s(szBuf, sizeof(szBuf), "指定国家明天已有跨服国战！");
2348 		goto EndCheckWar;	// 跳到结束计算任务
2349 	}
2348 		goto EndCheckWar;	// 跳到结束计算任务
2349 	}
2351 	// 检查明天跨服国战次数
2352 	if (dwOnWarCounts>=dwDayMaxWar)
2353 	{
2352 	if (dwOnWarCounts>=dwDayMaxWar)
2353 	{
2354 		sprintf_s(szBuf, sizeof(szBuf), "明天开跨服国战数已到上限，请明天再来！");
2355 		goto EndCheckWar;	// 跳到结束计算任务
2356 	}
2355 		goto EndCheckWar;	// 跳到结束计算任务
2356 	}
2358 	// 检查本国是否已用完本周所有跨服国战次数
2359 	if (dwMyAttackCounts>=dwMaxAttack)
2360 	{
2359 	if (dwMyAttackCounts>=dwMaxAttack)
2360 	{
2361 		sprintf_s(szBuf, sizeof(szBuf), "本周发起跨服国战次数已达上限！");
2362 		goto EndCheckWar;	// 跳到结束计算任务
2363 	}
2362 		goto EndCheckWar;	// 跳到结束计算任务
2363 	}
2364 	// 检查对方国是否已用完本周所有跨服国战次数
2365 	if (dwDefendCounts>=dwMaxDefend)
2366 	{
2380 			if ((DWORD)(pSiegeWar->nDawnTime)>dwStartTaskTime && (DWORD)(pSiegeWar->nDawnTime)<dwEndTaskTime)
2381 			{
2382 				sprintf_s(szBuf, sizeof(szBuf), "本国明天有本区国战，不能发起跨服国战！");
2383 				goto EndCheckWar;	// 跳到结束计算任务
2384 			}
2401 	return bRetFlag;
2402 }
2405 // 玩家请求发起跨服国战 DWORD dwFlag 操作标识 0.开战,1.结盟
2406 void CWarService::OnMsgRequestAddCountryWar(DWORD dwClientID,DWORD dwWorldID,DWORD dwCountryID,DWORD dwFlag)
2407 {
2408 	if (dwFlag>1)
2409 	{
2410 		ErrorLn("玩家请求发起跨服国战 操作标识(0.开战,1.结盟)无效： "<< dwFlag);
2411 		return;
2412 	}
2436 		return;
2437 	}
2439 	// 取地跨服国战系统接口
2440 	IWorldWar* pWorldWar = pCountryService->GetWorldWarPart();
2441 	if (pWorldWar==NULL)
2475 	if (pOfficerInfo==NULL)
2476 	{
2477 		sprintf_s(szBuf, sizeof(szBuf), "不是国家官员没有跨服国战相关权限！");
2478 	}
2479 	else if( !pOfficerPart->GetEnableFlag(COUNTRY_RIGHT_WAR) )
2479 	else if( !pOfficerPart->GetEnableFlag(COUNTRY_RIGHT_WAR) )
2480 	{	
2481 		sprintf_s(szBuf, sizeof(szBuf), "跨服国战相关功能暂时被禁用！");
2482 	}
2483 	else if( !pOfficerPart->HaveRight(pOfficerInfo->dwPlayerID,COUNTRY_RIGHT_WAR) )
2483 	else if( !pOfficerPart->HaveRight(pOfficerInfo->dwPlayerID,COUNTRY_RIGHT_WAR) )
2484 	{	
2485 		sprintf_s(szBuf, sizeof(szBuf), "没有跨服国战相关权限！");
2486 	}
2487 	else if (g_pMatchService->GetWarConfigSchemeInfo()->nWarOpen==0)
2487 	else if (g_pMatchService->GetWarConfigSchemeInfo()->nWarOpen==0)
2488 	{
2489 		sprintf_s(szBuf, sizeof(szBuf), "跨服国战相关功能禁用！");
2490 	}
2491 	else
2499 		return;
2500 	}
2502 	// 检查是否能发起跨服国战
2503 	if (!CheckCountryWorldWar(true,pUserInfo->id,pUserInfo->worldId,pUserInfo->worldId,pUserInfo->nation,dwWorldID,dwCountryID,dwFlag))
2504 	{
2517 			if (nInBudoTime == 1)
2518 			{
2519 				sprintf_s(szBuf, sizeof(szBuf), "武道会决赛期间，跨服国战相关功能禁用！");
2520 				gGlobalSocialServer->getChatService()->sendSystemTips(TipType_Operate, pUserInfo->id, InfoPos_ChatWindow|InfoPos_ActorRight, szBuf);
2521 				return;
2535 		sendData.dwCountryID		= dwCountryID;				// 目标国家ID
2536 		sendData.dwFlag				= dwFlag;					// 操作标识
2538 		//  请求检查跨服国战对方是否本区有国战 dwServerID:服务器ID ,跨区信息专用
2539 		g_pMatchService->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_RequestCheckCountryWar,0,0,0,(const char *)&sendData,sizeof(sendData));
2540 	}
2540 	}
2542 }
2543 // 请求检查跨服国战对方是否本区有国战
2544 void CWarService::OnMsgRequestCheckCountryWar(SMsgWarRequestAddCountryWar_O &node)
2545 {
2607 	if (dwSendServerID>0)
2608 	{
2609 		//  请求检查跨服国战对方是否本区有国战结果 dwServerID:服务器ID ,跨区信息专用
2610 		g_pMatchService->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_CheckCountryWarResult,dwResultFlag,0,0,(const char *)&node,sizeof(node));
2611 	}
2611 	}
2612 }
2614 // 请求检查跨服国战对方是否本区有国战结果
2615 void CWarService::OnMsgRequestCheckCountryWarResult(SMsgWarRequestAddCountryWar_O &node,DWORD dwResultFlag)
2616 {
2684 	}
2686 }
2688 // 发送参战跨服国战请求结果给本区社会服
2689 bool CWarService::OnBridgeRequestWarResultToLocal(DWORD dwWorldID, DWORD dwCountryID, DWORD dwFlag)
2690 {
2710 	return g_pMatchService->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_RequestAddCountryWarResult,dwWorldID,dwCountryID,dwFlag);
2711 }
2713 // 跨服国战延长国战任期
2714 bool CWarService::OnAddCountryWarKingTimeout(DWORD dwWorldID, DWORD dwCountryID)
2715 {
2785 			// 提示国王
2786 			char szBuf[512]={0};
2787 			sprintf_s(szBuf, sizeof(szBuf), "<rich color='#FF80FF'>参与跨服国战，您的任期延长至%d天后<rich color='default'>",pSiegeWarConfig->nKingOutDay);
2788 			gGlobalSocialServer->getChatService()->sendSystemTips(TipType_Operate, dwPlayerID, InfoPos_ChatWindow|InfoPos_ActorRight, szBuf);
2789 		}
2792 	return bFlag;
2793 }
2795 // purpose:		判断是否为跨服国战 交战国
2796 bool CWarService::IsCountryWarFight(UserInfo* MyInfo,UserInfo* TrageInfo)
2797 {
2813 		return false;
2814 	}
2816 	// 取地跨服国战系统接口
2817 	IWorldWar* pWorldWar = pCountryService->GetWorldWarPart();
2818 	if (pWorldWar==NULL)
2952 	}
2953 }
2956 // 玩家请求发起跨服国战 DWORD dwFlag 操作标识 0.开战,1.结盟
2957 void CWarService::RequestAddCountryWar(DWORD dwPlayerID,DWORD dwActorWorldID,DWORD dwFromWorldID,DWORD dwFromCountryID,DWORD dwWorldID,DWORD dwCountryID,DWORD dwFlag)
2958 {
2957 void CWarService::RequestAddCountryWar(DWORD dwPlayerID,DWORD dwActorWorldID,DWORD dwFromWorldID,DWORD dwFromCountryID,DWORD dwWorldID,DWORD dwCountryID,DWORD dwFlag)
2958 {
2959 	// 检查是否能发起跨服国战
2960 	if (!CheckCountryWorldWar(false,dwPlayerID,dwActorWorldID,dwFromWorldID,dwFromCountryID,dwWorldID,dwCountryID,dwFlag))
2961 	{
2969 		return;
2970 	}
2972 	// 取地跨服国战系统接口
2973 	IWorldWar* pWorldWar = pCountryService->GetWorldWarPart();
2974 	if (pWorldWar==NULL)
3014 		// 明天时间段
3015 		DWORD dwStartTaskTime =dwTodayTime+86400;
3017 		int nStartHourMin = g_pMatchService->GetWarConfigNumber(WarCfgNum_StartHourMin);		// 跨服国战开战时间：小时*100+分钟
3018 	
3019 		DWORD dwStartTimes = dwNowTimes;	// 开启时间
3059 		if (pSchemeInfo->nEnabled!=1)
3060 		{
3061 			sprintf_s(szBuf, sizeof(szBuf), "发起攻打[%s%s]跨服国战失败！跨服国战功能关闭",g_ExternalFacade.GetWorldName(dwWorldID),getCountryNameByID(dwCountryID,dwWorldID));
3062 		}
3063 		else
3063 		else
3064 		{
3065 			// 加入跨服国战信息
3066 			bool bOK = pWorldWar->AddWorldCountryWar(dwStartTimes,dwFightTimes,dwEndTimes,dwItemType,dwWarSceneID,dwFromWorldID,dwFromCountryID,dwWorldID,dwCountryID);
3067 			if (bOK)
3067 			if (bOK)
3068 			{
3069 				sprintf_s(szBuf, sizeof(szBuf), "发起攻打[%s%s]跨服国战成功！",g_ExternalFacade.GetWorldName(dwWorldID),getCountryNameByID(dwCountryID,dwWorldID));
3071 				// 发送参战跨服国战请求结果给攻方本区社会服
3072 				OnBridgeRequestWarResultToLocal(dwFromWorldID, dwFromCountryID, 1);
3072 				OnBridgeRequestWarResultToLocal(dwFromWorldID, dwFromCountryID, 1);
3073 				// 发送参战跨服国战请求结果给守方本区社会服
3074 				OnBridgeRequestWarResultToLocal(dwWorldID, dwCountryID, 1);
3075 			}
3076 			else
3077 			{
3078 				sprintf_s(szBuf, sizeof(szBuf), "发起攻打[%s%s]跨服国战失败！",g_ExternalFacade.GetWorldName(dwWorldID),getCountryNameByID(dwCountryID,dwWorldID));
3079 			}
3080 		}
3083 	else if(dwFlag==1)	//1.结盟
3084 	{
3085 		// 加入跨服国战盟国信息
3086 		bool bOK = pWorldWar->AddWarFriend(dwFromWorldID,dwFromCountryID,dwWorldID,dwCountryID);
3087 		if (bOK)
3087 		if (bOK)
3088 		{
3089 			sprintf_s(szBuf, sizeof(szBuf), "加[%s%s]为跨服国战盟国成功！",g_ExternalFacade.GetWorldName(dwWorldID),getCountryNameByID(dwCountryID,dwWorldID));
3090 		}
3091 		else
3091 		else
3092 		{
3093 			sprintf_s(szBuf, sizeof(szBuf), "加[%s%s]为跨服国战盟国失败！",g_ExternalFacade.GetWorldName(dwWorldID),getCountryNameByID(dwCountryID,dwWorldID));
3094 		}
3095 		gGlobalSocialServer->getChatService()->worldSendSystemTips(dwActorWorldID,TipType_Operate, dwPlayerID, InfoPos_ChatWindow|InfoPos_ActorRight, szBuf);
3098 }
3100 //////////////////////////////////////////////////////////////////////////
3102 // 新建跨服领地Boss战
3103 bool CWarService::NewCastleBossWar(bool bIsPublic,SCastleBossWarTaskInfo &node)
3104 {
3113 	if (dwServerID==0 || dwServerID==INVALID_SERVER_ID)
3114 	{
3115 		ErrorLn("开启跨服领地Boss战失败，原因：找不到合适的场景服服务器！");
3116 		return false;
3117 	}
3116 		return false;
3117 	}
3118 	ErrorLn("CWarService::NewCastleBossWar() :"<< dwServerID <<"号场景服上成功开启跨服领地Boss战！");
3119 	ostrbuf osb;
3120 	osb <<"加入时间="<<g_ExternalFacade.GetTimeString(node.dwAddTime)<<",开战时间="<<g_ExternalFacade.GetTimeString(node.dwStartTime)<<",文明等级="<<node.dwCivilGrade<<",BOSS_ID="<<node.dwBossID<<"，参战帮会：\r\n";
3135 	SCastleBossWarAddContext sendData;
3136 	sendData = node;
3138 	// 请求开跨服领地Boss战
3139 	g_pMatchService->SendDataToLocalServer(dwServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_RequestNewClanBossWar,node.dwWarTypeID,0,0,(const char *)&sendData,sizeof(sendData));
3141 	return true;
3141 	return true;
3142 }
3144 /** 加入跨服Boss战发起信息
3145 @param   LPSTR data : 上下文数据,为SCastleBossWarAddContext
3146 @param   size_t len	: 上下文数据长度
3162 	if (pMsg->dwCivilGrade==0 || pMsg->dwStartTime==0 || pMsg->dwSize==0 || pMsg->dwSize>COUNTRY_MAXID || pMsg->dwBossID==0 || pMsg->dwWarTypeID==WarType_None || pMsg->dwWarTypeID>=WarType_MaxID || COUNTRY_MAXID<3)
3163 	{
3164 		sprintf_s(szBuf, sizeof(szBuf), "加入跨服领地Boss战发起信息参数无效,世界文明等级=%d,战争场ID=%d,开战时间=%d,战场BOSSID=%d,是否在公共区开战=%d,参战阵营数量=%d,",
3165 			pMsg->dwCivilGrade,pMsg->dwWarTypeID,pMsg->dwStartTime,pMsg->dwBossID,pMsg->bIsPublic,pMsg->dwSize);
3166 		ErrorLn(szBuf);
3175 		{
3176 			bCheckListOK = false;
3177 			sprintf_s(szBuf, sizeof(szBuf), "加入跨服领地Boss战发起信息帮会参数无效,序号=%d,游戏世界ID=%d,国家ID=%d,帮会ID=%d,领地ID号=%d,帮会名称=%s,领地名称=%s",
3178 				i,clanNode.dwWorldID,clanNode.dwCountryID,clanNode.dwClanID,clanNode.dwCastleID,clanNode.szName,clanNode.szCastleName);
3179 			ErrorLn(szBuf);
3247 	return true;
3248 }
3250 // 取得跨服国家边境连通编号以(游戏世界ID+国家ID+类型)组数编号 为关键字
3251 DWORD CWarService::GetCountryWorldLinkKey(DWORD dwWorldID,DWORD dwCountryID,DWORD dwType)
3252 {
3312 	}
3314 	//// 世界文明 MatchWorldCountryLinkScore_Grade //////////////////////////////////////////////////////////////////////
3316 	DWORD dwCivilGradeLoRange = g_pMatchService->GetWarConfigNumber(WarCfgNum_CivilGradeLoRang);	// 跨服国战能跨文明等级下限 0
3317 	DWORD dwCivilGradeHiRange = g_pMatchService->GetWarConfigNumber(WarCfgNum_CivilGradeHiRang);	// 跨服国战能跨文明等级上限 1
3319 	// 检查对方国世界文明等级,用下限
3320 	if (node.dwCivilGrade>(matchNode.dwCivilGrade+dwCivilGradeLoRange))
3400 EndTask:
3402 	// 返回结果
3403 	matchResult.dwID			= matchNode.dwID;				// 撮合的跨服国家连通信息ID，(游戏世界ID,国家ID,类型)组合编号
3404 	matchResult.dwWorldID		= matchNode.dwWorldID;			// 撮合的国家所在游戏世界ID
3405 	matchResult.dwCountryID		= matchNode.dwCountryID;		// 撮合的国家ID
3404 	matchResult.dwWorldID		= matchNode.dwWorldID;			// 撮合的国家所在游戏世界ID
3405 	matchResult.dwCountryID		= matchNode.dwCountryID;		// 撮合的国家ID
3406 	matchResult.dwType			= matchNode.dwType;				// 撮合的跨服国家边境类型
3407 	matchResult.bMatchOK		= bRetFlag;						// 匹配结果
3408 	matchResult.dwScore			= (DWORD)fTotalScore;			// 匹配得分
3469 		return;
3470 	}
3472 	double fPowerRateMin	= (double)g_pMatchService->GetWarConfigNumber(WarCfgNum_ClanBoss_PowerRateMin)/COUNTRY_RATE_FNUM;		// 跨服撮合最小实力比 * 1/1000 (0~1000,默认700)
3473 	double fRandPowRate		= (double)g_pMatchService->GetWarConfigNumber(WarCfgNum_ClanBoss_RandPowRate)/COUNTRY_RATE_FNUM;		// 实力比随机调节系数，为实力比的pow指数 * 1/1000 (1000~10000,默认3000)
3473 	double fRandPowRate		= (double)g_pMatchService->GetWarConfigNumber(WarCfgNum_ClanBoss_RandPowRate)/COUNTRY_RATE_FNUM;		// 实力比随机调节系数，为实力比的pow指数 * 1/1000 (1000~10000,默认3000)
3475 	DWORD dwCivilGradeLoRange = g_pMatchService->GetWarConfigNumber(WarCfgNum_CivilGradeLoRang);	// 跨服国战能跨文明等级下限 0
3476 	DWORD dwCivilGradeHiRange = g_pMatchService->GetWarConfigNumber(WarCfgNum_CivilGradeHiRang);	// 跨服国战能跨文明等级上限 1
3478 	// 领地Boss战撮合处理,状态为 CastleBossWarTaskState_New表示等待撮合，CastleBossWarTaskState_Ready 表示已撮合成功了
3479 	for (TMAP_CastleBossWarTaskInfoList::iterator iter = m_mapCastleBossWarMatchList.begin(); iter != m_mapCastleBossWarMatchList.end(); iter++)
3655 		return;
3656 	}
3657 	// 取地跨服国战系统接口
3658 	IWorldWar* pWorldWar = pCountryService->GetWorldWarPart();
3659 	if (pWorldWar==NULL)
3693 		switch(node.dwState)
3694 		{
3695 		case CountryWorldWarState_None:		// 无效跨服国战
3696 			{
3697 			}
3697 			}
3698 			break;
3699 		case CountryWorldWarState_New:		// 新跨服国战（未启动）
3700 			{
3701 				// 开始战前准备
3733 	}while(pWorldWar->MoveNext());
3735 }
3738 // 跨服边境主任务处理
3739 void CWarService::DoBorderWarTask()
3740 {
3761 	DWORD dwNowTimes = (DWORD)time(NULL);
3763 	//char szBuf[512]={0};
3765 	// 处理创建跨服边境战任务
3766 	DWORD dwStartTimes	= 0;			// 开启时间
3767 	DWORD dwFightTimes	= 0;			// 开打时间
3767 	DWORD dwFightTimes	= 0;			// 开打时间
3768 	DWORD dwEndTimes	= 0;			// 战斗结束时间
3770 	bool bCanAddBorderWar = false;	// 是否能加入跨服边境
3771 	// 开启后冷却1小时,和生成创建跨服边境战任务时间段(开启前10分钟时段)配合，使系统只能进入处理一次
3772 	if (dwNowTimes>m_dwLastAddWorldBorderWarTimes+3600)
3773 	{
3792 			// 今天开始时间
3793 			DWORD dwTodayTime		= (DWORD) t_of_day;
3794 			DWORD dwStartHourMin	= (DWORD)pSchemeInfo->nOpenTime;		// 开跨服边境时间
3795 			dwFightTimes	= dwTodayTime+3600*(dwStartHourMin/100)+60*(dwStartHourMin%100);	// 开打时间
3796 			dwStartTimes	= dwFightTimes-(DWORD)pWarSchemeInfo->nReadyTime;			// 开启时间
3799 			if (dwNowTimes+600>dwStartTimes && dwNowTimes<dwStartTimes)
3800 			{
3801 				bCanAddBorderWar = true;	// 是否能加入跨服边境
3802 			}
3803 		}
3803 		}
3804 	}
3806 	// 可创建跨服边境战任务
3807 	if (bCanAddBorderWar)
3808 	{
3807 	if (bCanAddBorderWar)
3808 	{
3809 		// 最近创建跨服边境连通时间，用来冷却,和生成创建跨服边境战任务时间段(开启前10分钟时段)配合，使系统只能进入处理一次
3810 		m_dwLastAddWorldBorderWarTimes = dwNowTimes;
3812 		// 取得桥服务器连接器
3816 		if (pCountryService!=NULL && pBridgeConnector != NULL)
3817 		{
3818 			// 取地跨服国战系统接口
3819 			IWorldWar* pWorldWar = pCountryService->GetWorldWarPart();
3820 			if (pWorldWar!=NULL)
3845 						continue;
3846 					}
3848 					// 确定要创建跨服边境信息
3849 					m_dwWorldBorderLinkMaxID++;	// 最大跨服边境连通序号
3851 					SCountryWorldWarInfo addNode;	// 创建跨服边境信息
3852 					addNode.dwID				= m_dwWorldBorderLinkMaxID;				// 跨服国战信息ID，0为无效ID
3853 					addNode.dwPublicWorldID		= getThisGameWorldID();					// 所属公共区世界ID
3854 					addNode.dwStartTime			= dwStartTimes;							// 开始时间
3854 					addNode.dwStartTime			= dwStartTimes;							// 开始时间
3855 					addNode.dwEndTime			= dwEndTimes;							// 结束时间
3856 					addNode.dwType				= pSchemeInfo->nWarID;					// 跨服国战类型 EMWarItemType
3857 					addNode.dwState				= CountryWorldWarState_New;				// 状态 EMCountryWorldWarState
3858 					addNode.dwResultFlag		= 0;									// 结果标识 EMWarRaceResultType
3911 		switch(node.dwState)
3912 		{
3913 		case CountryWorldWarState_New:		// 新跨服边境（未启动）
3914 			{
3915 				// 开始战前准备
3917 				{
3918 					node.dwState = CountryWorldWarState_Ready;
3919 					// 开始创建跨服边境
3920 					NewCountryWorldBorderWar(bIsPublic,node);
3921 					// 开起后就删除节点
3956 	time(&long_time);
3957 	localtime_s(&local_time,&long_time);
3958 	// 周二重连跨服边境数据
3959 	if (bCheckWeekDay && local_time.tm_wday!=3)
3960 	{
3977 		return;
3978 	}
3979 	// 取地跨服国战系统接口
3980 	IWorldWar* pWorldWar = pCountryService->GetWorldWarPart();
3981 	if (pWorldWar==NULL)
4054 							node.dwWorldID			= pSocialPart->GetWorldID();				// 国家所在游戏世界ID
4055 							node.dwCountryID		= pCountry->GetID();						// 国家ID
4056 							node.dwType				= dwWarTypeID;								// 跨服国家边境类型
4057 							node.dwID				= GetCountryWorldLinkKey(node.dwWorldID,node.dwCountryID,node.dwType);	// 跨服国家连通信息ID，(游戏世界ID,国家ID,类型)组合编号
4058 							node.dwStateFlag		= MatchWorldCountryLink_Wait;				// 撮合状态 EMMatchWorldCountryLinkState
4059 							// 国家基本信息
4067 							node.dwCivilGrade		= pCountry->GetCivilGrade();				// 世界文明等级
4068 							node.dwCivilDot			= pCountry->GetCivilDot();					// 世界文明点数
4069 							// 取得跨服国家边境连通信息
4070 							SCountryWorldLinkInfo * pLinkInfo =	pWorldWar->GetCountryWorldLinkInfo(node.dwWorldID,node.dwCountryID,node.dwType);
4071 							if (pLinkInfo!=NULL)
4080 							
4081 							SMatchWorldCountryLinkOrderNode addNode;
4082 							addNode.dwID			= node.dwID;			// 跨服国家连通信息ID，(游戏世界ID,国家ID,类型)组合编号
4083 							addNode.dwWorldAttack	= node.dwWorldAttack;	// 国家综合攻击力
4084 							listMathLinkSort.push_back(addNode);
4152 			node.dwLinkWorldID		= 0;					// 连通国家所在游戏世界ID
4153 			node.dwLinkCountryID	= 0;					// 连通国家ID
4155 			// 跨服边境连通信息变化,保存入数据库
4156 			pWorldWar->OnWorldLinkInfoChanged(node.dwID);
4158 		}while(pWorldWar->Link_MoveNext());
4162 		{
4163 			SMathcWorldCountryLinkNode &node = iter->second;
4164 			// 取得跨服国家边境连通信息
4165 			SCountryWorldLinkInfo * pLinkInfo =	pWorldWar->GetCountryWorldLinkInfo(node.dwWorldID,node.dwCountryID,node.dwType);
4166 			// 发现没有，就新加一个节点
4167 			if (pLinkInfo==NULL)
4168 			{
4169 				// 加入跨服边境连通信息
4170 				SCountryWorldLinkInfo * pAddLinkInfo = pWorldWar->AddCountryWorldLinkInfo(node.dwWorldID,node.dwCountryID,node.dwType);
4171 				if (pAddLinkInfo!=NULL)
4171 				if (pAddLinkInfo!=NULL)
4172 				{
4173 					// 跨服边境连通信息变化,保存入数据库
4174 					pWorldWar->OnWorldLinkInfoChanged(pAddLinkInfo->dwID);
4175 				}
4176 				else
4177 				{
4178 					sprintf_s(szBuf, sizeof(szBuf), "加入跨服边境连通信息失败！,游戏世界ID=%d,国家ID=%d,战场项目类型=%d",node.dwWorldID,node.dwCountryID,node.dwType);
4179 					ErrorLn(szBuf);
4180 				}
4293 		{
4294 			SMathcWorldCountryLinkNode &node = iter->second;
4295 			// 取得跨服国家边境连通信息
4296 			SCountryWorldLinkInfo * pLinkInfo =	pWorldWar->GetCountryWorldLinkInfoByID(node.dwID);
4297 			// 发现没有，就新加一个节点
4312 				pLinkInfo->dwLinkCountryID	= 0;								// 连通国家ID
4313 			}
4315 			// 跨服边境连通信息变化,保存入数据库
4316 			pWorldWar->OnWorldLinkInfoChanged(pLinkInfo->dwID);
4317 		}
4322 	pWorldWar->UpdateAllServerData();
4323 }
4326 // 检查跨服连接和跨服国战信息是否正确,有问题报警
4327 void CWarService::CheckWorldAlert()
4328 {
4348 		return;
4349 	}
4350 	// 取地跨服国战系统接口
4351 	IWorldWar* pWorldWar = pCountryService->GetWorldWarPart();
4352 	if (pWorldWar==NULL)
4357 	// 以实际物理连接为准,来检查所有数据的有效
4359 	//////////////////////////////////////////////////////////////////////////
4360 	// 检查跨服国战记录
4362 	// 遍历所有记录
4363 	pWorldWar->MoveHead();
4390 			if (NULL==pBridgePart)
4391 			{
4392 				sprintf_s(szBuf, sizeof(szBuf), "跨服国战记录中的游戏区(%d)不存在! 记录ID=%d,所属公共区ID=%d,开始时间=%s,类型=%d,进攻世界ID=%d,进攻国家ID=%d,防御世界ID=%d,防御国家ID=%d,状态=%d",
4393 					dwCheckWorldID,node.dwID,node.dwPublicWorldID,g_ExternalFacade.GetTimeString(node.dwStartTime),node.dwType,node.dwAttackWorldID,node.dwAttackCountryID,node.dwDefendWorldID,node.dwDefendCountryID,node.dwState);
4395 				// 报警对应区没开
4402 	
4403 	//////////////////////////////////////////////////////////////////////////
4404 	// 检查跨服连接记录
4405 	// 要连接的战场配置项定义
4406 	static DWORD dwMatchLinkTypeList[1] =
4470 					continue;
4471 				}
4473 				// 取得跨服国家边境连通信息
4474 				SCountryWorldLinkInfo * pLinkInfo =	pWorldWar->GetCountryWorldLinkInfo(dwCheckWorldID,j,dwWarTypeID);
4475 				if (pLinkInfo==NULL)
4475 				if (pLinkInfo==NULL)
4476 				{
4477 					sprintf_s(szBuf, sizeof(szBuf), "跨服国家边境连通记录中没找到此国家的连接记录,这将导致这个国家进不了跨服边境,边境类型=%d,世界ID=%d,国家ID=%d",dwWarTypeID,dwCheckWorldID,j);
4479 					// 报警对应区没开
4480 					AlertBad(MG_AlertSrcType_DataBase,szBuf);
4496 		return;
4497 	}
4498 	// 取地跨服国战系统接口
4499 	IWorldWar* pWorldWar = pCountryService->GetWorldWarPart();
4500 	if (NULL == pWorldWar)
4587 	}
4588 }
4591 /* 强制让本区的跨服国战记录失效，用于处理公共区异常导致本区缓存的数据还运行的问题，不让客户端显示活动追踪及DIDA
4592 @Param	: DWORD dwDBID		跨服国战数据库记录ID
4593 */
4594 bool CWarService::AbandLocalCountryWorldWarInfo(DWORD dwDBID, DWORD dwState, DWORD dwRunStep)
4604 		return false;
4605 	}
4606 	// 取地跨服国战系统接口
4607 	IWorldWar* pWorldWar = pCountryService->GetWorldWarPart();
4608 	if (NULL == pWorldWar)
4611 	}
4613 	//////////////////////////////////////////////////////////////////////////
4614 	// 取得跨服国战信息
4615 	SCountryWorldWarInfo * pCountryWorldWarInfo = pWorldWar->GetWorldWarInfo(dwDBID);
4616 	if (pCountryWorldWarInfo == NULL)
4618 		return false;
4619 	}
4621 	// 使跨服国战记录无效
4622 	pCountryWorldWarInfo->dwState = CountryWorldWarState_None;	// 无效跨服国战 状态 EMCountryWorldWarState
4624 	//////////////////////////////////////////////////////////////////////////
4625 	// 广播国战状态给本区所有场景服
4632 void CWarService::OnEventNewDay(void)
4633 {
4634 	// 更新跨服国战活动追踪信息,dwWarID=0为发全部战场追踪信息
4635 	OnUpdateWorldWarTracker();
4635 	OnUpdateWorldWarTracker();
4637 	// 检查跨服连接和跨服国战信息是否正确,有问题报警
4638 	CheckWorldAlert();
4639 }

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MatchServer\WarServer.cpp 67 KB CPP 文件 2014/2/25 0:09:08 2018/10/23 20:06:25 2018/10/23 20:06:25 52
234 	return &(iter->second);
235 }
237 /** 是否为指定跨服帮会BOSS战场中的参战帮会
238 @param   DWORD dwWorldID					: 游戏世界ID
239 @param   DWORD dwCountryID					: 国家ID
254 	return CheckJoinWorldClanBossWar(dwWorldID,dwCountryID,dwClanID,nodeData);
255 }
257 /** 取得指定跨服帮会BOSS战场中的参战帮会信息
258 @param   DWORD dwWorldID					: 游戏世界ID
259 @param   DWORD dwCountryID					: 国家ID
440 	return g_pMatchServer->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_RequestAddHistory,dwCountryID,0,0, obufData.data(), obufData.size());
441 }
443 // 检查国家在跨服国战中的参战类型
444 DWORD CWarServer::CheckCountryWorldWarType(DWORD dwWorldID,DWORD dwCountryID,SCountryWarZoneInfo &node)
445 {
468 	return 0;
469 }
471 // 检查帮会是否进参与跨服帮会BOSS战
472 bool CWarServer::CheckJoinWorldClanBossWar(DWORD dwWorldID,DWORD dwCountryID, DWORD dwClanID, SWorldClanBossWarZoneInfo &node)
473 {
485 	return bJoin;
486 }
488 /**  检查是否进参与跨服边境战
489 @param   DWORD dwWorldID					: 游戏世界ID
490 @param   DWORD dwCountryID					: 国家ID
505 	return false;
506 }
508 /**  跨服国战状态变化
509 @param void * pWar :争场ID
510 @param DWORD dwRunStep :状态
630 	return g_pMatchServer->SendDataToClient(pPerson,MSG_MATCH_DATE_WARMSG,Match_WarMsg_CountryWarAutoJoin,dwJoinRoomID);
631 }
634 // 发加入跨服帮会BOSS战数据到客户端 
635 bool CWarServer::SendJoinClanBossWarDataToClient(IPerson * pPerson,DWORD dwRoomID, bool bCheckStep)
636 {
719 	return g_pMatchServer->SendDataToClient(pPerson,MSG_MATCH_DATE_WARMSG,Match_WarMsg_ClanBossWarAutoJoin,dwJoinRoomID);
720 }
722 // 发加入跨服边境战数据到客户端 
723 bool CWarServer::SendJoinBorderWarDataToClient(IPerson * pPerson,DWORD dwRoomID, bool bCheckStep)
724 {
830 	// 调式代码
831 	char szBuf[512]={0};
832 	sprintf_s(szBuf,sizeof(szBuf), "CWarServer::HandleBridgeMessage()  跨服 服务器撮合信息子消息:来源游戏世界ID=%d,来源服务器ID=%d,子消息代码=%d,len=%d,用户数据=%d,%d,%d",
833 		bridgeHead.dwWorldID,bridgeHead.dwServerID,pMsg->dwMsgCode,len,pMsg->dwUserData1,pMsg->dwUserData2,pMsg->dwUserData3);
834 	TraceLn(szBuf);
949 		}
950 		break;
951 	case Match_WarMsg_RequestKingInfo:	// 请求获取跨服国王信息
952 		{
953 			if (nNewlen<sizeof(SWarCountryKingInfo))
953 			if (nNewlen<sizeof(SWarCountryKingInfo))
954 			{
955 				ErrorLn("收到获取跨服国王信息数据大小不符，nLen = "<<nNewlen);
956 				break;
957 			}
1205 		}
1206 		break;
1208 	case Match_WarMsg_BorderWarCreate:				// 跨服边境战场已创建
1209 		{
1210 			if (nNewlen!=sizeof(SCountryBorderWarZoneInfo))
1210 			if (nNewlen!=sizeof(SCountryBorderWarZoneInfo))
1211 			{
1212 				ErrorLn("收到跨服边境战场已创建信息数据大小不符，nLen = "<<nNewlen);
1213 				break;
1214 			}
1218 		}
1219 		break;
1220 	case Match_WarMsg_BorderWarEnd:				// 跨服边境战场已结束
1221 		{
1222 			if (nNewlen!=0)
1239 		}
1240 		break;
1241 	case Match_WarMsg_RemoveBorderWar:			// 移除跨服边境战场信息
1242 		{
1243 			if (nNewlen<sizeof(SMsgWarRemoveWar_SS))
1243 			if (nNewlen<sizeof(SMsgWarRemoveWar_SS))
1244 			{
1245 				ErrorLn("收到移除跨服边境战场信息数据大小不符，nLen = "<<nNewlen);
1246 				break;
1247 			}
1259 		}
1260 		break;
1261 	case Match_WarMsg_BorderWarStepChanged:		// 跨服边境执行状态子类型变化
1262 		{
1263 			if (nNewlen!=0)
1346 	default:
1347 		{
1348 			ErrorLn("跨区战争系统有一个跨服撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
1349 		}
1350 		break;
1401 		}
1402 		break;
1404 	case Match_WarMsg_RequestNewCountryWar:		// 请求开跨服国战
1405 		{
1406 			if (nNewlen!=sizeof(SCountryWorldWarInfo))
1406 			if (nNewlen!=sizeof(SCountryWorldWarInfo))
1407 			{
1408 				ErrorLn("收到社会服新建跨服国战信息数据大小不符，nLen = "<<nNewlen);
1409 				break;
1410 			}
1412 			if (pResAdjustServer == NULL)
1413 			{
1414 				ErrorLn("请求开跨服国战失败，pResAdjustServer == NULL");
1415 				break;
1416 			}
1419 			if (pBridgeConnector == NULL)
1420 			{
1421 				ErrorLn("请求开跨服国战失败，pBridgeConnector == NULL");
1422 				break;
1423 			}
1445 				dwCivilGrade = max(dwAttCivilGrade, dwDefCivilGrade);
1446 			}
1448 			/** 用现场创建跨服国战
1449 			@param  DWORD dwWarTypeID		: 战场场类型
1450 			@param  char * szCamp1Name		: 阵营1名称
1467 				if (pInfo!=NULL)
1468 				{
1469 					pCountryWar->m_dwTaskWorldWarID		= pNode->dwID;							// 跨服国战信息ID，0为无效ID
1470 					pCountryWar->m_dwTaskPublicWorldID	= pNode->dwPublicWorldID;				// 所属公共区世界ID
1472 					pInfo->dwAttWorldID					= pNode->dwAttackWorldID;				// 攻击方世界ID
1492 		}
1493 		break;
1495 	case Match_WarMsg_RequestNewBorderWar:		// 请求开跨服边境战场
1496 		{
1497 			if (nNewlen!=sizeof(SCountryWorldWarInfo))
1497 			if (nNewlen!=sizeof(SCountryWorldWarInfo))
1498 			{
1499 				ErrorLn("收到社会服新建跨服边境战场信息数据大小不符，nLen = "<<nNewlen);
1500 				break;
1501 			}
1503 			if (pResAdjustServer == NULL)
1504 			{
1505 				ErrorLn("请求开跨服边境战场失败，pResAdjustServer == NULL");
1506 				break;
1507 			}
1510 			if (pBridgeConnector == NULL)
1511 			{
1512 				ErrorLn("请求开跨服边境战场失败，pBridgeConnector == NULL");
1513 				break;
1514 			}
1550 				dwCivilGrade = max(dwAttCivilGrade, dwDefCivilGrade);
1551 			}
1553 			/** 用现场创建跨服国战
1554 			@param  DWORD dwWarTypeID		: 战场场类型
1555 			@param  char * szCamp1Name		: 阵营1名称
1622 		}
1623 		break;
1624 	case Match_WarMsg_WorldWarTracker:		// 跨服国战跟踪信息
1625 		{
1626 			if (nNewlen!=sizeof(SCountryWorldWarInfo))
1626 			if (nNewlen!=sizeof(SCountryWorldWarInfo))
1627 			{
1628 				ErrorLn("收到社会服跨服国战跟踪信息数据大小不符，nLen = "<<nNewlen);
1629 				break;
1630 			}
1630 			}
1631 			
1632 			// 国家在跨服国战中的参战类型 0.无,1.攻,2.守,3.攻盟友,4.守盟友
1633 			DWORD dwJoinType = pMsg->dwUserData1;
1634 			DWORD dwPlayerID = pMsg->dwUserData2;
1674 				break;
1675 			}
1677 			// 跨服国战开始时间
1678 			DWORD dwStartTime = pNode->dwStartTime+dwReadyTime - dwTodayTime;
1680 			// 攻方与守方名称
1681 			string strAttackName = pCountryAPI->GetCountryNameByID(pNode->dwAttackCountryID, pNode->dwAttackWorldID); //g_ExternalFacade.GetWorldCountryName(pNode->dwAttackWorldID, pNode->dwAttackCountryID, false);
1682 			string strDefendName = pCountryAPI->GetCountryNameByID(pNode->dwDefendCountryID, pNode->dwDefendWorldID); //g_ExternalFacade.GetWorldCountryName(pNode->dwDefendWorldID, pNode->dwDefendCountryID, false);
1684 			// 运行脚本以在客户端刷新跨服国战追踪信息
1685 			ILuaEngine * pLuaEngine = gZoneServiceProvider->GetLuaEngine();
1686 			if(pLuaEngine != NULL)
1688 				CLuaParam param[7];
1689 				param[0] = dwPlayerID;					// 玩家角色ID
1690 				param[1] = pNode->dwType;				// 跨服国战类型 EMWarItemType				
1691 				param[2] = dwJoinType;					// 国家在跨服国战中的参战类型 0.无,1.攻,2.守,3.攻盟友,4.守盟友
1692 				param[3] = pNode->dwState;				// 状态 EMCountryWorldWarState
1692 				param[3] = pNode->dwState;				// 状态 EMCountryWorldWarState
1693 				param[4] = dwStartTime;					// 跨服国战开始时间
1694 				param[5] = strAttackName.c_str();		// 攻方名称
1695 				param[6] = strDefendName.c_str();		// 攻方名称
1699 		}
1700 		break;
1701 	case Match_WarMsg_BossWarTracker:		// 跨服帮会领地BOSS战跟踪信息
1702 		{
1703 			if (nNewlen!=sizeof(SClanCastleBossWarNode))
1703 			if (nNewlen!=sizeof(SClanCastleBossWarNode))
1704 			{
1705 				ErrorLn("收到跨服帮会领地BOSS战跟踪信息数据大小不符，nLen = "<<nNewlen);
1706 				break;
1707 			}
1784 				}
1785 			}
1787 			// 运行脚本以在客户端刷新跨服国战追踪信息
1788 			ILuaEngine * pLuaEngine = gZoneServiceProvider->GetLuaEngine();
1789 			if(pLuaEngine != NULL)
1801 		}
1802 		break;
1803 	case Match_WarMsg_BorderWarTracker:				// 跨服边境战跟踪信息
1804 		{
1805 			if (nNewlen != sizeof(SCountryWorldLinkInfo) )
1805 			if (nNewlen != sizeof(SCountryWorldLinkInfo) )
1806 			{
1807 				ErrorLn("收到跨服边境战跟踪信息数据大小不符，nLen = "<<nNewlen);
1808 				break;
1809 			}
1844 				break;
1845 			}
1847 			// 跨服国家边境连通信息
1848 			SCountryWorldLinkInfo * pLinkInfo = (SCountryWorldLinkInfo *)pMsgData;
1850 			string strName="";
1899 			// XX:XX金鳌岛之战:沧海雷州
1900 			sprintf_s(szBuf, sizeof(szBuf), "<font face='songti-12-ol' color='#FFFF00'>%s</font>%s%s", szTimeBuf, g_pMatchServer->GetWarConfigName(WarConfigName_BorderWarName),strName.c_str());
1902 			// 运行脚本以在客户端刷新跨服国战追踪信息
1903 			ILuaEngine * pLuaEngine = gZoneServiceProvider->GetLuaEngine();
1904 			if(pLuaEngine != NULL)
1912 		}
1913 		break;
1915 	case Match_WarMsg_RequestNewClanBossWar:		// 请求开跨服领地Boss战
1916 		{
1917 			if (nNewlen!=sizeof(SCastleBossWarAddContext))
1917 			if (nNewlen!=sizeof(SCastleBossWarAddContext))
1918 			{
1919 				ErrorLn("收到社会服新建请求开跨服领地Boss战信息数据大小不符，nLen = "<<nNewlen);
1920 				break;
1921 			}
1942 				dwCivilGrade = pNode->dwCivilGrade;
1943 			}
1945 			/** 用现场创建跨服国战
1946 			@param  DWORD dwWarTypeID		: 战场场类型
1947 			@param  char * szCamp1Name		: 阵营1名称
1980 		}
1981 		break;
1982 	case Match_WarMsg_CountryWarStepChanged:		// 本区社会服发来强制让本区的跨服国战记录失效，用于处理公共区异常导致本区缓存的数据还运行的问题，不让客户端显示活动追踪及DIDA
1983 		{
1984 			// 源端点码非社会服不处理
1994 			}
1995 			
1996 			DWORD dwDBID	= pMsg->dwUserData1;			// 跨服国战数据库记录ID
1997 			BYTE nState		= (BYTE)pMsg->dwUserData2;		// 国战状态
1998 			BYTE nRunStep	= (BYTE)pMsg->dwUserData3;		// 国战状态子类型
2012 				}
2013 			}
2014 			ErrorLn("本区社会服发来强制让本区的跨服国战记录失效, dwDBID="<< dwDBID << ", nHandleFlag="<< nHandleFlag);
2015 		}
2016 		break;
2256 				}				
2257 			}
2259 			// 发送加入跨服BOSS战数据到客户端
2260 			if (m_mapCastleBossWarInfoList.empty()==false)
2261 			{
2266 				}
2267 			}			
2269 			// 发加入跨服边境战数据到客户端 
2270 			if (m_mapBorderWarZoneInfoList.empty()==false)
2271 			{

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MatchServer\WarServer.cpp 67 KB CPP 文件 2014/2/25 14:27:18 2018/10/23 19:45:15 2018/10/23 19:45:15 52
234 	return &(iter->second);
235 }
237 /** 是否为指定跨服帮会BOSS战场中的参战帮会
238 @param   DWORD dwWorldID					: 游戏世界ID
239 @param   DWORD dwCountryID					: 国家ID
254 	return CheckJoinWorldClanBossWar(dwWorldID,dwCountryID,dwClanID,nodeData);
255 }
257 /** 取得指定跨服帮会BOSS战场中的参战帮会信息
258 @param   DWORD dwWorldID					: 游戏世界ID
259 @param   DWORD dwCountryID					: 国家ID
440 	return g_pMatchServer->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_RequestAddHistory,dwCountryID,0,0, obufData.data(), obufData.size());
441 }
443 // 检查国家在跨服国战中的参战类型
444 DWORD CWarServer::CheckCountryWorldWarType(DWORD dwWorldID,DWORD dwCountryID,SCountryWarZoneInfo &node)
445 {
468 	return 0;
469 }
471 // 检查帮会是否进参与跨服帮会BOSS战
472 bool CWarServer::CheckJoinWorldClanBossWar(DWORD dwWorldID,DWORD dwCountryID, DWORD dwClanID, SWorldClanBossWarZoneInfo &node)
473 {
485 	return bJoin;
486 }
488 /**  检查是否进参与跨服边境战
489 @param   DWORD dwWorldID					: 游戏世界ID
490 @param   DWORD dwCountryID					: 国家ID
505 	return false;
506 }
508 /**  跨服国战状态变化
509 @param void * pWar :争场ID
510 @param DWORD dwRunStep :状态
630 	return g_pMatchServer->SendDataToClient(pPerson,MSG_MATCH_DATE_WARMSG,Match_WarMsg_CountryWarAutoJoin,dwJoinRoomID);
631 }
634 // 发加入跨服帮会BOSS战数据到客户端 
635 bool CWarServer::SendJoinClanBossWarDataToClient(IPerson * pPerson,DWORD dwRoomID, bool bCheckStep)
636 {
719 	return g_pMatchServer->SendDataToClient(pPerson,MSG_MATCH_DATE_WARMSG,Match_WarMsg_ClanBossWarAutoJoin,dwJoinRoomID);
720 }
722 // 发加入跨服边境战数据到客户端 
723 bool CWarServer::SendJoinBorderWarDataToClient(IPerson * pPerson,DWORD dwRoomID, bool bCheckStep)
724 {
830 	// 调式代码
831 	char szBuf[512]={0};
832 	sprintf_s(szBuf,sizeof(szBuf), "CWarServer::HandleBridgeMessage()  跨服 服务器撮合信息子消息:来源游戏世界ID=%d,来源服务器ID=%d,子消息代码=%d,len=%d,用户数据=%d,%d,%d",
833 		bridgeHead.dwWorldID,bridgeHead.dwServerID,pMsg->dwMsgCode,len,pMsg->dwUserData1,pMsg->dwUserData2,pMsg->dwUserData3);
834 	TraceLn(szBuf);
949 		}
950 		break;
951 	case Match_WarMsg_RequestKingInfo:	// 请求获取跨服国王信息
952 		{
953 			if (nNewlen<sizeof(SWarCountryKingInfo))
953 			if (nNewlen<sizeof(SWarCountryKingInfo))
954 			{
955 				ErrorLn("收到获取跨服国王信息数据大小不符，nLen = "<<nNewlen);
956 				break;
957 			}
1205 		}
1206 		break;
1208 	case Match_WarMsg_BorderWarCreate:				// 跨服边境战场已创建
1209 		{
1210 			if (nNewlen!=sizeof(SCountryBorderWarZoneInfo))
1210 			if (nNewlen!=sizeof(SCountryBorderWarZoneInfo))
1211 			{
1212 				ErrorLn("收到跨服边境战场已创建信息数据大小不符，nLen = "<<nNewlen);
1213 				break;
1214 			}
1218 		}
1219 		break;
1220 	case Match_WarMsg_BorderWarEnd:				// 跨服边境战场已结束
1221 		{
1222 			if (nNewlen!=0)
1239 		}
1240 		break;
1241 	case Match_WarMsg_RemoveBorderWar:			// 移除跨服边境战场信息
1242 		{
1243 			if (nNewlen<sizeof(SMsgWarRemoveWar_SS))
1243 			if (nNewlen<sizeof(SMsgWarRemoveWar_SS))
1244 			{
1245 				ErrorLn("收到移除跨服边境战场信息数据大小不符，nLen = "<<nNewlen);
1246 				break;
1247 			}
1259 		}
1260 		break;
1261 	case Match_WarMsg_BorderWarStepChanged:		// 跨服边境执行状态子类型变化
1262 		{
1263 			if (nNewlen!=0)
1346 	default:
1347 		{
1348 			ErrorLn("跨区战争系统有一个跨服撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
1349 		}
1350 		break;
1401 		}
1402 		break;
1404 	case Match_WarMsg_RequestNewCountryWar:		// 请求开跨服国战
1405 		{
1406 			if (nNewlen!=sizeof(SCountryWorldWarInfo))
1406 			if (nNewlen!=sizeof(SCountryWorldWarInfo))
1407 			{
1408 				ErrorLn("收到社会服新建跨服国战信息数据大小不符，nLen = "<<nNewlen);
1409 				break;
1410 			}
1412 			if (pResAdjustServer == NULL)
1413 			{
1414 				ErrorLn("请求开跨服国战失败，pResAdjustServer == NULL");
1415 				break;
1416 			}
1419 			if (pBridgeConnector == NULL)
1420 			{
1421 				ErrorLn("请求开跨服国战失败，pBridgeConnector == NULL");
1422 				break;
1423 			}
1445 				dwCivilGrade = max(dwAttCivilGrade, dwDefCivilGrade);
1446 			}
1448 			/** 用现场创建跨服国战
1449 			@param  DWORD dwWarTypeID		: 战场场类型
1450 			@param  char * szCamp1Name		: 阵营1名称
1467 				if (pInfo!=NULL)
1468 				{
1469 					pCountryWar->m_dwTaskWorldWarID		= pNode->dwID;							// 跨服国战信息ID，0为无效ID
1470 					pCountryWar->m_dwTaskPublicWorldID	= pNode->dwPublicWorldID;				// 所属公共区世界ID
1472 					pInfo->dwAttWorldID					= pNode->dwAttackWorldID;				// 攻击方世界ID
1492 		}
1493 		break;
1495 	case Match_WarMsg_RequestNewBorderWar:		// 请求开跨服边境战场
1496 		{
1497 			if (nNewlen!=sizeof(SCountryWorldWarInfo))
1497 			if (nNewlen!=sizeof(SCountryWorldWarInfo))
1498 			{
1499 				ErrorLn("收到社会服新建跨服边境战场信息数据大小不符，nLen = "<<nNewlen);
1500 				break;
1501 			}
1503 			if (pResAdjustServer == NULL)
1504 			{
1505 				ErrorLn("请求开跨服边境战场失败，pResAdjustServer == NULL");
1506 				break;
1507 			}
1510 			if (pBridgeConnector == NULL)
1511 			{
1512 				ErrorLn("请求开跨服边境战场失败，pBridgeConnector == NULL");
1513 				break;
1514 			}
1550 				dwCivilGrade = max(dwAttCivilGrade, dwDefCivilGrade);
1551 			}
1553 			/** 用现场创建跨服国战
1554 			@param  DWORD dwWarTypeID		: 战场场类型
1555 			@param  char * szCamp1Name		: 阵营1名称
1622 		}
1623 		break;
1624 	case Match_WarMsg_WorldWarTracker:		// 跨服国战跟踪信息
1625 		{
1626 			if (nNewlen!=sizeof(SCountryWorldWarInfo))
1626 			if (nNewlen!=sizeof(SCountryWorldWarInfo))
1627 			{
1628 				ErrorLn("收到社会服跨服国战跟踪信息数据大小不符，nLen = "<<nNewlen);
1629 				break;
1630 			}
1630 			}
1631 			
1632 			// 国家在跨服国战中的参战类型 0.无,1.攻,2.守,3.攻盟友,4.守盟友
1633 			DWORD dwJoinType = pMsg->dwUserData1;
1634 			DWORD dwPlayerID = pMsg->dwUserData2;
1674 				break;
1675 			}
1677 			// 跨服国战开始时间
1678 			DWORD dwStartTime = pNode->dwStartTime+dwReadyTime - dwTodayTime;
1680 			// 攻方与守方名称
1681 			string strAttackName = pCountryAPI->GetCountryNameByID(pNode->dwAttackCountryID, pNode->dwAttackWorldID); //g_ExternalFacade.GetWorldCountryName(pNode->dwAttackWorldID, pNode->dwAttackCountryID, false);
1682 			string strDefendName = pCountryAPI->GetCountryNameByID(pNode->dwDefendCountryID, pNode->dwDefendWorldID); //g_ExternalFacade.GetWorldCountryName(pNode->dwDefendWorldID, pNode->dwDefendCountryID, false);
1684 			// 运行脚本以在客户端刷新跨服国战追踪信息
1685 			ILuaEngine * pLuaEngine = gZoneServiceProvider->GetLuaEngine();
1686 			if(pLuaEngine != NULL)
1688 				CLuaParam param[7];
1689 				param[0] = dwPlayerID;					// 玩家角色ID
1690 				param[1] = pNode->dwType;				// 跨服国战类型 EMWarItemType				
1691 				param[2] = dwJoinType;					// 国家在跨服国战中的参战类型 0.无,1.攻,2.守,3.攻盟友,4.守盟友
1692 				param[3] = pNode->dwState;				// 状态 EMCountryWorldWarState
1692 				param[3] = pNode->dwState;				// 状态 EMCountryWorldWarState
1693 				param[4] = dwStartTime;					// 跨服国战开始时间
1694 				param[5] = strAttackName.c_str();		// 攻方名称
1695 				param[6] = strDefendName.c_str();		// 攻方名称
1699 		}
1700 		break;
1701 	case Match_WarMsg_BossWarTracker:		// 跨服帮会领地BOSS战跟踪信息
1702 		{
1703 			if (nNewlen!=sizeof(SClanCastleBossWarNode))
1703 			if (nNewlen!=sizeof(SClanCastleBossWarNode))
1704 			{
1705 				ErrorLn("收到跨服帮会领地BOSS战跟踪信息数据大小不符，nLen = "<<nNewlen);
1706 				break;
1707 			}
1784 				}
1785 			}
1787 			// 运行脚本以在客户端刷新跨服国战追踪信息
1788 			ILuaEngine * pLuaEngine = gZoneServiceProvider->GetLuaEngine();
1789 			if(pLuaEngine != NULL)
1801 		}
1802 		break;
1803 	case Match_WarMsg_BorderWarTracker:				// 跨服边境战跟踪信息
1804 		{
1805 			if (nNewlen != sizeof(SCountryWorldLinkInfo) )
1805 			if (nNewlen != sizeof(SCountryWorldLinkInfo) )
1806 			{
1807 				ErrorLn("收到跨服边境战跟踪信息数据大小不符，nLen = "<<nNewlen);
1808 				break;
1809 			}
1844 				break;
1845 			}
1847 			// 跨服国家边境连通信息
1848 			SCountryWorldLinkInfo * pLinkInfo = (SCountryWorldLinkInfo *)pMsgData;
1850 			string strName="";
1899 			// XX:XX金鳌岛之战:沧海雷州
1900 			sprintf_s(szBuf, sizeof(szBuf), "<font face='songti-12-ol' color='#FFFF00'>%s</font>%s%s", szTimeBuf, g_pMatchServer->GetWarConfigName(WarConfigName_BorderWarName),strName.c_str());
1902 			// 运行脚本以在客户端刷新跨服国战追踪信息
1903 			ILuaEngine * pLuaEngine = gZoneServiceProvider->GetLuaEngine();
1904 			if(pLuaEngine != NULL)
1912 		}
1913 		break;
1915 	case Match_WarMsg_RequestNewClanBossWar:		// 请求开跨服领地Boss战
1916 		{
1917 			if (nNewlen!=sizeof(SCastleBossWarAddContext))
1917 			if (nNewlen!=sizeof(SCastleBossWarAddContext))
1918 			{
1919 				ErrorLn("收到社会服新建请求开跨服领地Boss战信息数据大小不符，nLen = "<<nNewlen);
1920 				break;
1921 			}
1942 				dwCivilGrade = pNode->dwCivilGrade;
1943 			}
1945 			/** 用现场创建跨服国战
1946 			@param  DWORD dwWarTypeID		: 战场场类型
1947 			@param  char * szCamp1Name		: 阵营1名称
1980 		}
1981 		break;
1982 	case Match_WarMsg_CountryWarStepChanged:		// 本区社会服发来强制让本区的跨服国战记录失效，用于处理公共区异常导致本区缓存的数据还运行的问题，不让客户端显示活动追踪及DIDA
1983 		{
1984 			// 源端点码非社会服不处理
1994 			}
1995 			
1996 			DWORD dwDBID	= pMsg->dwUserData1;			// 跨服国战数据库记录ID
1997 			BYTE nState		= (BYTE)pMsg->dwUserData2;		// 国战状态
1998 			BYTE nRunStep	= (BYTE)pMsg->dwUserData3;		// 国战状态子类型
2012 				}
2013 			}
2014 			ErrorLn("本区社会服发来强制让本区的跨服国战记录失效, dwDBID="<< dwDBID << ", nHandleFlag="<< nHandleFlag);
2015 		}
2016 		break;
2256 				}				
2257 			}
2259 			// 发送加入跨服BOSS战数据到客户端
2260 			if (m_mapCastleBossWarInfoList.empty()==false)
2261 			{
2266 				}
2267 			}			
2269 			// 发加入跨服边境战数据到客户端 
2270 			if (m_mapBorderWarZoneInfoList.empty()==false)
2271 			{

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MatchServer\WarResSeal.cpp 7 KB CPP 文件 2014/2/25 0:09:07 2018/10/23 20:06:25 2018/10/23 20:06:25 2
116 	// 战争资源生成
117 	SEventMatchWarResSeal_Occupy eventData;
118 	eventData.dwPVPClassType	= dwPVPType;		// 跨服PVP类型 EMPVPClassType
119 	eventData.dwWarID			= dwWarID;			// 相关战场ID
120 	eventData.dwResID			= GetResID();		// 相关战争资源配置
215 	// 战争资源生成
216 	SEventMatchWarRes_State_Change_S eventData;
217 	eventData.dwPVPClassType	= dwPVPType;					// 跨服PVP类型 EMPVPClassType
218 	eventData.dwWarID			= dwWarID;						// 相关战场ID
219 	eventData.dwResID			= GetResID();					// 相关战争资源配置

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MatchServer\WarResSeal.cpp 7 KB CPP 文件 2014/2/25 14:27:18 2018/10/23 19:45:14 2018/10/23 19:45:14 2
116 	// 战争资源生成
117 	SEventMatchWarResSeal_Occupy eventData;
118 	eventData.dwPVPClassType	= dwPVPType;		// 跨服PVP类型 EMPVPClassType
119 	eventData.dwWarID			= dwWarID;			// 相关战场ID
120 	eventData.dwResID			= GetResID();		// 相关战争资源配置
215 	// 战争资源生成
216 	SEventMatchWarRes_State_Change_S eventData;
217 	eventData.dwPVPClassType	= dwPVPType;					// 跨服PVP类型 EMPVPClassType
218 	eventData.dwWarID			= dwWarID;						// 相关战场ID
219 	eventData.dwResID			= GetResID();					// 相关战争资源配置

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MatchServer\WarResGate.cpp 5 KB CPP 文件 2014/2/25 0:09:06 2018/10/23 20:06:25 2018/10/23 20:06:25 1
98 		// 城门开关
99 		SEventMatchWarResGateOpen_S eventData;
100 		eventData.dwPVPClassType	= dwPVPType;		// 跨服PVP类型 EMPVPClassType
101 		eventData.dwWarID			= dwWarID;			// 相关战场ID
102 		eventData.dwResID			= GetResID();		// 相关战争资源配置

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MatchServer\WarResGate.cpp 5 KB CPP 文件 2014/2/25 14:27:17 2018/10/23 19:45:14 2018/10/23 19:45:14 1
98 		// 城门开关
99 		SEventMatchWarResGateOpen_S eventData;
100 		eventData.dwPVPClassType	= dwPVPType;		// 跨服PVP类型 EMPVPClassType
101 		eventData.dwWarID			= dwWarID;			// 相关战场ID
102 		eventData.dwResID			= GetResID();		// 相关战争资源配置

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MatchServer\WarResBase.cpp 20 KB CPP 文件 2014/2/25 0:09:05 2018/10/23 20:06:24 2018/10/23 20:06:24 4
298 	// 战争资源生成
299 	SEventMatchWarResBuild_S eventData;
300 	eventData.dwPVPClassType	= dwPVPType;		// 跨服PVP类型 EMPVPClassType
301 	eventData.dwWarID			= dwWarID;			// 相关战场ID
302 	eventData.dwResID			= GetResID();		// 相关战争资源配置
360 			// 战争资源生成
361 			SEventMatchWarResDie_S eventData;
362 			eventData.dwPVPClassType	= dwPVPType;		// 跨服PVP类型 EMPVPClassType
363 			eventData.dwWarID			= dwWarID;			// 相关战场ID
364 			eventData.dwResID			= GetResID();		// 相关战争资源配置
613 				// 战争资源生成
614 				SEventMatchWarResDie_S eventData;
615 				eventData.dwPVPClassType	= dwPVPType;		// 跨服PVP类型 EMPVPClassType
616 				eventData.dwWarID			= dwWarID;			// 相关战场ID
617 				eventData.dwResID			= GetResID();		// 相关战争资源配置
752 				// 询问上层应用 是否可以为此玩家添加 产生的数值
753 				SEventMatchWarResCanAddValue_S eventData;
754 				eventData.dwPVPClassType	= m_pResManage->GetPVPBase()->GetPVPClass()->GetClass();	// 跨服PVP类型 EMPVPClassType
755 				eventData.dwWarID			= m_pResManage->GetPVPBase()->GetID();						// 相关战场ID
756 				eventData.dwResID			= GetResID();												// 相关战争资源配置

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MatchServer\WarResBase.cpp 20 KB CPP 文件 2014/2/25 14:27:17 2018/10/23 19:45:14 2018/10/23 19:45:14 4
298 	// 战争资源生成
299 	SEventMatchWarResBuild_S eventData;
300 	eventData.dwPVPClassType	= dwPVPType;		// 跨服PVP类型 EMPVPClassType
301 	eventData.dwWarID			= dwWarID;			// 相关战场ID
302 	eventData.dwResID			= GetResID();		// 相关战争资源配置
360 			// 战争资源生成
361 			SEventMatchWarResDie_S eventData;
362 			eventData.dwPVPClassType	= dwPVPType;		// 跨服PVP类型 EMPVPClassType
363 			eventData.dwWarID			= dwWarID;			// 相关战场ID
364 			eventData.dwResID			= GetResID();		// 相关战争资源配置
613 				// 战争资源生成
614 				SEventMatchWarResDie_S eventData;
615 				eventData.dwPVPClassType	= dwPVPType;		// 跨服PVP类型 EMPVPClassType
616 				eventData.dwWarID			= dwWarID;			// 相关战场ID
617 				eventData.dwResID			= GetResID();		// 相关战争资源配置
752 				// 询问上层应用 是否可以为此玩家添加 产生的数值
753 				SEventMatchWarResCanAddValue_S eventData;
754 				eventData.dwPVPClassType	= m_pResManage->GetPVPBase()->GetPVPClass()->GetClass();	// 跨服PVP类型 EMPVPClassType
755 				eventData.dwWarID			= m_pResManage->GetPVPBase()->GetID();						// 相关战场ID
756 				eventData.dwResID			= GetResID();												// 相关战争资源配置

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MatchServer\WarManager.cpp 8 KB CPP 文件 2014/2/25 0:09:04 2018/10/23 20:06:24 2018/10/23 20:06:24 6
209 	if (context.dwWarMode == WarMode_Country)
210 	{
211 		pWar = new CCountryWar();	// 跨服国战
212 	}
213 	else if (context.dwWarMode == WarMode_ClanBoss)
213 	else if (context.dwWarMode == WarMode_ClanBoss)
214 	{
215 		pWar = new CClanBossWar();	// 跨服帮会战
216 	}
217 	else if (context.dwWarMode == WarMode_CountryBorder)
240 	{
241 		_T("未知"),
242 		_T("跨服国战"),
243 		_T("跨服帮会战"),
244 		_T("跨服边境战"),
245 		_T("跨服家族战"),
246 	};
248 	string strWarModeName="未知";

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MatchServer\WarManager.cpp 8 KB CPP 文件 2014/2/25 14:27:16 2018/10/23 19:45:14 2018/10/23 19:45:14 6
209 	if (context.dwWarMode == WarMode_Country)
210 	{
211 		pWar = new CCountryWar();	// 跨服国战
212 	}
213 	else if (context.dwWarMode == WarMode_ClanBoss)
213 	else if (context.dwWarMode == WarMode_ClanBoss)
214 	{
215 		pWar = new CClanBossWar();	// 跨服帮会战
216 	}
217 	else if (context.dwWarMode == WarMode_CountryBorder)
240 	{
241 		_T("未知"),
242 		_T("跨服国战"),
243 		_T("跨服帮会战"),
244 		_T("跨服边境战"),
245 		_T("跨服家族战"),
246 	};
248 	string strWarModeName="未知";

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcClient\Client\MatchClient\WarClient.cpp 8 KB CPP 文件 2014/2/25 8:34:48 2018/10/23 19:52:18 2018/10/23 19:52:18 9
39 	// 国战战场系统
40 	m_CountryWar.Create();
41 	// 跨服帮会BOSS战场系统
42 	m_ClanBossWar.Create();
42 	m_ClanBossWar.Create();
43 	// 跨服边境战场系统
44 	m_BorderWar.Create();
46 	return true;
52 	// 国战战场系统
53 	m_CountryWar.Release();
54 	// 跨服帮会BOSS战场系统
55 	m_ClanBossWar.Release();
55 	m_ClanBossWar.Release();
56 	// 跨服边境战场系统
57 	m_BorderWar.Release();
58 }
65 	return &m_CountryWar;
66 }
69 /** 取得跨服帮会BOSS战场系统
70 @return  CClanBossWar * 
71 */
83 	return &m_BorderWar;
84 }
87 /** 玩家请求发起跨服国战
88 @param DWORD dwWorldID : 对方游戏世界ID
89 @param DWORD dwCountryID : 对方国家ID
93 bool CWarClient::RequestAddWorldCountryWar(DWORD dwWorldID,DWORD dwCountryID,DWORD dwFlag)
94 {
95 	// 玩家请求发起跨服国战
96 	return g_pMatchClient->SendDataToSocial(MSG_MATCH_DATE_WARMSG,Match_WarMsg_RequestAddCountryWar,dwWorldID,dwCountryID,dwFlag);
97 }
193 		return;
194 	}
195 	// 跨服帮会Boss战专用消息应用 将依据消息码区间区分不同的玩法消息
196 	else if (pMsg->dwMsgCode > Match_WarMsg_CLANBOSSMODE_MSGBEGIN && pMsg->dwMsgCode<Match_WarMsg_CLANBOSSMODE_MSGEND)
197 	{
199 		return;
200 	}
201 	// 跨服边境战专用消息应用 将依据消息码区间区分不同的玩法消息
202 	else if (pMsg->dwMsgCode > Match_WarMsg_COUNTRYBORDERMODE_MSGBEGIN && pMsg->dwMsgCode<Match_WarMsg_COUNTRYBORDERMODE_MSGEND)
203 	{

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcClient\Client\MatchClient\WarClient.cpp 8 KB CPP 文件 2014/2/25 13:44:54 2018/10/23 19:34:25 2018/10/23 19:34:25 9
39 	// 国战战场系统
40 	m_CountryWar.Create();
41 	// 跨服帮会BOSS战场系统
42 	m_ClanBossWar.Create();
42 	m_ClanBossWar.Create();
43 	// 跨服边境战场系统
44 	m_BorderWar.Create();
46 	return true;
52 	// 国战战场系统
53 	m_CountryWar.Release();
54 	// 跨服帮会BOSS战场系统
55 	m_ClanBossWar.Release();
55 	m_ClanBossWar.Release();
56 	// 跨服边境战场系统
57 	m_BorderWar.Release();
58 }
65 	return &m_CountryWar;
66 }
69 /** 取得跨服帮会BOSS战场系统
70 @return  CClanBossWar * 
71 */
83 	return &m_BorderWar;
84 }
87 /** 玩家请求发起跨服国战
88 @param DWORD dwWorldID : 对方游戏世界ID
89 @param DWORD dwCountryID : 对方国家ID
93 bool CWarClient::RequestAddWorldCountryWar(DWORD dwWorldID,DWORD dwCountryID,DWORD dwFlag)
94 {
95 	// 玩家请求发起跨服国战
96 	return g_pMatchClient->SendDataToSocial(MSG_MATCH_DATE_WARMSG,Match_WarMsg_RequestAddCountryWar,dwWorldID,dwCountryID,dwFlag);
97 }
193 		return;
194 	}
195 	// 跨服帮会Boss战专用消息应用 将依据消息码区间区分不同的玩法消息
196 	else if (pMsg->dwMsgCode > Match_WarMsg_CLANBOSSMODE_MSGBEGIN && pMsg->dwMsgCode<Match_WarMsg_CLANBOSSMODE_MSGEND)
197 	{
199 		return;
200 	}
201 	// 跨服边境战专用消息应用 将依据消息码区间区分不同的玩法消息
202 	else if (pMsg->dwMsgCode > Match_WarMsg_COUNTRYBORDERMODE_MSGBEGIN && pMsg->dwMsgCode<Match_WarMsg_COUNTRYBORDERMODE_MSGEND)
203 	{

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MatchServer\War.cpp 98 KB CPP 文件 2014/2/25 0:09:04 2018/10/23 20:06:24 2018/10/23 20:06:24 2
1911 /** 资源事件执行接口
1912 @param   WORD wEventID		:事件ID
1913 @param   WORD dwPVPClassType:跨服PVP类型 EMPVPClassType
1914 @param   WORD dwWarID		:相关战场ID
1915 @param   WORD dwResID		:相关战争资源配置ID
1926 /** 资源投票事件
1927 @param   WORD wEventID		:事件ID
1928 @param   WORD dwPVPClassType:跨服PVP类型 EMPVPClassType
1929 @param   WORD dwWarID		:相关战场ID
1930 @param   WORD dwResID		:相关战争资源配置ID

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MatchServer\War.cpp 98 KB CPP 文件 2014/2/25 14:27:16 2018/10/23 19:45:13 2018/10/23 19:45:13 2
1911 /** 资源事件执行接口
1912 @param   WORD wEventID		:事件ID
1913 @param   WORD dwPVPClassType:跨服PVP类型 EMPVPClassType
1914 @param   WORD dwWarID		:相关战场ID
1915 @param   WORD dwResID		:相关战争资源配置ID
1926 /** 资源投票事件
1927 @param   WORD wEventID		:事件ID
1928 @param   WORD dwPVPClassType:跨服PVP类型 EMPVPClassType
1929 @param   WORD dwWarID		:相关战场ID
1930 @param   WORD dwResID		:相关战争资源配置ID

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\SocialServer\VoiceService.cpp 86 KB CPP 文件 2014/2/25 0:24:18 2018/10/23 20:09:13 2018/10/23 20:09:13 2
2103 	switch(pMsg->dwMsgCode)
2104 	{
2105 	case VoiceSubMsg_VoiceCheck:		// 检测消息，用来跨服检测网络连接状态
2106 		{
2107 			if( nNewlen < sizeof(SVoiceSubMsgCheck) )
2139 		}
2140 		break;
2142 	case VoiceSubMsg_VoiceCheckBack:		// 检测消息回复，用来跨服检测网络连接状态
2143 		{
2144 			// 有需要的时候扩展

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\SocialServer\VoiceService.cpp 86 KB CPP 文件 2014/2/25 14:32:09 2018/10/23 19:46:51 2018/10/23 19:46:51 2
2103 	switch(pMsg->dwMsgCode)
2104 	{
2105 	case VoiceSubMsg_VoiceCheck:		// 检测消息，用来跨服检测网络连接状态
2106 		{
2107 			if( nNewlen < sizeof(SVoiceSubMsgCheck) )
2139 		}
2140 		break;
2142 	case VoiceSubMsg_VoiceCheckBack:		// 检测消息回复，用来跨服检测网络连接状态
2143 		{
2144 			// 有需要的时候扩展

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\ServerModule\VoiceServer.cpp 58 KB CPP 文件 2014/2/25 0:10:27 2018/10/23 20:06:42 2018/10/23 20:06:42 5
389 	return false;
390 }
392 // 发送跨服网络检测，跨服网络检测完毕会回调，再执行dwActionId
393 void CVoiceServer::SendCheck( DWORD dwEndPoint, DWORD dwSrcWorldID, DWORD dwDestWorldID, DWORD dwActionId, DWORD dwPDBIDSend, DWORD dwPDBID, 
394 							 DWORD dwData1, DWORD dwData2, DWORD dwData3, void * data, size_t len )
663 	{
664 #ifdef VOICE_PRINT_DEBUG_INF
665 		TraceLn("CVoiceServer::SendGift 跨服赠送礼物");
666 #endif
667 		SendAcceptGiftData( pSender, dwPDBID, szMessage, dwGiftID, dwDestWorldID, 0  , dwFlag , dwData1 , dwData2 , dwData3);
1485 	switch(pMsg->dwMsgCode)
1486 	{
1487 	case VoiceSubMsg_VoiceCheck:		// 检测消息，用来跨服检测网络连接状态
1488 		{
1489 			if( nNewlen < sizeof(SVoiceSubMsgCheck) )
1783 	{
1784 #ifdef VOICE_PRINT_DEBUG_INF
1785 		TraceLn( "CVoiceServer::SendAcceptGiftData 跨服发送" );
1786 #endif
1787 		SendVoiceDataBridgeToServer( MSG_ENDPOINT_ZONE, dwDestWorldID, dwAcceptor, MSG_VOICE_DATA_SUBMSG, VoiceSubMsg_AcceptGift, 0, 0, 0, obufData.data(), obufData.size() );

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\ServerModule\VoiceServer.cpp 58 KB CPP 文件 2014/2/25 14:28:12 2018/10/23 19:45:34 2018/10/23 19:45:34 5
389 	return false;
390 }
392 // 发送跨服网络检测，跨服网络检测完毕会回调，再执行dwActionId
393 void CVoiceServer::SendCheck( DWORD dwEndPoint, DWORD dwSrcWorldID, DWORD dwDestWorldID, DWORD dwActionId, DWORD dwPDBIDSend, DWORD dwPDBID, 
394 							 DWORD dwData1, DWORD dwData2, DWORD dwData3, void * data, size_t len )
663 	{
664 #ifdef VOICE_PRINT_DEBUG_INF
665 		TraceLn("CVoiceServer::SendGift 跨服赠送礼物");
666 #endif
667 		SendAcceptGiftData( pSender, dwPDBID, szMessage, dwGiftID, dwDestWorldID, 0  , dwFlag , dwData1 , dwData2 , dwData3);
1485 	switch(pMsg->dwMsgCode)
1486 	{
1487 	case VoiceSubMsg_VoiceCheck:		// 检测消息，用来跨服检测网络连接状态
1488 		{
1489 			if( nNewlen < sizeof(SVoiceSubMsgCheck) )
1783 	{
1784 #ifdef VOICE_PRINT_DEBUG_INF
1785 		TraceLn( "CVoiceServer::SendAcceptGiftData 跨服发送" );
1786 #endif
1787 		SendVoiceDataBridgeToServer( MSG_ENDPOINT_ZONE, dwDestWorldID, dwAcceptor, MSG_VOICE_DATA_SUBMSG, VoiceSubMsg_AcceptGift, 0, 0, 0, obufData.data(), obufData.size() );

I:\work\source\神仙传\[src.cool]神仙传\GAME\Project1\ZoneClientEditor\Source\NetWork\UserPacketProcess.cpp 46 KB CPP 文件 2010/4/5 17:14:25 2018/10/23 13:31:19 2018/10/23 13:31:19 1
746 		break;
747 	case CHAT_MSG_TYPE_WORLD:
748 		strChannel = "跨服";
749 		break;
750 	case CHAT_MSG_TYPE_WORLDPLUS:

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\TestServer\TestServer.cpp 38 KB CPP 文件 2014/2/25 0:11:39 2018/10/23 20:06:57 2018/10/23 20:06:57 2
337 	case EmTestAction_ChangeMap:		// 换地图
338 		{
339 			// dwUserData1:	换地图方式 0.随机,1:到指定地图和位置集合,2.随机跨服
340 			// dwUserData2: 指定地图ID dwUserData3: 指定地图位置X,dwUserData3: 指定地图位置Y
341 			SMsgActionStopHere_SS sendData;
1161 	return true;
1162 }
1164 // 随机取得跨服地图着陆配置信息
1165 bool CTestServer::GetRandWorldMapLandInfo(IPerson * pPerson,DWORD &dwGameWorldID,DWORD &dwMapID,POINT &ptLoc)
1166 {

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\TestServer\TestServer.cpp 38 KB CPP 文件 2014/2/25 14:28:58 2018/10/23 19:45:47 2018/10/23 19:45:47 2
337 	case EmTestAction_ChangeMap:		// 换地图
338 		{
339 			// dwUserData1:	换地图方式 0.随机,1:到指定地图和位置集合,2.随机跨服
340 			// dwUserData2: 指定地图ID dwUserData3: 指定地图位置X,dwUserData3: 指定地图位置Y
341 			SMsgActionStopHere_SS sendData;
1161 	return true;
1162 }
1164 // 随机取得跨服地图着陆配置信息
1165 bool CTestServer::GetRandWorldMapLandInfo(IPerson * pPerson,DWORD &dwGameWorldID,DWORD &dwMapID,POINT &ptLoc)
1166 {

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\TeamService\TeamService.cpp 37 KB CPP 文件 2014/2/25 0:25:15 2018/10/23 20:09:17 2018/10/23 20:09:17 1
632 		return;
633 	}
635 	if(pMainTeam->IsSettingFlag(tTeamSetting_Flag_ForbidKick)/*跨服状态不允许踢人*/)
636 	{
637 		char szTips[1024] = { 0 };

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\TeamService\TeamService.cpp 37 KB CPP 文件 2014/2/25 14:32:28 2018/10/23 19:46:56 2018/10/23 19:46:56 1
632 		return;
633 	}
635 	if(pMainTeam->IsSettingFlag(tTeamSetting_Flag_ForbidKick)/*跨服状态不允许踢人*/)
636 	{
637 		char szTips[1024] = { 0 };

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\TankServer\TankManager.cpp 57 KB CPP 文件 2014/2/25 0:11:14 2018/10/23 20:06:53 2018/10/23 20:06:53 3
94 		// 订阅载具死亡事件
95 		pEventEngine->Subscibe(static_cast<IEventExecuteSink *>(this), EVENT_CREATURE_DIE, SOURCE_TYPE_TANK, 0, "CTankManager::Create");
96 		// 订阅 玩家下线（跨服、跨进程）事件
97 		pEventEngine->Subscibe(static_cast<IEventExecuteSink *>(this), EVENT_PERSON_PRELOGOUT, SOURCE_TYPE_PERSON, 0, "CTankManager::Create");
98 		// 订阅 玩家下线（跨地图）事件
129 		// 取消 订阅载具死亡事件
130 		pEventEngine->UnSubscibe(static_cast<IEventExecuteSink *>(this), EVENT_CREATURE_DIE, SOURCE_TYPE_TANK, 0);
131 		// 取消 订阅玩家下线（跨服、跨进程）事件
132 		pEventEngine->UnSubscibe(static_cast<IEventExecuteSink *>(this), EVENT_PERSON_PRELOGOUT, SOURCE_TYPE_PERSON, 0);
133 		// 取消 订阅玩家下线（跨地图）事件
627 		}
628 		break;
630 	case EVENT_PERSON_PRELOGOUT:		// 玩家下线（跨服、跨进程）事件
631 		{
632 			if(nLen != sizeof(SEventPersonPreLogout_S))

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\TankServer\TankManager.cpp 57 KB CPP 文件 2014/2/25 14:28:41 2018/10/23 19:45:42 2018/10/23 19:45:42 3
94 		// 订阅载具死亡事件
95 		pEventEngine->Subscibe(static_cast<IEventExecuteSink *>(this), EVENT_CREATURE_DIE, SOURCE_TYPE_TANK, 0, "CTankManager::Create");
96 		// 订阅 玩家下线（跨服、跨进程）事件
97 		pEventEngine->Subscibe(static_cast<IEventExecuteSink *>(this), EVENT_PERSON_PRELOGOUT, SOURCE_TYPE_PERSON, 0, "CTankManager::Create");
98 		// 订阅 玩家下线（跨地图）事件
129 		// 取消 订阅载具死亡事件
130 		pEventEngine->UnSubscibe(static_cast<IEventExecuteSink *>(this), EVENT_CREATURE_DIE, SOURCE_TYPE_TANK, 0);
131 		// 取消 订阅玩家下线（跨服、跨进程）事件
132 		pEventEngine->UnSubscibe(static_cast<IEventExecuteSink *>(this), EVENT_PERSON_PRELOGOUT, SOURCE_TYPE_PERSON, 0);
133 		// 取消 订阅玩家下线（跨地图）事件
627 		}
628 		break;
630 	case EVENT_PERSON_PRELOGOUT:		// 玩家下线（跨服、跨进程）事件
631 		{
632 			if(nLen != sizeof(SEventPersonPreLogout_S))

I:\work\source\书剑恩仇录\书剑恩仇录_zccode.com\书剑恩仇录\金\Src\Share\TAB\TabDefine_Share.cpp 90 KB CPP 文件 2013/3/3 12:51:50 2018/10/23 13:36:07 2018/10/23 13:36:07 1
1284 	if (g_Config.m_MultiGroupConfig.m_nGroupCount > 0) 
1285 	{
1286 		//如果是跨服MapServer确保BackScene有配置
1287 		KCheckEx(bFindCurrServerBackScene,"BakSceneInfo.tab表配置错误");
1288 	}

I:\work\source\书剑恩仇录\[src.cool]书剑恩仇录\Src\Share\TAB\TabDefine_Share.cpp 90 KB CPP 文件 2013/3/3 12:51:50 2018/10/23 13:35:06 2018/10/23 13:35:06 1
1284 	if (g_Config.m_MultiGroupConfig.m_nGroupCount > 0) 
1285 	{
1286 		//如果是跨服MapServer确保BackScene有配置
1287 		KCheckEx(bFindCurrServerBackScene,"BakSceneInfo.tab表配置错误");
1288 	}

I:\work\source\书剑恩仇录\书剑恩仇录_zccode.com\书剑恩仇录\金\Src\Share\TAB\TabDefine_Map_Misc.cpp 91 KB CPP 文件 2013/3/3 12:51:46 2018/10/23 13:36:06 2018/10/23 13:36:06 2
2380 /*
2381 =======================================================================================================================
2382 跨服关卡 逻辑数据表
2383 =======================================================================================================================
2384 */
2439 /*
2440 =======================================================================================================================
2441 跨服关卡 配置数据表
2442 =======================================================================================================================
2443 */

I:\work\source\书剑恩仇录\[src.cool]书剑恩仇录\Src\Share\TAB\TabDefine_Map_Misc.cpp 91 KB CPP 文件 2013/3/3 12:51:46 2018/10/23 13:35:06 2018/10/23 13:35:06 2
2380 /*
2381 =======================================================================================================================
2382 跨服关卡 逻辑数据表
2383 =======================================================================================================================
2384 */
2439 /*
2440 =======================================================================================================================
2441 跨服关卡 配置数据表
2442 =======================================================================================================================
2443 */

I:\work\source\蜀山神话\[src.cool]蜀山神话\src\server\gamesvr\SynchManager.cpp 14 KB CPP 文件 2012/4/21 1:05:17 2018/10/23 13:25:14 2018/10/23 13:25:14 9
116         pCharExtraInfo->DoSave(NULL, NULL, true);
117     }
119     // 在线奖励跨服设置
120     pPlayer->OnlineAward_SpanServer();  
121 	pPlayer->SetSectorId(states.m_to_map);
150         gameapi::GuildAssistanceConsume(pPlayer, states.m_nGuildAssistanceCoinType, states.m_nGuildAssistanceCoinCount);
151     }
153     // 通知贵族系统玩家跨服过来
154     GAME_SVR::instance()->GetNobleManager()->OnPlayerLogin(pPlayer);
154     GAME_SVR::instance()->GetNobleManager()->OnPlayerLogin(pPlayer);
156     // 通知幻兽系统玩家跨服过来
157     GAME_SVR::instance()->GetBeastManager()->OnPlayerLogin(pPlayer);
158 }
160 void SynchManager::handle_notify_coming(FiMessage* msg)
161 {
162     //Gate发来的，通知跨服务器传送中，有玩家即将传送到本服
163     //请做好接收准备，准备好后需要发送NotifyComing发送回Gate
165     std::auto_ptr<CharVisitCallback> callback(new CharVisitCallback(this, msg));
165     std::auto_ptr<CharVisitCallback> callback(new CharVisitCallback(this, msg));
167     ClusterGateNotifyComing& come = callback->GetRequest();
169     //在跨服转送的时候，作为接收服务器，此时应该创建对应的角色
170     //实例。
171 	ZuClient* client = m_game_svr->GetClientManager()->FindClient(msg->GetClientNum());
268     UINT32 char_oid = flushed.m_char_oid;
269     UINT32 client_id = msg->GetClientNum();
271     //Gate发来的，通知跨服务器传送中，目标游戏服务器已经就绪
272     //本服务器作为源服务器，可以开始发送同步信息了
273     //发送完同步信息以后，本服务器需要发送ClusterGameConfirmLeaving    
299 void  SynchManager::handle_confirm_leaving(FiMessage* msg)
300 {
301     //Gate发来的，通知跨服务器传送中，源服务器已经完成了所有的
302     //数据同步，本服作为目标服务器可以发送ConfirmComing再次确认
304     ClusterGameConfirmLeaving notify(msg);
330     ClusterGateNotifyComing& notify = callback->GetRequest();
332     std::auto_ptr<ZuCharacter> char_ (callback->DetachCharacter());
334     // 此处的RegisterPlayer是为跨服创建GamePlayer，第三个参数为false
335     m_game_svr->GetEntityManager()->RegisterPlayer(client, char_.get());
336     
402 void SynchManager::handle_confirm_coming(FiMessage* msg)
403 {
404     //Gate发来的，通知跨服务器传送中，目标服务器已经完成了接收
405     //本服作为源服务器，可以清除玩家在本服中的信息了
406     ClusterGameConfirmComing notify(msg);

I:\work\source\仙剑神曲\[src.cool]仙剑神曲\src\server\gamesvr\SynchManager.cpp 15 KB CPP 文件 2012/4/22 2:05:34 2018/10/23 16:11:22 2018/10/23 16:11:22 7
114     GamePlayer* pPlayer = gameapi::FindPlayerByOID(packet.m_nCharOid);
115     CHECK_NULL(pPlayer);
117 	// 跨服重建BUFF
118 	pPlayer->RebuildSvrBuff(packet.m_buff_array, packet.m_buffCnt);
120 	// 重建后最大Hp与传送过来时不同
145         return;
146     }
148     // 跨服重建法宝状态
149     GAME_SVR::instance()->GetTrumpManager()->RebuildSvrTrumpState(pPlayer, trumpState.m_syncData);
150 }
180 void SynchManager::handle_notify_coming(FiMessage* msg)
181 {
182     //Gate发来的，通知跨服务器传送中，有玩家即将传送到本服
183     //请做好接收准备，准备好后需要发送NotifyComing发送回Gate
185     std::auto_ptr<CharVisitCallback> callback(new CharVisitCallback(this, msg));
185     std::auto_ptr<CharVisitCallback> callback(new CharVisitCallback(this, msg));
187     ClusterGateNotifyComing& come = callback->GetRequest();
189     //在跨服转送的时候，作为接收服务器，此时应该创建对应的角色实例。
190 	ZuClient* client = m_game_svr->GetClientManager()->FindClient(msg->GetClientNum());
191 	if (!client)
280     UINT32 char_oid = flushed.m_char_oid;
281     UINT32 client_id = msg->GetClientNum();
283     //Gate发来的，通知跨服务器传送中，目标游戏服务器已经就绪
284     //本服务器作为源服务器，可以开始发送同步信息了
285     //发送完同步信息以后，本服务器需要发送ClusterGameConfirmLeaving    
311 void  SynchManager::handle_confirm_leaving(FiMessage* msg)
312 {
313     //Gate发来的，通知跨服务器传送中，源服务器已经完成了所有的
314     //数据同步，本服作为目标服务器可以发送ConfirmComing再次确认
316     ClusterGameConfirmLeaving notify(msg);
435 void SynchManager::handle_confirm_coming(FiMessage* msg)
436 {
437     //Gate发来的，通知跨服务器传送中，目标服务器已经完成了接收
438     //本服作为源服务器，可以清除玩家在本服中的信息了
439     ClusterGameConfirmComing notify(msg);

I:\work\source\书剑恩仇录\书剑恩仇录_zccode.com\书剑恩仇录\金\Src\Share\StructRoomBattle.cpp 118 KB CPP 文件 2013/3/3 11:32:38 2018/10/23 13:36:05 2018/10/23 13:36:05 21
4 Author:Michael		
5 Created:Michael    
6 Description :跨服房间相关结构
7 Revision :  2011/06/21 Michael create
9 =============================================================================*/
1005 }
1008 /************************************************************************/
1009 /* 跨服报名候选数据结构定义  		                                    */
1010 /************************************************************************/
1011 BOOL RoomBattleSignupInfo::IsRoomIDInList(RoomID_t nRoomID) const
1145 }
1146 /************************************************************************/
1147 /* 跨服报名候选数据结构定义 客户端消息结构                              */
1148 /************************************************************************/
1149 void RoomBattleSignupInfo_CX_Msg::Clear()
1186 }
1188 /************************************************************************/
1189 /* 跨服取消报名结构定义   客户端消息结构	                           */
1190 /************************************************************************/
1191 void RoomBattleSignupCancel_CX_Msg::Clear()
1216 }
1218 /************************************************************************/
1219 /* 跨服确认进入结构定义    客户端消息结构	                           */
1220 /************************************************************************/
1221 void RoomBattleWaitingEnter_CX_Msg::Clear()
1324 }
1326 /************************************************************************/
1327 /* 跨服玩家确认结构定义    服务器消息结构	                           */
1328 /************************************************************************/
1329 void RoomBattlePlayerEnter_XC_Msg::Clear()
1363 }
1365 /************************************************************************/
1366 /* 跨服军团成员离开    服务器消息结构	                                */
1367 /************************************************************************/
1368 void RoomBattlePlayerLeave_XC_Msg::Clear()
1422 }
1425 /************************************************************************/
1426 /* 跨服确认进入结构定义    服务器消息结构	                           */
1427 /************************************************************************/
1428 void RoomBattleWaitingEnter_XC_Msg::Clear()
1796 }
1797 /************************************************************************/
1798 /* 跨服MapServer信息                  		                            */
1799 /************************************************************************/
1800 bool SMutiGroupMapServerInfo::IsValid( void ) const
1917 }
1919 /************************************************************************/
1920 /* 跨服关卡消息结构定义 MGP-->GL               		                    */
1921 /************************************************************************/
1922 uint32 MsgMGRoomBattle::GetMsgSize() const
1994 }
1996 /************************************************************************/
1997 /* 跨服关卡消息结构定义 GL-->MGP               		                    */
1998 /************************************************************************/
1999 uint32 MsgGMRoomBattle::GetMsgSize() const
2086 }
2087 /************************************************************************/
2088 /* 跨服关卡消息结构定义 MGP-->GL-->MGP  用于客户端确认进入或取消            */
2089 /************************************************************************/
2090 uint32 MsgXGMRoomBattle_ReplyEnter::GetMsgSize()const
2123 }
2125 /************************************************************************/
2126 /* 跨服关卡消息结构定义 MGP-->GL-->MGP  用于客户端确认进入或取消广播            */
2127 /************************************************************************/
2128 uint32 MsgXGMRoomBattle_ReplyEnter_BROADCAST::GetMsgSize()const
2161 }
2163 /************************************************************************/
2164 /* 跨服关卡消息结构定义 MGP-->GL-->MGP  客户端确认离开，重新返回报名状态 */
2165 /************************************************************************/
2166 uint32 MsgXGMRoomBattle_Leave::GetMsgSize()const
2199 }
2201 /************************************************************************/
2202 /* 跨服关卡消息结构定义 MGP-->GL-->MGP        		                    */
2203 /************************************************************************/
2204 uint32 MsgMGMRoomBattle::GetMsgSize() const
2258 }
2260 /************************************************************************/
2261 /* 跨服关卡消息结构定义 MAP-->GL-->MGP        		                    */
2262 /************************************************************************/
2263 uint32 MsgXGMRoomBattle::GetMsgSize() const
2377 }
2379 /************************************************************************/
2380 /* 跨服关卡消息结构定义 MGP-->GL-->MAP        		                    */
2381 /************************************************************************/
2382 uint32 MsgMGXRoomBattle::GetMsgSize() const
2493 }
2495 /************************************************************************/
2496 /* 跨服关卡消息结构定义 Client-->MAP        		                    */
2497 /************************************************************************/
2498 uint32 MsgCXRoomBattle::GetMsgSize() const
2588 }
2590 /************************************************************************/
2591 /* 跨服关卡消息结构定义 MAP-->Client        		                    */
2592 /************************************************************************/
2593 uint32 MsgXCRoomBattle::GetMsgSize() const
3058 }
3060 /************************************************************************/
3061 /* 跨服关卡消息结构定义 Client-->MAP        		                    */
3062 /************************************************************************/
3063 uint32 MsgCXPKRoom::GetMsgSize() const
3908 }
3911 /************************************************************************/
3912 /* 跨服关卡消息结构定义 MAP-->GL-->MGP        		                    */
3913 /************************************************************************/
3914 uint32 MsgXGMPKRoom::GetMsgSize() const

I:\work\source\书剑恩仇录\[src.cool]书剑恩仇录\Src\Share\StructRoomBattle.cpp 118 KB CPP 文件 2013/3/3 11:32:38 2018/10/23 13:35:06 2018/10/23 13:35:06 21
4 Author:Michael		
5 Created:Michael    
6 Description :跨服房间相关结构
7 Revision :  2011/06/21 Michael create
9 =============================================================================*/
1005 }
1008 /************************************************************************/
1009 /* 跨服报名候选数据结构定义  		                                    */
1010 /************************************************************************/
1011 BOOL RoomBattleSignupInfo::IsRoomIDInList(RoomID_t nRoomID) const
1145 }
1146 /************************************************************************/
1147 /* 跨服报名候选数据结构定义 客户端消息结构                              */
1148 /************************************************************************/
1149 void RoomBattleSignupInfo_CX_Msg::Clear()
1186 }
1188 /************************************************************************/
1189 /* 跨服取消报名结构定义   客户端消息结构	                           */
1190 /************************************************************************/
1191 void RoomBattleSignupCancel_CX_Msg::Clear()
1216 }
1218 /************************************************************************/
1219 /* 跨服确认进入结构定义    客户端消息结构	                           */
1220 /************************************************************************/
1221 void RoomBattleWaitingEnter_CX_Msg::Clear()
1324 }
1326 /************************************************************************/
1327 /* 跨服玩家确认结构定义    服务器消息结构	                           */
1328 /************************************************************************/
1329 void RoomBattlePlayerEnter_XC_Msg::Clear()
1363 }
1365 /************************************************************************/
1366 /* 跨服军团成员离开    服务器消息结构	                                */
1367 /************************************************************************/
1368 void RoomBattlePlayerLeave_XC_Msg::Clear()
1422 }
1425 /************************************************************************/
1426 /* 跨服确认进入结构定义    服务器消息结构	                           */
1427 /************************************************************************/
1428 void RoomBattleWaitingEnter_XC_Msg::Clear()
1796 }
1797 /************************************************************************/
1798 /* 跨服MapServer信息                  		                            */
1799 /************************************************************************/
1800 bool SMutiGroupMapServerInfo::IsValid( void ) const
1917 }
1919 /************************************************************************/
1920 /* 跨服关卡消息结构定义 MGP-->GL               		                    */
1921 /************************************************************************/
1922 uint32 MsgMGRoomBattle::GetMsgSize() const
1994 }
1996 /************************************************************************/
1997 /* 跨服关卡消息结构定义 GL-->MGP               		                    */
1998 /************************************************************************/
1999 uint32 MsgGMRoomBattle::GetMsgSize() const
2086 }
2087 /************************************************************************/
2088 /* 跨服关卡消息结构定义 MGP-->GL-->MGP  用于客户端确认进入或取消            */
2089 /************************************************************************/
2090 uint32 MsgXGMRoomBattle_ReplyEnter::GetMsgSize()const
2123 }
2125 /************************************************************************/
2126 /* 跨服关卡消息结构定义 MGP-->GL-->MGP  用于客户端确认进入或取消广播            */
2127 /************************************************************************/
2128 uint32 MsgXGMRoomBattle_ReplyEnter_BROADCAST::GetMsgSize()const
2161 }
2163 /************************************************************************/
2164 /* 跨服关卡消息结构定义 MGP-->GL-->MGP  客户端确认离开，重新返回报名状态 */
2165 /************************************************************************/
2166 uint32 MsgXGMRoomBattle_Leave::GetMsgSize()const
2199 }
2201 /************************************************************************/
2202 /* 跨服关卡消息结构定义 MGP-->GL-->MGP        		                    */
2203 /************************************************************************/
2204 uint32 MsgMGMRoomBattle::GetMsgSize() const
2258 }
2260 /************************************************************************/
2261 /* 跨服关卡消息结构定义 MAP-->GL-->MGP        		                    */
2262 /************************************************************************/
2263 uint32 MsgXGMRoomBattle::GetMsgSize() const
2377 }
2379 /************************************************************************/
2380 /* 跨服关卡消息结构定义 MGP-->GL-->MAP        		                    */
2381 /************************************************************************/
2382 uint32 MsgMGXRoomBattle::GetMsgSize() const
2493 }
2495 /************************************************************************/
2496 /* 跨服关卡消息结构定义 Client-->MAP        		                    */
2497 /************************************************************************/
2498 uint32 MsgCXRoomBattle::GetMsgSize() const
2588 }
2590 /************************************************************************/
2591 /* 跨服关卡消息结构定义 MAP-->Client        		                    */
2592 /************************************************************************/
2593 uint32 MsgXCRoomBattle::GetMsgSize() const
3058 }
3060 /************************************************************************/
3061 /* 跨服关卡消息结构定义 Client-->MAP        		                    */
3062 /************************************************************************/
3063 uint32 MsgCXPKRoom::GetMsgSize() const
3908 }
3911 /************************************************************************/
3912 /* 跨服关卡消息结构定义 MAP-->GL-->MGP        		                    */
3913 /************************************************************************/
3914 uint32 MsgXGMPKRoom::GetMsgSize() const

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MatchServer\StrikeServer.cpp 27 KB CPP 文件 2014/2/25 0:09:02 2018/10/23 20:06:24 2018/10/23 20:06:24 2
68 	// 调式代码
69 	char szBuf[512]={0};
70 	sprintf_s(szBuf,sizeof(szBuf), "CStrikeServer::HandleBridgeMessage()  跨服 服务器撮合信息子消息:来源游戏世界ID=%d,来源服务器ID=%d,子消息代码=%d,len=%d,用户数据=%d,%d,%d",
71 		bridgeHead.dwWorldID,bridgeHead.dwServerID,pMsg->dwMsgCode,len,pMsg->dwUserData1,pMsg->dwUserData2,pMsg->dwUserData3);
72 	TraceLn(szBuf);
86 	default:
87 		{
88 			ErrorLn("跨区竞技系统有一个跨服撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
89 		}
90 		break;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MatchServer\StrikeServer.cpp 27 KB CPP 文件 2014/2/25 14:27:14 2018/10/23 19:45:13 2018/10/23 19:45:13 2
68 	// 调式代码
69 	char szBuf[512]={0};
70 	sprintf_s(szBuf,sizeof(szBuf), "CStrikeServer::HandleBridgeMessage()  跨服 服务器撮合信息子消息:来源游戏世界ID=%d,来源服务器ID=%d,子消息代码=%d,len=%d,用户数据=%d,%d,%d",
71 		bridgeHead.dwWorldID,bridgeHead.dwServerID,pMsg->dwMsgCode,len,pMsg->dwUserData1,pMsg->dwUserData2,pMsg->dwUserData3);
72 	TraceLn(szBuf);
86 	default:
87 		{
88 			ErrorLn("跨区竞技系统有一个跨服撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
89 		}
90 		break;

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\MatchService\StrikeMatch.cpp 73 KB CPP 文件 2014/2/25 0:23:11 2018/10/23 20:09:04 2018/10/23 20:09:04 6
5 ** 日  期:	2010-10-27
6 ** 版  本:	1.0
7 ** 描  述:	跨服竞技撮合系统服务
8 ** 应  用:  	
9 	
78 ///////////////////////////IStrikeMatch///////////////////////////////////////////////
80 /**
81 @name  : 建立跨服组队撮合系统服务
82 */
83 bool CStrikeMatch::Create()
570 	default:
571 		{
572 			ErrorLn("跨服竞技撮合系统服务有一个子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
573 		}
574 		break;
663 	default:
664 		{
665 			ErrorLn("跨服竞技撮合系统服务有一个桥服务器发过来的子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
666 		}
667 		break;
694 	ostrbuf osb;
695 	ostrbuf link;
696 	link << "<img src=\"set:MatchStrike image:StrikeKill\"><a color='#FF00FF00' href=\"Z?18&21&\">点击进行跨服竞技PK";
697 	osb << "<rich color='#FF00FFFF'>" << szWorldName << "<rich color='FFFFFFFF'>的<rich color='#FF00FFFF'>" << member.szName<< "<rich color='FFFFFFFF'>通过<rich color='#FF00FFFF'>跨服竞技系统<rich color='FFFFFFFF'>成功进入<rich color='#FF00FFFF'>" << schemeInfo.szName << "　" << link << "<rich color='default'>";
699 	DWORD dwArrWorldID[256] = {0};
700 	DWORD dwCount = 0;

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MatchServer\StrikeMatch.cpp 52 KB CPP 文件 2014/2/25 0:09:02 2018/10/23 20:06:24 2018/10/23 20:06:24 6
5 ** 日  期:	2010-10-27
6 ** 版  本:	1.0
7 ** 描  述:	跨服竞技撮合系统服务器
8 ** 应  用:  	
9 	
68 	// 调式代码
69 	char szBuf[512]={0};
70 	sprintf_s(szBuf,sizeof(szBuf), "CStrikeMatch::HandleBridgeMessage()  跨服 服务器撮合信息子消息:来源游戏世界ID=%d,来源服务器ID=%d,子消息代码=%d,len=%d,用户数据=%d,%d,%d",
71 		bridgeHead.dwWorldID,bridgeHead.dwServerID,pMsg->dwMsgCode,len,pMsg->dwUserData1,pMsg->dwUserData2,pMsg->dwUserData3);
72 	TraceLn(szBuf);
91 	default:
92 		{
93 			ErrorLn("跨服竞技撮合系统有一个跨服撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
94 		}
95 		break;
431 	default:
432 		{
433 			ErrorLn("跨服竞技撮合系统有一个服务器撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
434 		}
435 		break;
526 	default:
527 		{
528 			ErrorLn("跨服竞技撮合系统有一个客户端撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
529 		}
530 		break;

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcClient\Client\MatchClient\StrikeMatch.cpp 15 KB CPP 文件 2014/2/25 8:34:47 2018/10/23 19:52:18 2018/10/23 19:52:18 2
5 ** 日  期:	2010-10-27
6 ** 版  本:	1.0
7 ** 描  述:	跨服竞技撮合系统客户端
8 ** 应  用:  	
9 	
461 	default:
462 		{
463 			ErrorLn("跨服竞技撮合系统客户端有一个服务器撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
464 		}
465 		break;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\MatchService\StrikeMatch.cpp 73 KB CPP 文件 2014/2/25 14:31:42 2018/10/23 19:46:42 2018/10/23 19:46:42 6
5 ** 日  期:	2010-10-27
6 ** 版  本:	1.0
7 ** 描  述:	跨服竞技撮合系统服务
8 ** 应  用:  	
9 	
78 ///////////////////////////IStrikeMatch///////////////////////////////////////////////
80 /**
81 @name  : 建立跨服组队撮合系统服务
82 */
83 bool CStrikeMatch::Create()
570 	default:
571 		{
572 			ErrorLn("跨服竞技撮合系统服务有一个子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
573 		}
574 		break;
663 	default:
664 		{
665 			ErrorLn("跨服竞技撮合系统服务有一个桥服务器发过来的子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
666 		}
667 		break;
694 	ostrbuf osb;
695 	ostrbuf link;
696 	link << "<img src=\"set:MatchStrike image:StrikeKill\"><a color='#FF00FF00' href=\"Z?18&21&\">点击进行跨服竞技PK";
697 	osb << "<rich color='#FF00FFFF'>" << szWorldName << "<rich color='FFFFFFFF'>的<rich color='#FF00FFFF'>" << member.szName<< "<rich color='FFFFFFFF'>通过<rich color='#FF00FFFF'>跨服竞技系统<rich color='FFFFFFFF'>成功进入<rich color='#FF00FFFF'>" << schemeInfo.szName << "　" << link << "<rich color='default'>";
699 	DWORD dwArrWorldID[256] = {0};
700 	DWORD dwCount = 0;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MatchServer\StrikeMatch.cpp 52 KB CPP 文件 2014/2/25 14:27:13 2018/10/23 19:45:13 2018/10/23 19:45:13 6
5 ** 日  期:	2010-10-27
6 ** 版  本:	1.0
7 ** 描  述:	跨服竞技撮合系统服务器
8 ** 应  用:  	
9 	
68 	// 调式代码
69 	char szBuf[512]={0};
70 	sprintf_s(szBuf,sizeof(szBuf), "CStrikeMatch::HandleBridgeMessage()  跨服 服务器撮合信息子消息:来源游戏世界ID=%d,来源服务器ID=%d,子消息代码=%d,len=%d,用户数据=%d,%d,%d",
71 		bridgeHead.dwWorldID,bridgeHead.dwServerID,pMsg->dwMsgCode,len,pMsg->dwUserData1,pMsg->dwUserData2,pMsg->dwUserData3);
72 	TraceLn(szBuf);
91 	default:
92 		{
93 			ErrorLn("跨服竞技撮合系统有一个跨服撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
94 		}
95 		break;
431 	default:
432 		{
433 			ErrorLn("跨服竞技撮合系统有一个服务器撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
434 		}
435 		break;
526 	default:
527 		{
528 			ErrorLn("跨服竞技撮合系统有一个客户端撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
529 		}
530 		break;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcClient\Client\MatchClient\StrikeMatch.cpp 15 KB CPP 文件 2014/2/25 13:44:53 2018/10/23 19:34:25 2018/10/23 19:34:25 2
5 ** 日  期:	2010-10-27
6 ** 版  本:	1.0
7 ** 描  述:	跨服竞技撮合系统客户端
8 ** 应  用:  	
9 	
461 	default:
462 		{
463 			ErrorLn("跨服竞技撮合系统客户端有一个服务器撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
464 		}
465 		break;

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MatchServer\StrikeDropPrize.cpp 64 KB CPP 文件 2014/2/25 0:09:00 2018/10/23 20:06:24 2018/10/23 20:06:24 1
1198 					strWorldName = pInfo->GetWorldName();
1199 				}
1201 				osb << "<rich color='#FFFF80FF'>" << strWorldName.c_str()<<"[" <<  pPerson->GetName() <<"]跨服竞技抽奖获得"<< nodeData.strMsgBuf.c_str() << "<rich color='default'>";
1204 				DWORD dwArrWorldID[256] = {0};
1205 				DWORD dwCount = 0;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MatchServer\StrikeDropPrize.cpp 64 KB CPP 文件 2014/2/25 14:27:12 2018/10/23 19:45:13 2018/10/23 19:45:13 1
1198 					strWorldName = pInfo->GetWorldName();
1199 				}
1201 				osb << "<rich color='#FFFF80FF'>" << strWorldName.c_str()<<"[" <<  pPerson->GetName() <<"]跨服竞技抽奖获得"<< nodeData.strMsgBuf.c_str() << "<rich color='default'>";
1204 				DWORD dwArrWorldID[256] = {0};
1205 				DWORD dwCount = 0;

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MatchServer\Strike.cpp 329 KB CPP 文件 2014/2/25 0:08:59 2018/10/23 20:06:24 2018/10/23 20:06:24 11
809 	}
811 	char szReason[128];
812 	strncpy(szReason,"跨服竞技载具场自动赠送",DIM(szReason)-1);
813 	szReason[DIM(szReason)-1] = '\0';
814 	//判断添加物品条件
914 // 
915 // 	BYTE * bySerial = NULL;
916 // 	int nRetVal = pPacketSkepPart->AddGoods(pGoodsItem->GetUID(),-1,OssResAdd_StrikeFree, "跨服竞技载具场自动赠送", false, bySerial);
917 // 	if ( nRetVal == -1)
918 // 	{
2013 	if (pStrikeInfo != NULL)
2014 	{
2015 		// 强制性设置 跨服进入PVP类型
2016 		pStrikeInfo->nEnterType = PVPClassType_Strike;
2017 	}
2739 /** 资源事件执行接口
2740 @param   WORD wEventID		:事件ID
2741 @param   WORD dwPVPClassType:跨服PVP类型 EMPVPClassType
2742 @param   WORD dwWarID		:相关战场ID
2743 @param   WORD dwResID		:相关战争资源配置ID
2754 /** 资源投票事件
2755 @param   WORD wEventID		:事件ID
2756 @param   WORD dwPVPClassType:跨服PVP类型 EMPVPClassType
2757 @param   WORD dwWarID		:相关战场ID
2758 @param   WORD dwResID		:相关战争资源配置ID
7294 				}
7295 			}
7296 			else if (m_StrikeSchemeInfo.nPrizeMode == StrikePrizeType_Task)			// 跨服西瓜活动，按活动方式计算奖励
7297 			{
7298 				IChatServer * pChatServer = gZoneServiceProvider->GetChatServer();
7406 							if(pPerson->SetNumProp(CREATURE_PROP_EXP, dwAddExp, true))
7407 							{
7408 								pOSSLogServer->TrackAddExp(dwPlayerID, 0, dwAddExp, OssResAdd_StrikeTask, 0, "跨服活动型对抗赛获得经验奖励");
7409 							}
7410 							else
7418 						if (nAddCredit > 0)
7419 						{
7420 							if(pCreditPart->InCreditValue(ECreditSubID_Nation, nAddCredit, "跨服活动型对抗赛获得国家声望",OssResAdd_StrikeTask)==false)
7421 							{
7422 								nAddCredit = 0;
8515 						if(pPerson->SetNumProp(CREATURE_PROP_EXP, dwAddExp, true))
8516 						{
8517 							pOSSLogServer->TrackAddExp(dwPlayerID, 0, dwAddExp, OssResAdd_StrikeTask, 0, "跨服活动型生存赛获得经验奖励");
8518 						}
8519 						else
8532                             bCreditSucc = pCreditPart->InCreditValue(ECreditSubID_Ectype,
8533                                 nAddCredit,
8534                                 "跨服活动型对抗赛获得副本声望",
8535                                 OssResAdd_StrikeTask);
8536                         }
8539                             bCreditSucc = pCreditPart->InCreditValue(ECreditSubID_Nation,
8540                                 nAddCredit,
8541                                 "跨服活动型对抗赛获得国家声望",
8542                                 OssResAdd_StrikeTask);
8543                         }

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MatchServer\Strike.cpp 329 KB CPP 文件 2014/2/25 14:27:11 2018/10/23 19:45:13 2018/10/23 19:45:13 11
809 	}
811 	char szReason[128];
812 	strncpy(szReason,"跨服竞技载具场自动赠送",DIM(szReason)-1);
813 	szReason[DIM(szReason)-1] = '\0';
814 	//判断添加物品条件
914 // 
915 // 	BYTE * bySerial = NULL;
916 // 	int nRetVal = pPacketSkepPart->AddGoods(pGoodsItem->GetUID(),-1,OssResAdd_StrikeFree, "跨服竞技载具场自动赠送", false, bySerial);
917 // 	if ( nRetVal == -1)
918 // 	{
2013 	if (pStrikeInfo != NULL)
2014 	{
2015 		// 强制性设置 跨服进入PVP类型
2016 		pStrikeInfo->nEnterType = PVPClassType_Strike;
2017 	}
2739 /** 资源事件执行接口
2740 @param   WORD wEventID		:事件ID
2741 @param   WORD dwPVPClassType:跨服PVP类型 EMPVPClassType
2742 @param   WORD dwWarID		:相关战场ID
2743 @param   WORD dwResID		:相关战争资源配置ID
2754 /** 资源投票事件
2755 @param   WORD wEventID		:事件ID
2756 @param   WORD dwPVPClassType:跨服PVP类型 EMPVPClassType
2757 @param   WORD dwWarID		:相关战场ID
2758 @param   WORD dwResID		:相关战争资源配置ID
7294 				}
7295 			}
7296 			else if (m_StrikeSchemeInfo.nPrizeMode == StrikePrizeType_Task)			// 跨服西瓜活动，按活动方式计算奖励
7297 			{
7298 				IChatServer * pChatServer = gZoneServiceProvider->GetChatServer();
7406 							if(pPerson->SetNumProp(CREATURE_PROP_EXP, dwAddExp, true))
7407 							{
7408 								pOSSLogServer->TrackAddExp(dwPlayerID, 0, dwAddExp, OssResAdd_StrikeTask, 0, "跨服活动型对抗赛获得经验奖励");
7409 							}
7410 							else
7418 						if (nAddCredit > 0)
7419 						{
7420 							if(pCreditPart->InCreditValue(ECreditSubID_Nation, nAddCredit, "跨服活动型对抗赛获得国家声望",OssResAdd_StrikeTask)==false)
7421 							{
7422 								nAddCredit = 0;
8515 						if(pPerson->SetNumProp(CREATURE_PROP_EXP, dwAddExp, true))
8516 						{
8517 							pOSSLogServer->TrackAddExp(dwPlayerID, 0, dwAddExp, OssResAdd_StrikeTask, 0, "跨服活动型生存赛获得经验奖励");
8518 						}
8519 						else
8532                             bCreditSucc = pCreditPart->InCreditValue(ECreditSubID_Ectype,
8533                                 nAddCredit,
8534                                 "跨服活动型对抗赛获得副本声望",
8535                                 OssResAdd_StrikeTask);
8536                         }
8539                             bCreditSucc = pCreditPart->InCreditValue(ECreditSubID_Nation,
8540                                 nAddCredit,
8541                                 "跨服活动型对抗赛获得国家声望",
8542                                 OssResAdd_StrikeTask);
8543                         }

I:\work\source\龙腾世界\[src.cool]龙腾世界\Code\Code\GraphNetServer\SrvrGSProcess_Er2Gs.cpp 98 KB CPP 文件 2007/2/3 23:52:26 2018/10/22 15:45:41 2018/10/22 15:45:41 1
1972 				}
1973 				else
1974 				{// 跨服务器切换场景的 login
1975 					WORD	para[4] = {NMC_INCHARACTER_RETURN, (aParam[1].m_bValue ? 1 : 0),
1976 										(WORD)aParam[3].m_dwValue, (WORD)nGateCharacterID};

I:\work\source\龙腾世界\[src.cool]龙腾世界\Code\Code\GraphNetServer\SrvrGSProcess.cpp 46 KB CPP 文件 2007/4/5 12:56:24 2018/10/22 15:45:41 2018/10/22 15:45:41 1
260 				if ( ENTERROOM_FROM_REMOTE_SERVER == eFromMode )
261 				{
262 					// 告诉客户端跨服务器了
263 					GetERCmdCentral()->SendSharpPackToClient( pERPlayer->IDNet(), FMI_STOC_GOTO_OTHER_SERVER, -1, -1, -1, NULL, 0 );
264 				}

I:\work\source\龙腾世界\[src.cool]龙腾世界\Code\Code\GraphNetServer\SrvrERProcess.cpp 25 KB CPP 文件 2007/1/26 13:05:52 2018/10/22 15:45:41 2018/10/22 15:45:41 1
455 	if ( SUCCEEDED(hr) )
456 	{
457 		//是不是跨服务器切场景。
458 		BOOL bIsFormOtherServer = pChangeSvrInfo ? TRUE : FALSE;
460 		//启动客户端反外挂

I:\work\source\晶铁之门\晶铁之门\晶铁之门全套源码+数据库\code\server\winserver\Map\src\DICTIONARY\SKILL\Skill.cpp 140 KB CPP 文件 2011/4/21 9:31:58 2018/10/19 14:24:36 2018/10/19 14:24:36 2
1918 		return;
1919 	/*
1920 	//不能跨服务器传送
1921 	if (pSub->GetSpaceInstance() != pObj->GetSpaceInstance())
1922 	{
1925 	}
1926 	// */
1927 	// 2010-3-5 masuo 不能跨服，也不能在里面使用
1928 	if (pSub->GetSpaceInstance() > 0 || pSub->GetSpaceInstance() != pObj->GetSpaceInstance())
1929 	{

I:\work\source\晶铁之门\[src.cool]晶铁之门\Src\code\server\winserver\Map\src\DICTIONARY\SKILL\Skill.cpp 140 KB CPP 文件 2011/4/21 9:31:58 2018/10/19 14:24:32 2018/10/19 14:24:32 2
1918 		return;
1919 	/*
1920 	//不能跨服务器传送
1921 	if (pSub->GetSpaceInstance() != pObj->GetSpaceInstance())
1922 	{
1925 	}
1926 	// */
1927 	// 2010-3-5 masuo 不能跨服，也不能在里面使用
1928 	if (pSub->GetSpaceInstance() > 0 || pSub->GetSpaceInstance() != pObj->GetSpaceInstance())
1929 	{

I:\work\source\书剑恩仇录\书剑恩仇录_zccode.com\书剑恩仇录\金\Src\MapServer\Server\GameLogic\SignUpMgr.cpp 83 KB CPP 文件 2013/3/3 13:58:34 2018/10/23 13:34:39 2018/10/23 13:34:39 1
4 Author:shangy		
5 Created:shangy    
6 Description :跨服报名管理类
7 Revision :  2011/06/20 shangy create
8 			2011/08/05 Michael Lin Modify

I:\work\source\书剑恩仇录\[src.cool]书剑恩仇录\Src\MapServer\Server\GameLogic\SignUpMgr.cpp 83 KB CPP 文件 2013/3/3 13:58:34 2018/10/23 13:34:21 2018/10/23 13:34:21 1
4 Author:shangy		
5 Created:shangy    
6 Description :跨服报名管理类
7 Revision :  2011/06/20 shangy create
8 			2011/08/05 Michael Lin Modify

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\CountryService\SiegeWarService.cpp 57 KB CPP 文件 2014/2/25 0:21:43 2018/10/23 20:08:53 2018/10/23 20:08:53 1
274 		}*/
275 	}
276 	// 跨服更新共享国家信息列表到
277 	gGlobalCountryServer->SendWorldCountryToBridgeServer(0,pApplyInfo->dwAttCountry);
278 	gGlobalCountryServer->SendWorldCountryToBridgeServer(0,pApplyInfo->dwDefCountry);

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\CountryService\SiegeWarService.cpp 57 KB CPP 文件 2014/2/25 14:31:00 2018/10/23 19:46:34 2018/10/23 19:46:34 1
274 		}*/
275 	}
276 	// 跨服更新共享国家信息列表到
277 	gGlobalCountryServer->SendWorldCountryToBridgeServer(0,pApplyInfo->dwAttCountry);
278 	gGlobalCountryServer->SendWorldCountryToBridgeServer(0,pApplyInfo->dwDefCountry);

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\SiegeWarServer\SiegeWarServer.cpp 93 KB CPP 文件 2014/2/25 0:10:42 2018/10/23 20:06:46 2018/10/23 20:06:46 1
2616 		return;
2617 	}
2618 	// 取得跨服组队撮合服务器
2619 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
2620 	if (pMatchServer == NULL)

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\SiegeWarServer\SiegeWarServer.cpp 93 KB CPP 文件 2014/2/25 14:28:21 2018/10/23 19:45:37 2018/10/23 19:45:37 1
2616 		return;
2617 	}
2618 	// 取得跨服组队撮合服务器
2619 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
2620 	if (pMatchServer == NULL)

I:\work\source\书剑恩仇录\书剑恩仇录_zccode.com\书剑恩仇录\金\Src\Share\Core\Setting.cpp 88 KB CPP 文件 2013/3/3 12:49:24 2018/10/23 13:35:56 2018/10/23 13:35:56 4
309 /*
310 =======================================================================================================================
311  加载跨服配置信息
312 =======================================================================================================================
313 */
337 		m_MultiGroupConfig.m_GLServerInfo[i].m_Port = ini.Get_Property_Int( szSection, "gl_port" );
338 		m_MultiGroupConfig.m_GLServerInfo[i].m_WorldID = ini.Get_Property_Int( szSection, "gl_worldid" );
340 		// 2011-11-05 by Michael Lin 改变跨服配置文件结构
341 		int32 nMapCount = ini.Get_Property_Int(szSection,"map_count");
342 		KCheckEx(nMapCount >= 0 && nMapCount <= PERGROUP_MAX_MAPCOUNT,
359 		}
360 	}
362 	//跨服关卡报名服务器开关 added by Michael Lin 2011-08-03
363 	m_MultiGroupConfig.m_SignUpServerToggle = ini.Get_Property_Int( "Room", "SignUpServerToggle" );
365 	__UNGUARD__
1079 	m_ConfigInfo.m_nVendueBidIncreaseLimit = ini.Get_Property_Int("Vendue", "VendueBidIncreaseLimit");
1080 	m_ConfigInfo.m_nVendueBargainOnTax = ini.GetFloat("Vendue", "VendueBargainOnTax") / 1000;
1082 	//added for跨服军团 by Michael Lin 2011-07-26
1083 	for (int32 _nGIndex = 0; _nGIndex < MAX_GROUP_MEMBER; ++_nGIndex)
1084 	{

I:\work\source\书剑恩仇录\[src.cool]书剑恩仇录\Src\Share\Core\Setting.cpp 88 KB CPP 文件 2013/3/3 12:49:24 2018/10/23 13:35:01 2018/10/23 13:35:01 4
309 /*
310 =======================================================================================================================
311  加载跨服配置信息
312 =======================================================================================================================
313 */
337 		m_MultiGroupConfig.m_GLServerInfo[i].m_Port = ini.Get_Property_Int( szSection, "gl_port" );
338 		m_MultiGroupConfig.m_GLServerInfo[i].m_WorldID = ini.Get_Property_Int( szSection, "gl_worldid" );
340 		// 2011-11-05 by Michael Lin 改变跨服配置文件结构
341 		int32 nMapCount = ini.Get_Property_Int(szSection,"map_count");
342 		KCheckEx(nMapCount >= 0 && nMapCount <= PERGROUP_MAX_MAPCOUNT,
359 		}
360 	}
362 	//跨服关卡报名服务器开关 added by Michael Lin 2011-08-03
363 	m_MultiGroupConfig.m_SignUpServerToggle = ini.Get_Property_Int( "Room", "SignUpServerToggle" );
365 	__UNGUARD__
1079 	m_ConfigInfo.m_nVendueBidIncreaseLimit = ini.Get_Property_Int("Vendue", "VendueBidIncreaseLimit");
1080 	m_ConfigInfo.m_nVendueBargainOnTax = ini.GetFloat("Vendue", "VendueBargainOnTax") / 1000;
1082 	//added for跨服军团 by Michael Lin 2011-07-26
1083 	for (int32 _nGIndex = 0; _nGIndex < MAX_GROUP_MEMBER; ++_nGIndex)
1084 	{

I:\work\source\神魔传奇\[src.cool]神魔传奇代码\Server\ScenesServer\SessionClient.cpp 160 KB CPP 文件 2012/1/17 23:01:19 2018/10/23 13:18:01 2018/10/23 13:18:01 1
2457 			sprintf(pUser->charbase.OldMap, "%s-%d-%d", pUser->scene->name, pUser->getPos().x, pUser->getPos().y);
2458 			strncpy(pUser->charbase.mapName,(char *)rev->map_name,MAX_NAMESIZE);
2459 			Zebra::logger->info("%s(%d)跨服切换场景(%s-->%s)",pUser->name,pUser->id,pUser->scene->name,pUser->charbase.mapName);
2460 			//用户不在动态场景，需要保存OLDMAP，
2461 		}

I:\work\source\征途\征途-2\zhengtu\src\libscenesserver\SessionClient.cpp 136 KB CPP 文件 2009/3/31 15:35:22 2018/10/23 19:34:23 2018/10/23 19:34:23 1
2346 			pUser->charbase.mapid = rev->temp_id;
2347 			strncpy(pUser->charbase.mapName,(char *)rev->map_name,MAX_NAMESIZE);
2348 			Zebra::logger->info("%s(%d)跨服切换场景(%s-->%s)",pUser->name,pUser->id,pUser->scene->name,pUser->charbase.mapName);
2349 			pUser->charbase.x = rev->x;
2350 			pUser->charbase.y = rev->y;

I:\work\source\征途\征途-1\zhengtu\征途\server\src\ScenesServer\SessionClient.cpp 132 KB CPP 文件 2006/8/2 12:05:20 2018/10/23 19:35:37 2018/10/23 19:35:37 1
2368 				pUser->charbase.mapid = rev->temp_id;
2369 				strncpy(pUser->charbase.mapName, (char *)rev->map_name, MAX_NAMESIZE);
2370 				Zebra::logger->trace("%s(%d)跨服切换场景(%s-->%s)",pUser->name,pUser->id,pUser->scene->name,pUser->charbase.mapName);
2371 				pUser->charbase.x = rev->x;
2372 				pUser->charbase.y = rev->y;

I:\work\source\最游记\Server\Server\Common\ServerVarInterface.cpp 147 KB CPP 文件 2012/2/27 9:55:45 2012/2/27 9:55:45 2012/2/27 9:55:45 1
1661 void CServerVarInterface::AddStatusByScript(int nStatusID, int nStatusLevel)
1662 {
1663     // Todo 现在已经修改成为跨服的，需要请求到center去同步  
1665 }
1666 void CServerVarInterface::PopNpcList()

I:\work\source\最游记\[src.cool]最游记\Server\Server\Server\Common\ServerVarInterface.cpp 209 KB CPP 文件 2013/6/28 14:00:02 2018/10/23 19:50:04 2018/10/23 19:50:04 1
1824 void CServerVarInterface::AddStatusByScript(int nStatusID, int nStatusLevel)
1825 {
1826     // Todo 现在已经修改成为跨服的，需要请求到center去同步  
1828 }
1829 void CServerVarInterface::PopNpcList()

I:\work\source\征三国\征三国\Server\Common\ServerVarInterface.cpp 174 KB CPP 文件 2014/6/10 15:10:44 2018/10/23 19:46:53 2018/10/23 19:46:53 1
1826 void CServerVarInterface::AddStatusByScript(int nStatusID, int nStatusLevel)
1827 {
1828     // Todo 现在已经修改成为跨服的，需要请求到center去同步  
1830 }
1831 void CServerVarInterface::PopNpcList()

I:\work\source\书剑恩仇录\书剑恩仇录_zccode.com\书剑恩仇录\金\Src\MapServer\Server\Connector\ServerConnectorManager_MapServer.cpp 19 KB CPP 文件 2013/3/3 13:58:08 2018/10/23 13:34:39 2018/10/23 13:34:39 3
250 	if(g_Config.m_MultiGroupConfig.IsSignUpServer())
251 	{
252 		//只要一组服务器连接正常,跨服房间管理器的心跳仍然执行 
253 		//added by Michael 2011-10-26
254 		if (GetGLServerActiveCount() > 0)
654 				{
655 					AddGroupTmp( connID, g_Config.m_MultiGroupConfig.m_GLServerInfo[i].m_WorldID );
657 					//2010-10-9 by rj 跨服线程连接方式不可以直接在连接成功后即发 SSHandShake，
658 					//当未 AddGroup 创建帮会据点数据等时线程切换发来同步据点数据会找不到据点缓存
659 					SSHandShake msg;
686 	if(FALSE == IsGLServerActiveTmp())//处理断线重连
687 	{
688 		//added by Michael 2011-06-23 跨服重连机制
690 		if (FALSE == m_ConnectTimer.IsSetTimer())
691 		{

I:\work\source\书剑恩仇录\[src.cool]书剑恩仇录\Src\MapServer\Server\Connector\ServerConnectorManager_MapServer.cpp 19 KB CPP 文件 2013/3/3 13:58:08 2018/10/23 13:34:19 2018/10/23 13:34:19 3
250 	if(g_Config.m_MultiGroupConfig.IsSignUpServer())
251 	{
252 		//只要一组服务器连接正常,跨服房间管理器的心跳仍然执行 
253 		//added by Michael 2011-10-26
254 		if (GetGLServerActiveCount() > 0)
654 				{
655 					AddGroupTmp( connID, g_Config.m_MultiGroupConfig.m_GLServerInfo[i].m_WorldID );
657 					//2010-10-9 by rj 跨服线程连接方式不可以直接在连接成功后即发 SSHandShake，
658 					//当未 AddGroup 创建帮会据点数据等时线程切换发来同步据点数据会找不到据点缓存
659 					SSHandShake msg;
686 	if(FALSE == IsGLServerActiveTmp())//处理断线重连
687 	{
688 		//added by Michael 2011-06-23 跨服重连机制
690 		if (FALSE == m_ConnectTimer.IsSetTimer())
691 		{

I:\work\source\书剑恩仇录\书剑恩仇录_zccode.com\书剑恩仇录\金\Src\DBShare\DBShare\Run\ServerConnectorManager_DBShare.cpp 12 KB CPP 文件 2013/3/3 13:30:54 2018/10/23 13:33:22 2018/10/23 13:33:22 2
333 				{					
334 					AddGroupTmp( connID, g_Config.m_MultiGroupConfig.m_DBCenterInfo[i].m_WorldID );
336 					//2010-10-9 by rj 跨服线程连接方式不可以直接在连接成功后即发 SSHandShake，
337 					//当未 AddGroup 创建帮会据点数据等时线程切换发来同步据点数据会找不到据点缓存
338 					SSHandShake msg;
365 	if(IsDBCenterServerActiveTmp())
366 		return TRUE;
368 	//added by Michael 2011-06-23 跨服重连机制
370 	uint32 uTime = GET_TIME().TickCount();
372 	if (FALSE == m_ConnectTimer.IsSetTimer())

I:\work\source\书剑恩仇录\[src.cool]书剑恩仇录\Src\DBShare\DBShare\Run\ServerConnectorManager_DBShare.cpp 12 KB CPP 文件 2013/3/3 13:30:54 2018/10/23 13:33:14 2018/10/23 13:33:14 2
333 				{					
334 					AddGroupTmp( connID, g_Config.m_MultiGroupConfig.m_DBCenterInfo[i].m_WorldID );
336 					//2010-10-9 by rj 跨服线程连接方式不可以直接在连接成功后即发 SSHandShake，
337 					//当未 AddGroup 创建帮会据点数据等时线程切换发来同步据点数据会找不到据点缓存
338 					SSHandShake msg;
365 	if(IsDBCenterServerActiveTmp())
366 		return TRUE;
368 	//added by Michael 2011-06-23 跨服重连机制
370 	uint32 uTime = GET_TIME().TickCount();
372 	if (FALSE == m_ConnectTimer.IsSetTimer())

I:\work\source\书剑恩仇录\书剑恩仇录_zccode.com\书剑恩仇录\金\Src\Share\Connector\ServerConnectorManager.cpp 10 KB CPP 文件 2013/3/3 12:49:16 2018/10/23 13:35:56 2018/10/23 13:35:56 1
222 	__UNGUARD__
223 }
225 // 2011-10-27 by Michael 跨服线程连接方式(非阻塞)
226 Connector *ServerConnectorManager::ConnectToServerForGroup(const char* ip,uint16 port,ID_t serverid,ConnectorID_t& connID)
227 {

I:\work\source\书剑恩仇录\[src.cool]书剑恩仇录\Src\Share\Connector\ServerConnectorManager.cpp 10 KB CPP 文件 2013/3/3 12:49:16 2018/10/23 13:35:01 2018/10/23 13:35:01 1
222 	__UNGUARD__
223 }
225 // 2011-10-27 by Michael 跨服线程连接方式(非阻塞)
226 Connector *ServerConnectorManager::ConnectToServerForGroup(const char* ip,uint16 port,ID_t serverid,ConnectorID_t& connID)
227 {

I:\work\source\神魔传奇\[src.cool]神魔传奇代码\Server\ScenesServer\Scene.cpp 90 KB CPP 文件 2012/1/17 23:01:20 2018/10/23 13:18:01 2018/10/23 13:18:01 1
544 * \param deathBackto 是否是死亡回城
545 * \param ignoreWar 忽略跳转中的国战处理部分
546 * \return 0 跳场景失败,1 在本服跳场景,2跨服跳场景
547 */
548 int Scene::changeMap(TSceneUserSharedPtr pUser,bool deathBackto,bool ignoreWar)

I:\work\source\征途\征途-2\zhengtu\src\libscenesserver\Scene.cpp 71 KB CPP 文件 2009/3/27 10:46:32 2018/10/23 19:34:23 2018/10/23 19:34:23 1
447  * \param deathBackto 是否是死亡回城
448  * \param ignoreWar 忽略跳转中的国战处理部分
449  * \return 0 跳场景失败,1 在本服跳场景,2跨服跳场景
450  */
451 int Scene::changeMap(SceneUser *pUser,bool deathBackto,bool ignoreWar)

I:\work\source\征途\征途-1\zhengtu\征途\server\src\ScenesServer\Scene.cpp 61 KB CPP 文件 2006/8/2 11:12:58 2018/10/23 19:35:36 2018/10/23 19:35:36 1
460  * \param deathBackto 是否是死亡回城
461  * \param ignoreWar 忽略跳转中的国战处理部分
462  * \return 0 跳场景失败，1 在本服跳场景， 2跨服跳场景
463  */
464 int Scene::changeMap(SceneUser *pUser , bool deathBackto, bool ignoreWar)

I:\work\source\神仙传\[src.cool]神仙传\GAME\Project1\ZoneClientEditor\Source\Gameplay\Data\RouteRepository.cpp 15 KB CPP 文件 2010/3/22 9:23:20 2018/10/23 13:31:17 2018/10/23 13:31:17 1
324 }
325 #endif
327 //跨服寻径
328 StrideRepository g_StrideRepository;
330 StrideRepository::StrideRepository()

I:\work\source\远征\[src.cool]远征\Xgame2001_source\Common\RegisterGameSPCmdID.cpp 13 KB CPP 文件 2014/2/25 11:36:51 2018/10/23 19:49:34 2018/10/23 19:49:34 10
148 		_regDbSP(GAMEDB_REQUEST_WRITE_BOSSDROP);						// 写BOSS掉落数据
150 		_regDbSP(GAMEDB_REQUEST_ACTORSTRIKERESULTLOG_ADD);				// 竞技结果日志信息到数据库
152 		// 跨服国战
153 		_regDbSP(GAMEDB_REQUEST_WORLDCOUNTRY_WARLOG_READ);				// 查询跨服国战结果信息
154 		_regDbSP(GAMEDB_REQUEST_WORLDCOUNTRY_WARLOG_ADD);				// 添加跨服国战结果信息
156 		// 经脉系统
157 		_regDbSP(GAMEDB_REQUEST_READNERVE);								// 读取经脉穴位数据
181 		_regDbSP(GAMEDB_REQUEST_MAPRECOVER_SAVE);						// 批量保存地图信息  
182 		_regDbSP(GAMEDB_REQUEST_GETCOUNTRYPOWER);						// 取得国家综合国力信息  
183 		// 跨服国战
184 		_regDbSP(GAMEDB_REQUEST_WORLDCOUNTRY_WAR_READ);					// 查询跨服国战信息
185 		_regDbSP(GAMEDB_REQUEST_WORLDCOUNTRY_WAR_ADD);					// 添加跨服国战信息
186 		_regDbSP(GAMEDB_REQUEST_WORLDCOUNTRY_WAR_SAVE);					// 批量保存跨服国战信息
187 		// 跨服国家边境
188 		_regDbSP(GAMEDB_REQUEST_WORLDCOUNTRY_LINK_READ);				// 查询跨服国家边境连通信息
189 		_regDbSP(GAMEDB_REQUEST_WORLDCOUNTRY_LINK_ADD);					// 添加跨服国家边境连通信息
191 		_regDbSP(GAMEDB_REQUEST_CHATSPEAKER_READ);						// 查询喇叭
192 		_regDbSP(GAMEDB_REQUEST_CHATSPEAKER_ADD);						// 添加喇叭

I:\work\source\远征\[src.cool]远征\Xgame2001_build\Common\RegisterGameSPCmdID.cpp 13 KB CPP 文件 2014/2/25 14:54:08 2018/10/23 19:32:39 2018/10/23 19:32:39 10
148 		_regDbSP(GAMEDB_REQUEST_WRITE_BOSSDROP);						// 写BOSS掉落数据
150 		_regDbSP(GAMEDB_REQUEST_ACTORSTRIKERESULTLOG_ADD);				// 竞技结果日志信息到数据库
152 		// 跨服国战
153 		_regDbSP(GAMEDB_REQUEST_WORLDCOUNTRY_WARLOG_READ);				// 查询跨服国战结果信息
154 		_regDbSP(GAMEDB_REQUEST_WORLDCOUNTRY_WARLOG_ADD);				// 添加跨服国战结果信息
156 		// 经脉系统
157 		_regDbSP(GAMEDB_REQUEST_READNERVE);								// 读取经脉穴位数据
181 		_regDbSP(GAMEDB_REQUEST_MAPRECOVER_SAVE);						// 批量保存地图信息  
182 		_regDbSP(GAMEDB_REQUEST_GETCOUNTRYPOWER);						// 取得国家综合国力信息  
183 		// 跨服国战
184 		_regDbSP(GAMEDB_REQUEST_WORLDCOUNTRY_WAR_READ);					// 查询跨服国战信息
185 		_regDbSP(GAMEDB_REQUEST_WORLDCOUNTRY_WAR_ADD);					// 添加跨服国战信息
186 		_regDbSP(GAMEDB_REQUEST_WORLDCOUNTRY_WAR_SAVE);					// 批量保存跨服国战信息
187 		// 跨服国家边境
188 		_regDbSP(GAMEDB_REQUEST_WORLDCOUNTRY_LINK_READ);				// 查询跨服国家边境连通信息
189 		_regDbSP(GAMEDB_REQUEST_WORLDCOUNTRY_LINK_ADD);					// 添加跨服国家边境连通信息
191 		_regDbSP(GAMEDB_REQUEST_CHATSPEAKER_READ);						// 查询喇叭
192 		_regDbSP(GAMEDB_REQUEST_CHATSPEAKER_ADD);						// 添加喇叭

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\ServerManager\ManagerClient\Src\RealTimeDataView.cpp 49 KB CPP 文件 2014/2/25 0:32:17 2018/10/23 20:07:25 2018/10/23 20:07:25 1
95 		{ _T("进程已用虚拟内存"),	false,			false,			true	},
96 		{ _T("在线人数"),			true,			true,			true	},
97 		{ _T("跨服在线人数"),		true,			true,			true	},
98 		{ _T(" "),					false,			false,			true	},	//  无
99 	};

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\ServerManager\ManagerClient\Src\RealTimeDataView.cpp 49 KB CPP 文件 2014/2/25 14:34:36 2018/10/23 19:46:19 2018/10/23 19:46:19 1
95 		{ _T("进程已用虚拟内存"),	false,			false,			true	},
96 		{ _T("在线人数"),			true,			true,			true	},
97 		{ _T("跨服在线人数"),		true,			true,			true	},
98 		{ _T(" "),					false,			false,			true	},	//  无
99 	};

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\ServerManager\Common\RealTimeDataSrc.cpp 12 KB CPP 文件 2014/2/25 0:20:27 2018/10/23 20:07:19 2018/10/23 20:07:19 1
127 		true,		// 进程已用虚拟内存
128 		true,		// 在线人数
129 		true,		// 跨服在线数
130 		false,		// 无
131 	};

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\ServerManager\Common\RealTimeDataSrc.cpp 12 KB CPP 文件 2014/2/25 14:30:23 2018/10/23 19:46:15 2018/10/23 19:46:15 1
127 		true,		// 进程已用虚拟内存
128 		true,		// 在线人数
129 		true,		// 跨服在线数
130 		false,		// 无
131 	};

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\ServerManager\ManagerClient\Src\RealTimeDataDraw.cpp 146 KB CPP 文件 2014/2/25 0:32:15 2018/10/23 20:07:25 2018/10/23 20:07:25 15
57 		{ MG_RTDrawType_None,							0,	"未支持",	"显示未支持文字",			{   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   0 }	},	// 无曲线图,只显示文字
58 		{ MG_RTDrawType_OnlineCountsCurve,				1,	"在线",		"在线数曲线图",				{   0,   1,   1,   1,   0,   0,   0,   0,   1,   0,   0,   0,   0,   0,   0,   1,   1,   0,   0,   0,   0,   0 }	},	// 在线数曲线图
59 		{ MG_RTDrawType_OtherOnlineCountsCurve,			1,	"跨服在线",	"跨服在线数曲线图",			{   0,   0,   0,   0,   0,   0,   0,   0,   1,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 }	},	// 跨服在线曲线图
60 		{ MG_RTDrawType_PhysicalMemoryUsedCurve,		1,	"物存",		"物理内存使用曲线图",		{   0,   1,   1,   1,   0,   0,   0,   1,   1,   0,   0,   0,   0,   0,   0,   1,   1,   0,   0,   1,   0,   0 }	},	// 物理内存使用曲线图
61 		{ MG_RTDrawType_VirtualMemoryUsedCurve,			1,	"虚存",		"虚拟内存使用曲线图",		{   0,   1,   1,   1,   0,   0,   0,   1,   1,   0,   0,   0,   0,   0,   0,   1,   1,   0,   0,   1,   0,   0 }	},	// 虚拟内存使用曲线图
74 		{ MG_RTDrawType_HourKDataCurve,					1,	"小时K线",	"在线小时K线",				{   0,   1,   0,   0,   0,   0,   0,   0,   1,   0,   0,   0,   0,   0,   0,   1,   0,   0,   0,   0,   0,   0 }	},	// 小时K线曲线图
75 		{ MG_RTDrawType_HourKDataFixCurve,				1,	"小时K线",	"在线小时K线72",			{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 }	},	// 小时K线固定宽度曲线图
76 		{ MG_RTDrawType_OtherMinuteKDataCurve,			1,	"跨服分钟",	"跨服在线分钟K线",			{   0,   0,   0,   0,   0,   0,   0,   0,   1,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 }	},	// 跨服分钟K线曲线图
77 		{ MG_RTDrawType_OtherHourKDataCurve,			1,	"跨服小时",	"跨服在线小时K线",			{   0,   0,   0,   0,   0,   0,   0,   0,   1,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 }	},	// 跨服小时K线曲线图
78 	};
80 	// 检查取得实时数据绘图类型配置信息的服务器最大数量，不对就报错
176 		(RTDATADRAW_PROC)&CRealTimeDataDraw::DrawNone,									// 空图
177 		(RTDATADRAW_PROC)&CRealTimeDataDraw::DrawOnlineCountsCurve,						// 在线数曲线图
178 		(RTDATADRAW_PROC)&CRealTimeDataDraw::DrawOnlineCountsCurve,						// 跨服在线数曲线图
179 		(RTDATADRAW_PROC)&CRealTimeDataDraw::DrawPhysicalMemoryUsedCurve,				// 物理内存使用曲线图
180 		(RTDATADRAW_PROC)&CRealTimeDataDraw::DrawVirtualMemoryUsedCurve,				// 虚拟内存使用曲线图
193 		(RTDATADRAW_PROC)&CRealTimeDataDraw::DrawHourKDataCurve,						// 在线小时K线
194 		(RTDATADRAW_PROC)&CRealTimeDataDraw::DrawHourKDataCurve,						// 在线小时K线72
195 		(RTDATADRAW_PROC)&CRealTimeDataDraw::DrawMinuteKDataCurve,						// 跨服在线分钟K线
196 		(RTDATADRAW_PROC)&CRealTimeDataDraw::DrawHourKDataCurve,						// 跨服在线小时K线
197 	};
199 	// 实时数据绘图类型无效或不支持
597 	int nOnlineDataID = -1;	// 所在服务器类型的在线数据ID
598 	
599 	// 是跨服的
600 	if (dwDrawType==MG_RTDrawType_OtherOnlineCountsCurve)
601 	{
3105 	// 所在服务器类型的在线数据ID
3106 	int nOnlineDataID = -1;	// 所在服务器类型的在线数据ID
3108 	// 是跨服的
3109 	if (dwDrawType==MG_RTDrawType_OtherMinuteKDataCurve)
3110 	{
3548 	// 所在服务器类型的在线数据ID
3549 	int nOnlineDataID = -1;	// 所在服务器类型的在线数据ID
3551 	// 是跨服的
3552 	if (dwDrawType==MG_RTDrawType_OtherHourKDataCurve)
3553 	{

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\ServerManager\ManagerClient\Src\RealTimeDataDraw.cpp 146 KB CPP 文件 2014/2/25 14:34:35 2018/10/23 19:46:19 2018/10/23 19:46:19 15
57 		{ MG_RTDrawType_None,							0,	"未支持",	"显示未支持文字",			{   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   0 }	},	// 无曲线图,只显示文字
58 		{ MG_RTDrawType_OnlineCountsCurve,				1,	"在线",		"在线数曲线图",				{   0,   1,   1,   1,   0,   0,   0,   0,   1,   0,   0,   0,   0,   0,   0,   1,   1,   0,   0,   0,   0,   0 }	},	// 在线数曲线图
59 		{ MG_RTDrawType_OtherOnlineCountsCurve,			1,	"跨服在线",	"跨服在线数曲线图",			{   0,   0,   0,   0,   0,   0,   0,   0,   1,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 }	},	// 跨服在线曲线图
60 		{ MG_RTDrawType_PhysicalMemoryUsedCurve,		1,	"物存",		"物理内存使用曲线图",		{   0,   1,   1,   1,   0,   0,   0,   1,   1,   0,   0,   0,   0,   0,   0,   1,   1,   0,   0,   1,   0,   0 }	},	// 物理内存使用曲线图
61 		{ MG_RTDrawType_VirtualMemoryUsedCurve,			1,	"虚存",		"虚拟内存使用曲线图",		{   0,   1,   1,   1,   0,   0,   0,   1,   1,   0,   0,   0,   0,   0,   0,   1,   1,   0,   0,   1,   0,   0 }	},	// 虚拟内存使用曲线图
74 		{ MG_RTDrawType_HourKDataCurve,					1,	"小时K线",	"在线小时K线",				{   0,   1,   0,   0,   0,   0,   0,   0,   1,   0,   0,   0,   0,   0,   0,   1,   0,   0,   0,   0,   0,   0 }	},	// 小时K线曲线图
75 		{ MG_RTDrawType_HourKDataFixCurve,				1,	"小时K线",	"在线小时K线72",			{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 }	},	// 小时K线固定宽度曲线图
76 		{ MG_RTDrawType_OtherMinuteKDataCurve,			1,	"跨服分钟",	"跨服在线分钟K线",			{   0,   0,   0,   0,   0,   0,   0,   0,   1,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 }	},	// 跨服分钟K线曲线图
77 		{ MG_RTDrawType_OtherHourKDataCurve,			1,	"跨服小时",	"跨服在线小时K线",			{   0,   0,   0,   0,   0,   0,   0,   0,   1,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 }	},	// 跨服小时K线曲线图
78 	};
80 	// 检查取得实时数据绘图类型配置信息的服务器最大数量，不对就报错
176 		(RTDATADRAW_PROC)&CRealTimeDataDraw::DrawNone,									// 空图
177 		(RTDATADRAW_PROC)&CRealTimeDataDraw::DrawOnlineCountsCurve,						// 在线数曲线图
178 		(RTDATADRAW_PROC)&CRealTimeDataDraw::DrawOnlineCountsCurve,						// 跨服在线数曲线图
179 		(RTDATADRAW_PROC)&CRealTimeDataDraw::DrawPhysicalMemoryUsedCurve,				// 物理内存使用曲线图
180 		(RTDATADRAW_PROC)&CRealTimeDataDraw::DrawVirtualMemoryUsedCurve,				// 虚拟内存使用曲线图
193 		(RTDATADRAW_PROC)&CRealTimeDataDraw::DrawHourKDataCurve,						// 在线小时K线
194 		(RTDATADRAW_PROC)&CRealTimeDataDraw::DrawHourKDataCurve,						// 在线小时K线72
195 		(RTDATADRAW_PROC)&CRealTimeDataDraw::DrawMinuteKDataCurve,						// 跨服在线分钟K线
196 		(RTDATADRAW_PROC)&CRealTimeDataDraw::DrawHourKDataCurve,						// 跨服在线小时K线
197 	};
199 	// 实时数据绘图类型无效或不支持
597 	int nOnlineDataID = -1;	// 所在服务器类型的在线数据ID
598 	
599 	// 是跨服的
600 	if (dwDrawType==MG_RTDrawType_OtherOnlineCountsCurve)
601 	{
3105 	// 所在服务器类型的在线数据ID
3106 	int nOnlineDataID = -1;	// 所在服务器类型的在线数据ID
3108 	// 是跨服的
3109 	if (dwDrawType==MG_RTDrawType_OtherMinuteKDataCurve)
3110 	{
3548 	// 所在服务器类型的在线数据ID
3549 	int nOnlineDataID = -1;	// 所在服务器类型的在线数据ID
3551 	// 是跨服的
3552 	if (dwDrawType==MG_RTDrawType_OtherHourKDataCurve)
3553 	{

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\ServerManager\ManagerClient\Src\RealTimeDataCheckFun.cpp 38 KB CPP 文件 2014/2/25 0:32:13 2018/10/23 20:07:25 2018/10/23 20:07:25 1
114 		{ MG_CheckFunType_MoreThan,			0,		0,		5,		20,		true,	false,				{  { 0,0 },  { 0,	1073741824	},  { 0,	1273741824	},} },	// 进程已用虚拟内存
115 		{ MG_CheckFunType_LessThanPre,		50,		0,		5,		20,		true,	true,				{  { 0,0 },  { 20,	0			},  { 30,	0			},} },	// 在线人数
116 		{ MG_CheckFunType_LessThanPre,		50,		0,		5,		20,		true,	true,				{  { 0,0 },  { 20,	0			},  { 30,	0			},} },	// 跨服在线人数
117 		{ MG_CheckFunType_None,				0,		0,		0,		0,		true,	false,				{  { 0,0 },  { 0,	0			},  { 0,	0			},} },	// 无
119 	};

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\ServerManager\ManagerClient\Src\RealTimeDataCheckFun.cpp 38 KB CPP 文件 2014/2/25 14:34:34 2018/10/23 19:46:19 2018/10/23 19:46:19 1
114 		{ MG_CheckFunType_MoreThan,			0,		0,		5,		20,		true,	false,				{  { 0,0 },  { 0,	1073741824	},  { 0,	1273741824	},} },	// 进程已用虚拟内存
115 		{ MG_CheckFunType_LessThanPre,		50,		0,		5,		20,		true,	true,				{  { 0,0 },  { 20,	0			},  { 30,	0			},} },	// 在线人数
116 		{ MG_CheckFunType_LessThanPre,		50,		0,		5,		20,		true,	true,				{  { 0,0 },  { 20,	0			},  { 30,	0			},} },	// 跨服在线人数
117 		{ MG_CheckFunType_None,				0,		0,		0,		0,		true,	false,				{  { 0,0 },  { 0,	0			},  { 0,	0			},} },	// 无
119 	};

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MatchServer\PublicWatcher.cpp 28 KB CPP 文件 2014/2/25 0:08:57 2018/10/23 20:06:24 2018/10/23 20:06:24 1
359 	return true;
360 }
363 /** 调用客户端的LUA函数，用于控制显示客户端跨服倒计时
364 @param   bShow：是否显示倒计时面板
365 @param   nRemainSeconds：倒计时（秒）

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MatchServer\PublicWatcher.cpp 28 KB CPP 文件 2014/2/25 14:27:09 2018/10/23 19:45:12 2018/10/23 19:45:12 1
359 	return true;
360 }
363 /** 调用客户端的LUA函数，用于控制显示客户端跨服倒计时
364 @param   bShow：是否显示倒计时面板
365 @param   nRemainSeconds：倒计时（秒）

I:\work\source\神仙传\[src.cool]神仙传\GAME\Project1\ZoneClientEditor\Source\Gameplay\GameObjects\PlayerScript.cpp 32 KB CPP 文件 2010/3/28 23:55:01 2018/10/23 13:31:18 2018/10/23 13:31:18 1
605 }
607 // ----------------------------------------------------------------------------
608 // 取消跨服寻径
609 ConsoleFunction(clearStrideServerPath, void, 1, 1, "clearStrideServerPath()")
610 {

I:\work\source\仙剑神曲\[src.cool]仙剑神曲\src\server\gamesvr\PlayerOnlineReward.cpp 19 KB CPP 文件 2012/4/22 2:05:34 2018/10/23 16:11:13 2018/10/23 16:11:13 1
297         if (nParam == 1)
298         {
299             // 跨服跳地图
300             m_nCurTick = m_pOwner->GetCharacter()->GetCharacterData()->GetOnlineRewardTickCount();
301         }

I:\work\source\最游记\[src.cool]最游记\Server\Server\Server\Common\PlayerMessageHandle.cpp 487 KB CPP 文件 2013/6/28 14:00:24 2018/10/23 19:50:01 2018/10/23 19:50:01 1
916     m_BigDBKey = m_BigDBKey << 32;
917     m_BigDBKey += GetServerID();
919 	// 跨服之后保持原服的双倍经验状态
920 	m_bIsOpenDoubleExp = pDBWorld->runtimeInfo.bIsOpenDoubleExp;
922     // 角色数据初始化

I:\work\source\剑侠情缘3\sword3\Sources\MultiServer\GatewayRobot\Player.cpp 56 KB CPP 文件 2014/3/9 20:39:26 2018/10/19 14:09:42 2018/10/19 14:09:42 1
845 			}
846 				break;
848 			// 跨服务器
849 			case s2c_notifyplayerexchange:
850 			{

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MatchServer\PersonStrikePart.cpp 95 KB CPP 文件 2014/2/25 0:08:56 2018/10/23 20:06:23 2018/10/23 20:06:23 6
174 	m_StrikeInfo.dwStrikeBankMoney	= pDBInfo->dwStrikeBankMoney;				// 银行保存徽章
175 	m_StrikeInfo.nDayPlayCount		= pDBInfo->nDayPlayCount;					// 每天竞技比赛局数
176 	m_StrikeInfo.dwWarScore			= pDBInfo->dwWarScore;						// 跨服国战积分
177 	m_StrikeInfo.dwData1			= pDBInfo->dwData1;
178 	m_StrikeInfo.nGiftCount			= pDBInfo->nGiftCount;						// 国战获得礼包次数
322 	m_StrikeInfo.dwStrikeBankMoney = 	pExport->dwStrikeBankMoney	;				// 银行保存徽章
323 	m_StrikeInfo.nDayPlayCount = 	pExport->nDayPlayCount		;					// 每天竞技比赛局数
324 	m_StrikeInfo.dwWarScore = 	pExport->dwWarScore			;						// 跨服国战积分
325 	m_StrikeInfo.dwData1 = 	pExport->dwData1			;											// 检验国家数据,调试用,现清空,以备后以用
326 	m_StrikeInfo.nGiftCount = 	pExport->nGiftCount			;						// 国战获得礼包次数
558 	pExport->dwStrikeBankMoney	= m_StrikeInfo.dwStrikeBankMoney;				// 银行保存徽章
559 	pExport->nDayPlayCount		= m_StrikeInfo.nDayPlayCount;					// 每天竞技比赛局数
560 	pExport->dwWarScore			= m_StrikeInfo.dwWarScore;						// 跨服国战积分
561 	pExport->dwData1			= 0;											// 检验国家数据,调试用,现清空,以备后以用
562 	pExport->nGiftCount			= m_StrikeInfo.nGiftCount;						// 国战获得礼包次数
603 	// 调式代码
604 	char szBuf[512]={0};
605 	sprintf_s(szBuf, sizeof(szBuf), "CPersonStrikePart::ExportDBContext() 导出数据库属性现场,玩家ID=%d,竞技等级=%d,竞技点数=%d,标识状态=%d,参与竞技总局数=%d,获胜总局数=%d,逃跑总局数=%d,参与竞技总时间长=%d,杀敌总数=%d,死亡总数=%d,竞技积分=%d,竞技徽章=%d,银行徽章=%d,攻击能力=%d, 防御能力=%d,每天竞技比赛局数=%d,跨服国战积分=%d",
606 		m_pMaster->GetNumProp(CREATURE_PROP_PDBID),m_StrikeInfo.dwLevel,m_StrikeInfo.dwPoint,m_StrikeInfo.dwFlag,m_StrikeInfo.dwTotal,m_StrikeInfo.dwWin,m_StrikeInfo.dwRunAway,m_StrikeInfo.dwPlayTime,m_StrikeInfo.dwKill,m_StrikeInfo.dwDead,m_StrikeInfo.dwScore,m_StrikeInfo.dwStrikeMoney,m_StrikeInfo.dwStrikeBankMoney,m_StrikeInfo.nAttackPower,m_StrikeInfo.nDefendPower,m_StrikeInfo.nDayPlayCount,m_StrikeInfo.dwWarScore);
607 	TraceLn(szBuf);
2115 	// 保存竞技场退出回到的地图位置信息
2116 	SaveStrikeBackMapInfo();
2118 	// 是跨服
2119 	if (dwGameWorldID!=0 && dwGameWorldID!=getThisGameWorldID())
2120 	{
3236 	pExport->dwStrikeBankMoney	= m_StrikeInfo.dwStrikeBankMoney;				// 银行保存徽章
3237 	pExport->nDayPlayCount		= m_StrikeInfo.nDayPlayCount;					// 每天竞技比赛局数
3238 	pExport->dwWarScore			= m_StrikeInfo.dwWarScore;						// 跨服国战积分
3239 	pExport->dwData1			= 0;											// 检验国家数据,调试用,现清空,以备后以用
3240 	pExport->nGiftCount			= m_StrikeInfo.nGiftCount;						// 国战获得礼包次数

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MatchServer\PersonStrikePart.cpp 95 KB CPP 文件 2014/2/25 14:27:09 2018/10/23 19:45:12 2018/10/23 19:45:12 6
174 	m_StrikeInfo.dwStrikeBankMoney	= pDBInfo->dwStrikeBankMoney;				// 银行保存徽章
175 	m_StrikeInfo.nDayPlayCount		= pDBInfo->nDayPlayCount;					// 每天竞技比赛局数
176 	m_StrikeInfo.dwWarScore			= pDBInfo->dwWarScore;						// 跨服国战积分
177 	m_StrikeInfo.dwData1			= pDBInfo->dwData1;
178 	m_StrikeInfo.nGiftCount			= pDBInfo->nGiftCount;						// 国战获得礼包次数
322 	m_StrikeInfo.dwStrikeBankMoney = 	pExport->dwStrikeBankMoney	;				// 银行保存徽章
323 	m_StrikeInfo.nDayPlayCount = 	pExport->nDayPlayCount		;					// 每天竞技比赛局数
324 	m_StrikeInfo.dwWarScore = 	pExport->dwWarScore			;						// 跨服国战积分
325 	m_StrikeInfo.dwData1 = 	pExport->dwData1			;											// 检验国家数据,调试用,现清空,以备后以用
326 	m_StrikeInfo.nGiftCount = 	pExport->nGiftCount			;						// 国战获得礼包次数
558 	pExport->dwStrikeBankMoney	= m_StrikeInfo.dwStrikeBankMoney;				// 银行保存徽章
559 	pExport->nDayPlayCount		= m_StrikeInfo.nDayPlayCount;					// 每天竞技比赛局数
560 	pExport->dwWarScore			= m_StrikeInfo.dwWarScore;						// 跨服国战积分
561 	pExport->dwData1			= 0;											// 检验国家数据,调试用,现清空,以备后以用
562 	pExport->nGiftCount			= m_StrikeInfo.nGiftCount;						// 国战获得礼包次数
603 	// 调式代码
604 	char szBuf[512]={0};
605 	sprintf_s(szBuf, sizeof(szBuf), "CPersonStrikePart::ExportDBContext() 导出数据库属性现场,玩家ID=%d,竞技等级=%d,竞技点数=%d,标识状态=%d,参与竞技总局数=%d,获胜总局数=%d,逃跑总局数=%d,参与竞技总时间长=%d,杀敌总数=%d,死亡总数=%d,竞技积分=%d,竞技徽章=%d,银行徽章=%d,攻击能力=%d, 防御能力=%d,每天竞技比赛局数=%d,跨服国战积分=%d",
606 		m_pMaster->GetNumProp(CREATURE_PROP_PDBID),m_StrikeInfo.dwLevel,m_StrikeInfo.dwPoint,m_StrikeInfo.dwFlag,m_StrikeInfo.dwTotal,m_StrikeInfo.dwWin,m_StrikeInfo.dwRunAway,m_StrikeInfo.dwPlayTime,m_StrikeInfo.dwKill,m_StrikeInfo.dwDead,m_StrikeInfo.dwScore,m_StrikeInfo.dwStrikeMoney,m_StrikeInfo.dwStrikeBankMoney,m_StrikeInfo.nAttackPower,m_StrikeInfo.nDefendPower,m_StrikeInfo.nDayPlayCount,m_StrikeInfo.dwWarScore);
607 	TraceLn(szBuf);
2115 	// 保存竞技场退出回到的地图位置信息
2116 	SaveStrikeBackMapInfo();
2118 	// 是跨服
2119 	if (dwGameWorldID!=0 && dwGameWorldID!=getThisGameWorldID())
2120 	{
3236 	pExport->dwStrikeBankMoney	= m_StrikeInfo.dwStrikeBankMoney;				// 银行保存徽章
3237 	pExport->nDayPlayCount		= m_StrikeInfo.nDayPlayCount;					// 每天竞技比赛局数
3238 	pExport->dwWarScore			= m_StrikeInfo.dwWarScore;						// 跨服国战积分
3239 	pExport->dwData1			= 0;											// 检验国家数据,调试用,现清空,以备后以用
3240 	pExport->nGiftCount			= m_StrikeInfo.nGiftCount;						// 国战获得礼包次数

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\EntityServer\PersonBattleRidePart.cpp 224 KB CPP 文件 2014/2/25 0:07:30 2018/10/23 20:04:40 2018/10/23 20:04:40 2
7335 				int nFightMapID = g_ExternalFacade.GetCountryWarMapID(m_pMaster);
7336 				int nMengguoMapID = g_ExternalFacade.GetMengguoCountryWarMapID(m_pMaster);
7338 				// 508是跨服国战地图
7339 				if (nOldMapID == nFightMapID || nOldMapID == nMengguoMapID || nOldMapID == 508)
7340 				{
7370 				int nFightMapID = g_ExternalFacade.GetCountryWarMapID(m_pMaster);
7371 				int nMengguoMapID = g_ExternalFacade.GetMengguoCountryWarMapID(m_pMaster);
7373 				// 508是跨服国战地图
7374 				if (nNewMapID == nFightMapID || nNewMapID == nMengguoMapID || nNewMapID == 508)
7375 				{

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\EntityServer\PersonBattleRidePart.cpp 224 KB CPP 文件 2014/2/25 14:25:09 2018/10/23 19:43:51 2018/10/23 19:43:51 2
7335 				int nFightMapID = g_ExternalFacade.GetCountryWarMapID(m_pMaster);
7336 				int nMengguoMapID = g_ExternalFacade.GetMengguoCountryWarMapID(m_pMaster);
7338 				// 508是跨服国战地图
7339 				if (nOldMapID == nFightMapID || nOldMapID == nMengguoMapID || nOldMapID == 508)
7340 				{
7370 				int nFightMapID = g_ExternalFacade.GetCountryWarMapID(m_pMaster);
7371 				int nMengguoMapID = g_ExternalFacade.GetMengguoCountryWarMapID(m_pMaster);
7373 				// 508是跨服国战地图
7374 				if (nNewMapID == nFightMapID || nNewMapID == nMengguoMapID || nNewMapID == 508)
7375 				{

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\SocialServer\PanelControl.cpp 26 KB CPP 文件 2014/2/25 0:24:02 2018/10/23 20:09:11 2018/10/23 20:09:11 3
537 	}
539 	size_t count = pUserManager->getUserCount();
541 	// 跨服在线角色个数
542 	DWORD dwOtherWorldUserCounts =  pMatchService->GetOtherWorldUserCounts();
542 	DWORD dwOtherWorldUserCounts =  pMatchService->GetOtherWorldUserCounts();
544 	EmphasisLn("在线人数："<<count<<"，跨服在线："<<dwOtherWorldUserCounts);
548 	// 输出撮合信息到文件
550 	std::string workdir = getWorkDir();
552 	ErrorLn("输出撮合列表信息到文件："<<strSaveLogFile.c_str());
554 	pMatchService->SaveMatchTotalInfoToFile(strSaveLogFile.c_str());
556 	// 取得跨服竞技撮合系统接口
557 	IStrikeMatch* pStrikeMatch = pMatchService->GetStrikeMatch();
558 	if (NULL==pStrikeMatch)

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\SocialServer\PanelControl.cpp 26 KB CPP 文件 2014/2/25 14:32:03 2018/10/23 19:46:49 2018/10/23 19:46:49 3
537 	}
539 	size_t count = pUserManager->getUserCount();
541 	// 跨服在线角色个数
542 	DWORD dwOtherWorldUserCounts =  pMatchService->GetOtherWorldUserCounts();
542 	DWORD dwOtherWorldUserCounts =  pMatchService->GetOtherWorldUserCounts();
544 	EmphasisLn("在线人数："<<count<<"，跨服在线："<<dwOtherWorldUserCounts);
548 	// 输出撮合信息到文件
550 	std::string workdir = getWorkDir();
552 	ErrorLn("输出撮合列表信息到文件："<<strSaveLogFile.c_str());
554 	pMatchService->SaveMatchTotalInfoToFile(strSaveLogFile.c_str());
556 	// 取得跨服竞技撮合系统接口
557 	IStrikeMatch* pStrikeMatch = pMatchService->GetStrikeMatch();
558 	if (NULL==pStrikeMatch)

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\StarTrekServer\OutDirHandler.cpp 26 KB CPP 文件 2014/2/25 0:11:06 2018/10/23 20:06:52 2018/10/23 20:06:52 1
659 		if(pMsgConsult->nConsultResult != tStarTrek_Result_Succeed)
660 		{
661 			WarningLn("Tick="<<GetTickCount()<<" 对方拒绝跨服传送 pdbid="<<pMsgConsult->PDBID<<" udbid="<<pMsgConsult->UDBID<<" 原因="<<pMsgConsult->nConsultResult);
662 			pOutObject->RegressPlayState(tReleaseTreak_Reason_ConsultRefuse, pMsgConsult->nConsultResult);
663 			return;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\StarTrekServer\OutDirHandler.cpp 26 KB CPP 文件 2014/2/25 14:28:36 2018/10/23 19:45:41 2018/10/23 19:45:41 1
659 		if(pMsgConsult->nConsultResult != tStarTrek_Result_Succeed)
660 		{
661 			WarningLn("Tick="<<GetTickCount()<<" 对方拒绝跨服传送 pdbid="<<pMsgConsult->PDBID<<" udbid="<<pMsgConsult->UDBID<<" 原因="<<pMsgConsult->nConsultResult);
662 			pOutObject->RegressPlayState(tReleaseTreak_Reason_ConsultRefuse, pMsgConsult->nConsultResult);
663 			return;

I:\work\source\蜀山神话\[src.cool]蜀山神话\src\server\gamesvr\society\OrganizeManager.cpp 82 KB CPP 文件 2012/4/21 1:05:07 2018/10/23 13:25:13 2018/10/23 13:25:13 1
2004 	gameapi::SendPacketToNpcSvr(pPlayer->GetSectorId(), notify);
2005 }
2007 //处理跨服观察请求
2008 void OrganizeManager::HandleObserverOtherGameRequest(FiMessage* pMsg)
2009 {

I:\work\source\蜀山神话\[src.cool]蜀山神话\src\server\npcserver\ObjectPxManager.cpp 58 KB CPP 文件 2012/4/21 1:05:18 2018/10/23 13:25:17 2018/10/23 13:25:17 1
2309     m_statuaryUpdateMap[iSector].set(eRankType - RQT_SUN_STRENGTH, isUpdate);
2310 }
2312 //请求跨服刷怪
2313 void ObjectPxManager::HandleRequestSpawnNpcToAppointSector(FiMessage* pMsg)
2314 {

I:\work\source\蜀山神话\[src.cool]蜀山神话\src\server\gamesvr\ObjectManager.cpp 86 KB CPP 文件 2012/4/21 1:05:17 2018/10/23 13:25:11 2018/10/23 13:25:11 1
2401 	m_pGameServer->GetInviteManager()->TerminateInviation(pPlayer
2402 		, INV_OFFLINE);
2404     ///玩家切地图(离开本服务器)处理(跨服跳地图)
2405     if(!IsLoadedMap(sector))
2406     {

I:\work\source\仙剑神曲\[src.cool]仙剑神曲\src\server\gamesvr\NobleManager.cpp 23 KB CPP 文件 2012/4/22 2:05:34 2018/10/23 16:11:10 2018/10/23 16:11:10 1
328 {
329     CHECK_NULL(pPlayer);
331     // 跨服同步, 金子兑换(升级), 登录(降级)
333     ZuCharacterData* pCharData = pPlayer->GetCharacter()->GetCharacterData();
335     // 角色名门总经验

I:\work\source\剑侠情缘3\sword3\Sources\S3Client\NetConnect\NetConnectAgent.cpp 12 KB CPP 文件 2014/3/9 20:39:49 2018/10/19 14:09:44 2018/10/19 14:09:44 2
314 			{
315 				PROTOCOL_MSG_TYPE	Msg = *pMsg;			
318 				// 跨服务器的协议
319 				if (Msg == s2c_notifyplayerexchange)
320 				{
420 	else
421 	{
422 		// 跨服务器失败
423 //		MessageBox(NULL, "", "", MB_OK);
425 #define	MSG_EXCHANGE_FAIL	"前方路途不太通畅，还是过会再来吧。"

I:\work\source\书剑恩仇录\书剑恩仇录_zccode.com\书剑恩仇录\金\Src\GLServer\GL\GLData\MutiGroupMapServerManager.cpp 16 KB CPP 文件 2013/3/3 13:56:50 2018/10/23 13:34:37 2018/10/23 13:34:37 1
4 Author:Michael		
5 Created:Michael
6 Description :跨服MapServer管理器实现
7 Revision :  2011/06/17 Michael create
9 =============================================================================*/

I:\work\source\书剑恩仇录\[src.cool]书剑恩仇录\Src\GLServer\GL\GLData\MutiGroupMapServerManager.cpp 16 KB CPP 文件 2013/3/3 13:56:50 2018/10/23 13:34:15 2018/10/23 13:34:15 1
4 Author:Michael		
5 Created:Michael
6 Description :跨服MapServer管理器实现
7 Revision :  2011/06/17 Michael create
9 =============================================================================*/

I:\work\source\最游记\[src.cool]最游记\Server\Server\Server\Common\MultiTeamStage.cpp 15 KB CPP 文件 2013/6/28 14:00:00 2018/10/23 19:49:53 2018/10/23 19:49:53 2
43     if ( EctypeStage::CheckNeedKickOutPlayer( pPlayer ) )
44     { return true; }
46     //// 没有队伍了 TODO: 因跨服战场是多队伍副本，但是却不用组队，所以此处先注释掉
47     //if ( !pPlayer->HaveTeam() )
48     //{ return true; }
75 }
77 //////////////////////////////////////////////////////////////////////////
78 // 以下是跨服战场的逻辑函数，暂时保留
80 void MultiTeamStage::CheckLevel(GamePlayer* pkPlayer)
81 {

I:\work\source\书剑恩仇录\书剑恩仇录_zccode.com\书剑恩仇录\金\Src\MapServer\Server\Object\Monster.cpp 64 KB CPP 文件 2013/3/3 14:00:22 2018/10/23 13:34:42 2018/10/23 13:34:42 6
1317 		return 0;
1318 	}
1320 	//如果是跨服副本
1321 	if (pMap->GetMapType() == MAP_TYPE_FUBEN && pMap->m_FubenDataParty.IsRoomType())
1322 	{
1405 		return 0;
1406 	}
1408 	//场景类型必须为跨服副本
1409 	Map* pMap = GetMap();
1410 	if (NULL == pMap)
1791 		return;
1792 	}
1794 	//跨服副本
1795 	if (pMap->GetMapType() == MAP_TYPE_FUBEN && pMap->m_FubenDataParty.IsRoomType())
1796 	{
1825 		return;
1826 	}
1828 	//跨服副本
1829 	Player* apValidMember[MAX_GROUP_MEMBER];
1830 	uint32 nValidMemberCount = 0;
2031 		nExp = (int32) (m_BaseExp * g_Config.m_ConfigInfo.m_ExpParam);
2032 	}
2034 	uint32	auExp[MAX_GROUP_MEMBER];//modify by Michael Lin 2011-07-26 for 跨服军团
2035 	int32	i;
2037 	CaculateMonsterExpRuler::eEXP_CALC_TYPE eCalcType 
2046 			if (pMap->m_FubenDataParty.IsRoomType())
2047 			{
2048 				eCalcType = CaculateMonsterExpRuler::eCALC_TYPE_GROUP; //按跨服军团分配
2049 			}
2050 		}

I:\work\source\书剑恩仇录\[src.cool]书剑恩仇录\Src\MapServer\Server\Object\Monster.cpp 64 KB CPP 文件 2013/3/3 14:00:22 2018/10/23 13:34:25 2018/10/23 13:34:25 6
1317 		return 0;
1318 	}
1320 	//如果是跨服副本
1321 	if (pMap->GetMapType() == MAP_TYPE_FUBEN && pMap->m_FubenDataParty.IsRoomType())
1322 	{
1405 		return 0;
1406 	}
1408 	//场景类型必须为跨服副本
1409 	Map* pMap = GetMap();
1410 	if (NULL == pMap)
1791 		return;
1792 	}
1794 	//跨服副本
1795 	if (pMap->GetMapType() == MAP_TYPE_FUBEN && pMap->m_FubenDataParty.IsRoomType())
1796 	{
1825 		return;
1826 	}
1828 	//跨服副本
1829 	Player* apValidMember[MAX_GROUP_MEMBER];
1830 	uint32 nValidMemberCount = 0;
2031 		nExp = (int32) (m_BaseExp * g_Config.m_ConfigInfo.m_ExpParam);
2032 	}
2034 	uint32	auExp[MAX_GROUP_MEMBER];//modify by Michael Lin 2011-07-26 for 跨服军团
2035 	int32	i;
2037 	CaculateMonsterExpRuler::eEXP_CALC_TYPE eCalcType 
2046 			if (pMap->m_FubenDataParty.IsRoomType())
2047 			{
2048 				eCalcType = CaculateMonsterExpRuler::eCALC_TYPE_GROUP; //按跨服军团分配
2049 			}
2050 		}

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\MatchService\MatrixService.cpp 116 KB CPP 文件 2014/2/25 0:23:09 2018/10/23 20:09:04 2018/10/23 20:09:04 4
2654 void CMatrixService::ReadMatrixMemberDummyData(void)
2655 {
2656 	// 取得跨服组队撮合系统服务
2657 	IMatchService *pMathcService = gGlobalSocialServer->GetMatchService();
2658 	if (pMathcService == NULL)
2699 bool CMatrixService::GetMemberDummyDataReadFinish(void)
2700 {
2701 	// 取得跨服组队撮合系统服务
2702 	IMatchService *pMathcService = gGlobalSocialServer->GetMatchService();
2703 	if (pMathcService == NULL)
2727 void CMatrixService::SetMatrixMemberInfoInDummyData(void)
2728 {
2729 	// 取得跨服组队撮合系统服务
2730 	IMatchService *pMathcService = gGlobalSocialServer->GetMatchService();
2731 	if (pMathcService == NULL)
2790 void CMatrixService::UpdateAllDummyMemberData(DWORD dwServerID)
2791 {
2792 	// 取得跨服组队撮合系统服务
2793 	IMatchService *pMathcService = gGlobalSocialServer->GetMatchService();
2794 	if (pMathcService == NULL)

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\MatchService\MatrixService.cpp 116 KB CPP 文件 2014/2/25 14:31:41 2018/10/23 19:46:42 2018/10/23 19:46:42 4
2654 void CMatrixService::ReadMatrixMemberDummyData(void)
2655 {
2656 	// 取得跨服组队撮合系统服务
2657 	IMatchService *pMathcService = gGlobalSocialServer->GetMatchService();
2658 	if (pMathcService == NULL)
2699 bool CMatrixService::GetMemberDummyDataReadFinish(void)
2700 {
2701 	// 取得跨服组队撮合系统服务
2702 	IMatchService *pMathcService = gGlobalSocialServer->GetMatchService();
2703 	if (pMathcService == NULL)
2727 void CMatrixService::SetMatrixMemberInfoInDummyData(void)
2728 {
2729 	// 取得跨服组队撮合系统服务
2730 	IMatchService *pMathcService = gGlobalSocialServer->GetMatchService();
2731 	if (pMathcService == NULL)
2790 void CMatrixService::UpdateAllDummyMemberData(DWORD dwServerID)
2791 {
2792 	// 取得跨服组队撮合系统服务
2793 	IMatchService *pMathcService = gGlobalSocialServer->GetMatchService();
2794 	if (pMathcService == NULL)

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MatchServer\MatrixEctype.cpp 81 KB CPP 文件 2014/2/25 0:08:53 2018/10/23 20:06:23 2018/10/23 20:06:23 10
252 	// 设置副本开始状态
253 	nEctypeState = emMatrix_Begin;
255 	// 取得跨服组队撮合服务器
256 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
257 	if (pMatchServer == NULL)
486 		return;
487 	}
489 	// 取得跨服组队撮合服务器
490 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
491 	if (pMatchServer == NULL)
600 		return 0;
601 	}
603 	// 取得跨服组队撮合服务器
604 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
605 	if (pMatchServer == NULL)
977 		return;
978 	}
979 	// 取得跨服组队撮合服务器
980 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
981 	if (pMatchServer == NULL)
1086 		return;
1087 	}
1089 	// 取得跨服组队撮合服务器
1090 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
1091 	if (pMatchServer == NULL)
1576 	else
1577 	{
1578 		// 取得跨服组队撮合服务器
1579 		IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
1580 		if (pMatchServer == NULL)
1950 		return false;
1951 	}
1953 	// 取得跨服组队撮合服务器
1954 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
1955 	if (pMatchServer == NULL)
2428 		return;
2429 	}
2431 	// 取得跨服组队撮合服务器
2432 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
2433 	if (pMatchServer == NULL)
2660 		return;
2661 	}
2663 	// 取得跨服组队撮合服务器
2664 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
2665 	if (pMatchServer == NULL)
2866 		return 0;
2867 	}
2869 	// 取得跨服组队撮合服务器
2870 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
2871 	if (pMatchServer == NULL)

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MatchServer\MatrixEctype.cpp 81 KB CPP 文件 2014/2/25 14:27:06 2018/10/23 19:45:12 2018/10/23 19:45:12 10
252 	// 设置副本开始状态
253 	nEctypeState = emMatrix_Begin;
255 	// 取得跨服组队撮合服务器
256 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
257 	if (pMatchServer == NULL)
486 		return;
487 	}
489 	// 取得跨服组队撮合服务器
490 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
491 	if (pMatchServer == NULL)
600 		return 0;
601 	}
603 	// 取得跨服组队撮合服务器
604 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
605 	if (pMatchServer == NULL)
977 		return;
978 	}
979 	// 取得跨服组队撮合服务器
980 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
981 	if (pMatchServer == NULL)
1086 		return;
1087 	}
1089 	// 取得跨服组队撮合服务器
1090 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
1091 	if (pMatchServer == NULL)
1576 	else
1577 	{
1578 		// 取得跨服组队撮合服务器
1579 		IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
1580 		if (pMatchServer == NULL)
1950 		return false;
1951 	}
1953 	// 取得跨服组队撮合服务器
1954 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
1955 	if (pMatchServer == NULL)
2428 		return;
2429 	}
2431 	// 取得跨服组队撮合服务器
2432 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
2433 	if (pMatchServer == NULL)
2660 		return;
2661 	}
2663 	// 取得跨服组队撮合服务器
2664 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
2665 	if (pMatchServer == NULL)
2866 		return 0;
2867 	}
2869 	// 取得跨服组队撮合服务器
2870 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
2871 	if (pMatchServer == NULL)

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\MatchService\Matrix.cpp 11 KB CPP 文件 2014/2/25 0:23:07 2018/10/23 20:09:04 2018/10/23 20:09:04 3
79 		m_Info.sHeadInfo.nID = emMatrixID_first;
80 	}
82 	// 跨服组队撮合系统服务接口定义
83 	IMatchService *pMatchService = gGlobalSocialServer->GetMatchService();
84 	if (pMatchService == NULL)
200 void CMatrix::CheckMatrix(void)
201 {
202 	// 跨服组队撮合系统服务接口定义
203 	IMatchService *pMatchService = gGlobalSocialServer->GetMatchService();
204 	if (pMatchService == NULL)
327 	// 压入数据
328 	buf.push_back(&data.byMinorInfo, nLen);
330 	// 跨服组队撮合系统服务接口定义
331 	IMatchService *pMatchService = gGlobalSocialServer->GetMatchService();
332 	if (pMatchService == NULL)

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\MatchService\Matrix.cpp 11 KB CPP 文件 2014/2/25 14:31:40 2018/10/23 19:46:42 2018/10/23 19:46:42 3
79 		m_Info.sHeadInfo.nID = emMatrixID_first;
80 	}
82 	// 跨服组队撮合系统服务接口定义
83 	IMatchService *pMatchService = gGlobalSocialServer->GetMatchService();
84 	if (pMatchService == NULL)
200 void CMatrix::CheckMatrix(void)
201 {
202 	// 跨服组队撮合系统服务接口定义
203 	IMatchService *pMatchService = gGlobalSocialServer->GetMatchService();
204 	if (pMatchService == NULL)
327 	// 压入数据
328 	buf.push_back(&data.byMinorInfo, nLen);
330 	// 跨服组队撮合系统服务接口定义
331 	IMatchService *pMatchService = gGlobalSocialServer->GetMatchService();
332 	if (pMatchService == NULL)

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\MatchService\MatchService.cpp 284 KB CPP 文件 2014/2/25 0:23:04 2018/10/23 20:09:04 2018/10/23 20:09:04 34
5 ** 日  期:	2008/12/9 16:59
6 ** 版  本:	1.0
7 ** 描  述:	跨服组队撮合系统服务
8 ** 应  用:  	
9 	
149 ///////////////////////////IMatchService///////////////////////////////////////////////
151 /**
152 @name  : 建立跨服组队撮合系统服务
153 */
154 bool CMatchService::Create()
182 		return false;
183 	}
185 	// 创建跨服竞技撮合系统
186 	if (m_StrikeMatch.Create() == false)
187 	{
319 	// 关闭跨区竞技系统
320 	m_StrikeService.Release();
321 	// 关闭跨服竞技撮合系统
322 	m_StrikeMatch.Release();
323 	// 关闭跨区副本保姆
455 			schemaInfo.nLevelRange		=  pCSVReader->GetInt(i, 3, 0);			// 上下浮动等级 组队时成员间的等级浮动范围 为0表示所有等级
456 			schemaInfo.nStrikeID		=  pCSVReader->GetInt(i, 4, 0);			// 竞技场类型ID Strike.csv nID 
457 			schemaInfo.nType			=  pCSVReader->GetInt(i, 5, 0);			// 跨服类型  1.跨服类型 2.本服类型
458 			schemaInfo.nMinNum			=  pCSVReader->GetInt(i, 6, 0);			// 撮合最少人数 主要是为了玩家在提交竞技请求时，撮合系统满足这个数值后，将组合好的玩家一次性提交到场景服中开场地竞技用
459 			schemaInfo.nFlag			=  pCSVReader->GetInt(i, 7, 0);			// 控制标识 
2507 	return szNameList[dwConfigNameType];
2508 }
2510 // 本区是否能开跨服国战
2511 bool CMatchService::IsCanOpenWorldWar()
2512 {
2687 	return &m_EctypeAssist;	
2688 }
2690 /** 取得跨服竞技撮合系统接口
2691 */
2692 IStrikeMatch* CMatchService::GetStrikeMatch()
2727 	return m_EctypeAssist;	
2728 }
2729 // 取得跨服竞技撮合系统
2730 CStrikeMatch& CMatchService::GetStrikeMatchInstance()
2731 {
2768 		return;
2769 	}
2771 	// 登录玩家取得跨服国战
2772 	m_WarService.OnUserLogin(info,nMode);
2774 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
3347 	default:
3348 		{
3349 			ErrorLn("跨服组队撮合系统服务器尚有一个投票事件订阅了但未处理，wEventID = "<<wEventID);
3350 		}
3351 		break;
3448 				break;
3449 			}
3451 			// 处理公共区或本区社会服当机,跨服在线列表没同步问题
3452 			// 服务器连入时要把自已在线列表发给对方,并要清除对方游戏区的跨服在线列表
3454 			DWORD dwSendInfWorldID = 0;	// 要更新在线所在的游戏区ID
3455 			// 公共区就指定发那个区的列表
3457 			{
3458 				dwSendInfWorldID = pData->dwWorldID;
3460 				// 删除关了的区所有跨服在线列表
3461 				for (TMAP_WorldOnlineUserList::iterator iter = m_mapWorldOnlineUserList.begin();iter!=m_mapWorldOnlineUserList.end();)
3462 				{
3540 			if (isPublicGameWorld())
3541 			{
3542 				// 删除关了的区所有跨服在线列表
3543 				for (TMAP_WorldOnlineUserList::iterator iter = m_mapWorldOnlineUserList.begin();iter!=m_mapWorldOnlineUserList.end();)
3544 				{
3620 	default:
3621 		{
3622 			ErrorLn("跨服组队撮合系统有一个桥服务器发过来的消息未处理，actionId = "<< actionId);
3623 		}
3624 		break;
3680 	default:
3681 		{
3682 			ErrorLn("跨服组队撮合系统有一个场景服消息未处理，actionId = "<< actionId);
3683 		}
3684 		break;
3845 						else if (dwFlag==2)
3846 						{
3847 							sprintf_s(szMsgBuf, sizeof(szMsgBuf), "队长[%s]当前状态不能带整个队伍跨服组队下副本！",pUserInfo->name);
3848 						}
3849 						else
3881 					else if (dwFlag==2)
3882 					{
3883 						sprintf_s(szMsgBuf, sizeof(szMsgBuf), "[%s]当前状态不能跨服组队下副本！",pUserInfo->name);
3884 					}
3885 					else
3929 	default:
3930 		{
3931 			ErrorLn("跨服组队撮合系统有一个服务器撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
3932 		}
3933 		break;
3935 }
3937 //////////////////////////////////////////////////////////////////////////
3938 // 跨服 服务器撮合信息子消息
3939 void CMatchService::OnBridgeMsgMatchSubMsg(unsigned long actionId, SMsgBridgeHead &bridgeHead, SGameMsgHead* head, LPSTR data, size_t len)
3940 {
3951 	// 调式代码
3952 	char szBuf[512]={0};
3953 	sprintf_s(szBuf, _countof(szBuf),_NGT"CMatchService::OnBridgeMsgMatchSubMsg()  跨服 服务器撮合信息子消息:来源游戏世界ID=%d,来源服务器ID=%d,子消息代码=%d,len=%d,用户数据=%d,%d,%d",
3954 		bridgeHead.dwWorldID,bridgeHead.dwServerID,pMsg->dwMsgCode,len,pMsg->dwUserData1,pMsg->dwUserData2,pMsg->dwUserData3);
3955 	TraceLn(szBuf);
4146 	default:
4147 		{
4148 			ErrorLn("跨服组队撮合系统有一个跨服撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
4149 		}
4150 		break;
4151 	}	
4152 }
4155 // 跨服 跨区中转消息
4156 void CMatchService::OnBridgeMsgMatchBridgeData(unsigned long actionId, SMsgBridgeHead &bridgeHead, SGameMsgHead* head, LPSTR data, size_t len)
4157 {
4167 	// 调式代码
4168 	char szBuf[512]={0};
4169 	sprintf_s(szBuf, _countof(szBuf),_NGT"CMatchService::OnBridgeMsgMatchBridgeData()  跨服  跨区中转消息:目标端点码=%d,角色来自游戏世界ID=%d,角色ID=%d,行为消息码=%d,数据长度=%d",
4170 		pMsg->nDestEndPoint,pMsg->dwFromWorldID,pMsg->dwActorID,pMsg->wKeyAction,pMsg->nDataLens);
4171 	TraceLn(szBuf);
4257 		return;
4258 	}
4259 	// 跨服在线玩家列表,以玩家角色ID为关键字
4260 	SWorldOnlineUserInfo addNode;
4261 	addNode.dwPDBID		= dwActorID;
4264 	m_mapWorldOnlineUserList[dwActorID] = addNode;
4266 	// 触发事件
4267 	// 社会服  跨服玩家上线事件
4268 	SEventMatchAddUser_O eventSendData;
4269 	eventSendData.dwWorldID	= dwWorldID;				// 玩家来自游戏世界ID
4292 	m_mapWorldOnlineUserList.erase(dwActorID);
4294 	// 触发事件
4295 	// 社会服  跨服玩家下线事件
4296 	SEventMatchRemoveUser_O eventSendData;
4297 	eventSendData.dwWorldID	= dwWorldID;				// 玩家来自游戏世界ID
5640 //	g_ExternalFacade.WriteData2File((BYTE*)strLog.c_str(),strLog.size(),szFileName);
5642 }
5645 /** 设定指定游戏世界ID是否开启跨服国战
5646 @param   DWORD dwWorldID	: 游戏世界ID
5647 @param   bool bClose		: 是否关闭
5659 	}
5660 }
5663 /** 指定游戏世界ID是否开启跨服国战
5664 @param   DWORD dwWorldID	: 游戏世界ID
5665 @return bool 是否关闭
5760 	return nRateRet;
5761 }
5764 /** 取得跨服在线角色信息
5765 @param   DWORD dwPDBID	: 角色ID
5766 @return SWorldOnlineUserInfo 在线角色信息
5772 		return NULL;
5773 	}
5774 	// 跨服在线玩家列表,以玩家角色ID为关键字
5775 	TMAP_WorldOnlineUserList::iterator iter = m_mapWorldOnlineUserList.find(dwPDBID);
5776 	if (iter==m_mapWorldOnlineUserList.end())
5780 	return &(iter->second);
5781 }
5783 /** 取得跨服在线角色个数
5784 @param  
5785 @return   DWORD : 在线角色个数

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\MatchService\MatchService.cpp 284 KB CPP 文件 2014/2/25 14:31:40 2018/10/23 19:46:42 2018/10/23 19:46:42 34
5 ** 日  期:	2008/12/9 16:59
6 ** 版  本:	1.0
7 ** 描  述:	跨服组队撮合系统服务
8 ** 应  用:  	
9 	
149 ///////////////////////////IMatchService///////////////////////////////////////////////
151 /**
152 @name  : 建立跨服组队撮合系统服务
153 */
154 bool CMatchService::Create()
182 		return false;
183 	}
185 	// 创建跨服竞技撮合系统
186 	if (m_StrikeMatch.Create() == false)
187 	{
319 	// 关闭跨区竞技系统
320 	m_StrikeService.Release();
321 	// 关闭跨服竞技撮合系统
322 	m_StrikeMatch.Release();
323 	// 关闭跨区副本保姆
455 			schemaInfo.nLevelRange		=  pCSVReader->GetInt(i, 3, 0);			// 上下浮动等级 组队时成员间的等级浮动范围 为0表示所有等级
456 			schemaInfo.nStrikeID		=  pCSVReader->GetInt(i, 4, 0);			// 竞技场类型ID Strike.csv nID 
457 			schemaInfo.nType			=  pCSVReader->GetInt(i, 5, 0);			// 跨服类型  1.跨服类型 2.本服类型
458 			schemaInfo.nMinNum			=  pCSVReader->GetInt(i, 6, 0);			// 撮合最少人数 主要是为了玩家在提交竞技请求时，撮合系统满足这个数值后，将组合好的玩家一次性提交到场景服中开场地竞技用
459 			schemaInfo.nFlag			=  pCSVReader->GetInt(i, 7, 0);			// 控制标识 
2507 	return szNameList[dwConfigNameType];
2508 }
2510 // 本区是否能开跨服国战
2511 bool CMatchService::IsCanOpenWorldWar()
2512 {
2687 	return &m_EctypeAssist;	
2688 }
2690 /** 取得跨服竞技撮合系统接口
2691 */
2692 IStrikeMatch* CMatchService::GetStrikeMatch()
2727 	return m_EctypeAssist;	
2728 }
2729 // 取得跨服竞技撮合系统
2730 CStrikeMatch& CMatchService::GetStrikeMatchInstance()
2731 {
2768 		return;
2769 	}
2771 	// 登录玩家取得跨服国战
2772 	m_WarService.OnUserLogin(info,nMode);
2774 	IBridgeConnector* pBridgeConnector = GetGlobalBridgeConnector();
3347 	default:
3348 		{
3349 			ErrorLn("跨服组队撮合系统服务器尚有一个投票事件订阅了但未处理，wEventID = "<<wEventID);
3350 		}
3351 		break;
3448 				break;
3449 			}
3451 			// 处理公共区或本区社会服当机,跨服在线列表没同步问题
3452 			// 服务器连入时要把自已在线列表发给对方,并要清除对方游戏区的跨服在线列表
3454 			DWORD dwSendInfWorldID = 0;	// 要更新在线所在的游戏区ID
3455 			// 公共区就指定发那个区的列表
3457 			{
3458 				dwSendInfWorldID = pData->dwWorldID;
3460 				// 删除关了的区所有跨服在线列表
3461 				for (TMAP_WorldOnlineUserList::iterator iter = m_mapWorldOnlineUserList.begin();iter!=m_mapWorldOnlineUserList.end();)
3462 				{
3540 			if (isPublicGameWorld())
3541 			{
3542 				// 删除关了的区所有跨服在线列表
3543 				for (TMAP_WorldOnlineUserList::iterator iter = m_mapWorldOnlineUserList.begin();iter!=m_mapWorldOnlineUserList.end();)
3544 				{
3620 	default:
3621 		{
3622 			ErrorLn("跨服组队撮合系统有一个桥服务器发过来的消息未处理，actionId = "<< actionId);
3623 		}
3624 		break;
3680 	default:
3681 		{
3682 			ErrorLn("跨服组队撮合系统有一个场景服消息未处理，actionId = "<< actionId);
3683 		}
3684 		break;
3845 						else if (dwFlag==2)
3846 						{
3847 							sprintf_s(szMsgBuf, sizeof(szMsgBuf), "队长[%s]当前状态不能带整个队伍跨服组队下副本！",pUserInfo->name);
3848 						}
3849 						else
3881 					else if (dwFlag==2)
3882 					{
3883 						sprintf_s(szMsgBuf, sizeof(szMsgBuf), "[%s]当前状态不能跨服组队下副本！",pUserInfo->name);
3884 					}
3885 					else
3929 	default:
3930 		{
3931 			ErrorLn("跨服组队撮合系统有一个服务器撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
3932 		}
3933 		break;
3935 }
3937 //////////////////////////////////////////////////////////////////////////
3938 // 跨服 服务器撮合信息子消息
3939 void CMatchService::OnBridgeMsgMatchSubMsg(unsigned long actionId, SMsgBridgeHead &bridgeHead, SGameMsgHead* head, LPSTR data, size_t len)
3940 {
3951 	// 调式代码
3952 	char szBuf[512]={0};
3953 	sprintf_s(szBuf, _countof(szBuf),_NGT"CMatchService::OnBridgeMsgMatchSubMsg()  跨服 服务器撮合信息子消息:来源游戏世界ID=%d,来源服务器ID=%d,子消息代码=%d,len=%d,用户数据=%d,%d,%d",
3954 		bridgeHead.dwWorldID,bridgeHead.dwServerID,pMsg->dwMsgCode,len,pMsg->dwUserData1,pMsg->dwUserData2,pMsg->dwUserData3);
3955 	TraceLn(szBuf);
4146 	default:
4147 		{
4148 			ErrorLn("跨服组队撮合系统有一个跨服撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
4149 		}
4150 		break;
4151 	}	
4152 }
4155 // 跨服 跨区中转消息
4156 void CMatchService::OnBridgeMsgMatchBridgeData(unsigned long actionId, SMsgBridgeHead &bridgeHead, SGameMsgHead* head, LPSTR data, size_t len)
4157 {
4167 	// 调式代码
4168 	char szBuf[512]={0};
4169 	sprintf_s(szBuf, _countof(szBuf),_NGT"CMatchService::OnBridgeMsgMatchBridgeData()  跨服  跨区中转消息:目标端点码=%d,角色来自游戏世界ID=%d,角色ID=%d,行为消息码=%d,数据长度=%d",
4170 		pMsg->nDestEndPoint,pMsg->dwFromWorldID,pMsg->dwActorID,pMsg->wKeyAction,pMsg->nDataLens);
4171 	TraceLn(szBuf);
4257 		return;
4258 	}
4259 	// 跨服在线玩家列表,以玩家角色ID为关键字
4260 	SWorldOnlineUserInfo addNode;
4261 	addNode.dwPDBID		= dwActorID;
4264 	m_mapWorldOnlineUserList[dwActorID] = addNode;
4266 	// 触发事件
4267 	// 社会服  跨服玩家上线事件
4268 	SEventMatchAddUser_O eventSendData;
4269 	eventSendData.dwWorldID	= dwWorldID;				// 玩家来自游戏世界ID
4292 	m_mapWorldOnlineUserList.erase(dwActorID);
4294 	// 触发事件
4295 	// 社会服  跨服玩家下线事件
4296 	SEventMatchRemoveUser_O eventSendData;
4297 	eventSendData.dwWorldID	= dwWorldID;				// 玩家来自游戏世界ID
5640 //	g_ExternalFacade.WriteData2File((BYTE*)strLog.c_str(),strLog.size(),szFileName);
5642 }
5645 /** 设定指定游戏世界ID是否开启跨服国战
5646 @param   DWORD dwWorldID	: 游戏世界ID
5647 @param   bool bClose		: 是否关闭
5659 	}
5660 }
5663 /** 指定游戏世界ID是否开启跨服国战
5664 @param   DWORD dwWorldID	: 游戏世界ID
5665 @return bool 是否关闭
5760 	return nRateRet;
5761 }
5764 /** 取得跨服在线角色信息
5765 @param   DWORD dwPDBID	: 角色ID
5766 @return SWorldOnlineUserInfo 在线角色信息
5772 		return NULL;
5773 	}
5774 	// 跨服在线玩家列表,以玩家角色ID为关键字
5775 	TMAP_WorldOnlineUserList::iterator iter = m_mapWorldOnlineUserList.find(dwPDBID);
5776 	if (iter==m_mapWorldOnlineUserList.end())
5780 	return &(iter->second);
5781 }
5783 /** 取得跨服在线角色个数
5784 @param  
5785 @return   DWORD : 在线角色个数

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MatchServer\MatchServer.cpp 290 KB CPP 文件 2014/2/25 0:08:51 2018/10/23 20:06:23 2018/10/23 20:06:23 32
5 ** 日  期:	2010-7-13
6 ** 版  本:	1.0
7 ** 描  述:	跨服组队撮合系统服务器
8 ** 应  用:  	
9 	
22 #include "time.h"
24 CMatchServer* g_pMatchServer = NULL;
26 // 跨服国战跨服BUFF配置信息结构
27 static SCountryWarBalanceConfig g_CountryWarBalanceConfig[CoutryWarBalanceConfigCount] = {
28 	// 积分比相差数值,	攻方BUFF ID,	攻方BUFF 级别,		守方BUFF ID,	守方BUFF 级别
113 		return false;
114 	}
115 	// 创建跨服竞技撮合系统模块
116 	if (m_StrikeMatch.Create() == false)
117 	{
270 	// 关闭跨区竞技系统模块
271 	m_StrikeServer.Release();
273 	// 关闭跨服竞技撮合系统模块
274 	m_StrikeMatch.Release();
276 	// 关闭PK竞技管理器
416 			schemaInfo.nLevelRange		=  pCSVReader->GetInt(i, 3, 0);			// 上下浮动等级 组队时成员间的等级浮动范围 为0表示所有等级
417 			schemaInfo.nStrikeID		=  pCSVReader->GetInt(i, 4, 0);			// 竞技场类型ID Strike.csv nID 
418 			schemaInfo.nType			=  pCSVReader->GetInt(i, 5, 0);			// 跨服类型  1.跨服类型 2.本服类型
419 			schemaInfo.nMinNum			=  pCSVReader->GetInt(i, 6, 0);			// 撮合最少人数 主要是为了玩家在提交竞技请求时，撮合系统满足这个数值后，将组合好的玩家一次性提交到场景服中开场地竞技用
420 			schemaInfo.nFlag			=  pCSVReader->GetInt(i, 7, 0);			// 控制标识 
1586 		g_ExternalFacade.GetXmlChildAttributeInt(pRootElement, "maplimit", "starttime", &(m_WarConfigSchemeInfo.nlimitStartTime));	// 限制开启开始时间
1587 		g_ExternalFacade.GetXmlChildAttributeInt(pRootElement, "maplimit", "endtime", &(m_WarConfigSchemeInfo.nlimitEndTime));		// 限制开启结束时间
1590 		// 初始化跨服国战平衡BUFF配置信息
1591 		InitializeWarBalanceConfig();
1592 #ifdef MATCH_PRINT_DEBUG_INF
3596 	return &m_EctypeAssist;
3597 }
3600 /** 取得跨服竞技撮合系统接口
3601 */
3602 IStrikeMatch* CMatchServer::GetStrikeMatch()
3671 	return m_EctypeAssist;
3672 }
3673 /** 取得跨服竞技撮合系统
3674 */
3675 CStrikeMatch& CMatchServer::GetStrikeMatchInstance()
3867 	return _gstrOut.c_str();
3868 }
3870 // 获取跨服国战平衡BUFF配置信息
3871 const SCountryWarBalanceConfig & CMatchServer::GetCountryWarBalanceConfig(DWORD dwIndex)
3872 {
4930 	/*
4931 	MatchTypeID_None = 0,		//	无效类型
4932 	MatchTypeID_PublicFuBen,	//	跨服副本组队类型
4933 	MatchTypeID_LocalFuBen,		//	本服副本组队类型
4934 	MatchTypeID_Local,			//	本地组队
4996 			{
4997 				dwOpenStateFlag |= CheckMatchTypeOpenFlag(MatchTypeID_PublicFuBen);
4998 				// 跨服副本开时就关闭本服副本
4999 				DWORD dwLocalFubenFlag = GetMatchTypeToOpenFlag(MatchTypeID_LocalFuBen);
5000 				dwOpenStateFlag &= (~dwLocalFubenFlag);
5106 	return true;
5107 }
5109 // 初始化跨服国战平衡BUFF配置信息
5110 void CMatchServer::InitializeWarBalanceConfig()
5111 {
5361 /** 加入PVP场景类型与相关ID映射信息
5362 @param  DWORD dwZoneID		:		场景ID
5363 @param  DWORD dwPVPType		:		跨服PVP类型 EMPVPClassType
5364 @param  DWORD dwWarID		:		相关战场ID
5365 */
5367 {
5368 	SMatchPVPZoneInfoNode addNode;
5369 	addNode.dwPVPClassType	= dwPVPType;		// 跨服PVP类型 EMPVPClassType
5370 	addNode.dwWarID			= dwWarID;			// 相关战场ID
5371 	// PVP场景类型与相关ID映射信息
5383 /** 加入战争资源UID与相关ID映射信息
5384 @param  LONGLONG uid		:		实体UID
5385 @param  DWORD dwPVPType		:		跨服PVP类型 EMPVPClassType
5386 @param  DWORD dwWarID		:		相关战场ID
5387 @param  DWORD dwID			:		相关战争资源ID
5390 {
5391 	SWarEntityUIDResInfoNode addNode;
5392 	addNode.dwPVPClassType	= dwPVPType;		// 跨服PVP类型 EMPVPClassType
5393 	addNode.dwWarID			= dwWarID;			// 相关战场ID
5394 	addNode.dwID			= dwID;				// 相关战争资源ID
5897 	if (isPublicGameWorld() && dwMatchTypeID!=MatchTypeID_PublicFuBen)
5898 	{
5899 		sprintf_s(szMsg, sizeof(szMsg), "在跨服状态不能提交组队请求！");
5900 		// 发送消息给客户端
5901 		gZoneServiceProvider->GetChatServer()->sendSystemTips(TipType_Operate, dwPlayerID, InfoPos_ChatWindow|InfoPos_ActorRight, szMsg);
6098 				else
6099 				{
6100 					sprintf_s(szMsg, sizeof(szMsg), "共公区服务器未开启，不能提交跨服组队请求！");
6101 					// 发送消息给客户端
6102 					gZoneServiceProvider->GetChatServer()->sendSystemTips(TipType_Operate, dwPlayerID, InfoPos_ChatWindow|InfoPos_ActorRight, szMsg);
6105 			else
6106 			{
6107 				sprintf_s(szMsg, sizeof(szMsg), "共公区未开放，不能提交跨服组队请求！");
6108 				// 发送消息给客户端
6109 				gZoneServiceProvider->GetChatServer()->sendSystemTips(TipType_Operate, dwPlayerID, InfoPos_ChatWindow|InfoPos_ActorRight, szMsg);
6267 	if (isPublicGameWorld() && dwMatchTypeID!=MatchTypeID_PublicFuBen)
6268 	{
6269 		sprintf_s(szMsg, sizeof(szMsg), "%s 在跨服状态不能提交组队请求！",strCharHead.c_str());
6270 		// 发送消息给客户端
6271 		gZoneServiceProvider->GetChatServer()->worldSendSystemTips(dwChatWorldID,TipType_Operate, dwChatActorID, InfoPos_ChatWindow|InfoPos_ActorRight, szMsg);
6504 				else
6505 				{
6506 					sprintf_s(szMsg, sizeof(szMsg), "%s 共公区服务器未开启，不能提交跨服组队请求！",strCharHead.c_str());
6507 					// 发送消息给客户端
6508 					gZoneServiceProvider->GetChatServer()->worldSendSystemTips(dwChatWorldID,TipType_Operate, dwChatActorID, InfoPos_ChatWindow|InfoPos_ActorRight, szMsg);
6511 			else
6512 			{
6513 				sprintf_s(szMsg, sizeof(szMsg), "%s 共公区未开放，不能提交跨服组队请求！",strCharHead.c_str());
6514 				// 发送消息给客户端
6515 				gZoneServiceProvider->GetChatServer()->worldSendSystemTips(dwChatWorldID,TipType_Operate, dwChatActorID, InfoPos_ChatWindow|InfoPos_ActorRight, szMsg);
6664 	default:
6665 		{
6666 			ErrorLn("跨服组队撮合系统有一个桥服务器发过来的消息未处理，actionId = "<< actionId);
6667 		}
6668 		break;
6728 	default:
6729 		{
6730 			ErrorLn("跨服组队撮合系统模块有一个服务器消息未处理，actionId = "<< actionId);
6731 		}
6732 		break;
6780 	default:
6781 		{
6782 			ErrorLn("跨服组队撮合系统模块有一个客户端消息未处理，actionId = "<< actionId);
6783 		}
6784 		break;
6803 	// 调式代码
6804 	char szBuf[512]={0};
6805 	sprintf_s(szBuf,sizeof(szBuf), "CMatchServer::OnBridgeMsgMatchSubMsg()  跨服 服务器撮合信息子消息:来源游戏世界ID=%d,来源服务器ID=%d,子消息代码=%d,len=%d,用户数据=%d,%d,%d",
6806 		bridgeHead.dwWorldID,bridgeHead.dwServerID,pMsg->dwMsgCode,len,pMsg->dwUserData1,pMsg->dwUserData2,pMsg->dwUserData3);
6807 	TraceLn(szBuf);
6876 	default:
6877 		{
6878 			ErrorLn("跨服组队撮合系统有一个跨服撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
6879 		}
6880 		break;
7009 	default:
7010 		{
7011 			ErrorLn("跨服组队撮合系统有一个服务器撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
7012 		}
7013 		break;
7254 	default:
7255 		{
7256 			ErrorLn("跨服组队撮合系统有一个客户端撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
7257 		}
7258 		break;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MatchServer\MatchServer.cpp 290 KB CPP 文件 2014/2/25 14:27:05 2018/10/23 19:45:11 2018/10/23 19:45:11 32
5 ** 日  期:	2010-7-13
6 ** 版  本:	1.0
7 ** 描  述:	跨服组队撮合系统服务器
8 ** 应  用:  	
9 	
22 #include "time.h"
24 CMatchServer* g_pMatchServer = NULL;
26 // 跨服国战跨服BUFF配置信息结构
27 static SCountryWarBalanceConfig g_CountryWarBalanceConfig[CoutryWarBalanceConfigCount] = {
28 	// 积分比相差数值,	攻方BUFF ID,	攻方BUFF 级别,		守方BUFF ID,	守方BUFF 级别
113 		return false;
114 	}
115 	// 创建跨服竞技撮合系统模块
116 	if (m_StrikeMatch.Create() == false)
117 	{
270 	// 关闭跨区竞技系统模块
271 	m_StrikeServer.Release();
273 	// 关闭跨服竞技撮合系统模块
274 	m_StrikeMatch.Release();
276 	// 关闭PK竞技管理器
416 			schemaInfo.nLevelRange		=  pCSVReader->GetInt(i, 3, 0);			// 上下浮动等级 组队时成员间的等级浮动范围 为0表示所有等级
417 			schemaInfo.nStrikeID		=  pCSVReader->GetInt(i, 4, 0);			// 竞技场类型ID Strike.csv nID 
418 			schemaInfo.nType			=  pCSVReader->GetInt(i, 5, 0);			// 跨服类型  1.跨服类型 2.本服类型
419 			schemaInfo.nMinNum			=  pCSVReader->GetInt(i, 6, 0);			// 撮合最少人数 主要是为了玩家在提交竞技请求时，撮合系统满足这个数值后，将组合好的玩家一次性提交到场景服中开场地竞技用
420 			schemaInfo.nFlag			=  pCSVReader->GetInt(i, 7, 0);			// 控制标识 
1586 		g_ExternalFacade.GetXmlChildAttributeInt(pRootElement, "maplimit", "starttime", &(m_WarConfigSchemeInfo.nlimitStartTime));	// 限制开启开始时间
1587 		g_ExternalFacade.GetXmlChildAttributeInt(pRootElement, "maplimit", "endtime", &(m_WarConfigSchemeInfo.nlimitEndTime));		// 限制开启结束时间
1590 		// 初始化跨服国战平衡BUFF配置信息
1591 		InitializeWarBalanceConfig();
1592 #ifdef MATCH_PRINT_DEBUG_INF
3596 	return &m_EctypeAssist;
3597 }
3600 /** 取得跨服竞技撮合系统接口
3601 */
3602 IStrikeMatch* CMatchServer::GetStrikeMatch()
3671 	return m_EctypeAssist;
3672 }
3673 /** 取得跨服竞技撮合系统
3674 */
3675 CStrikeMatch& CMatchServer::GetStrikeMatchInstance()
3867 	return _gstrOut.c_str();
3868 }
3870 // 获取跨服国战平衡BUFF配置信息
3871 const SCountryWarBalanceConfig & CMatchServer::GetCountryWarBalanceConfig(DWORD dwIndex)
3872 {
4930 	/*
4931 	MatchTypeID_None = 0,		//	无效类型
4932 	MatchTypeID_PublicFuBen,	//	跨服副本组队类型
4933 	MatchTypeID_LocalFuBen,		//	本服副本组队类型
4934 	MatchTypeID_Local,			//	本地组队
4996 			{
4997 				dwOpenStateFlag |= CheckMatchTypeOpenFlag(MatchTypeID_PublicFuBen);
4998 				// 跨服副本开时就关闭本服副本
4999 				DWORD dwLocalFubenFlag = GetMatchTypeToOpenFlag(MatchTypeID_LocalFuBen);
5000 				dwOpenStateFlag &= (~dwLocalFubenFlag);
5106 	return true;
5107 }
5109 // 初始化跨服国战平衡BUFF配置信息
5110 void CMatchServer::InitializeWarBalanceConfig()
5111 {
5361 /** 加入PVP场景类型与相关ID映射信息
5362 @param  DWORD dwZoneID		:		场景ID
5363 @param  DWORD dwPVPType		:		跨服PVP类型 EMPVPClassType
5364 @param  DWORD dwWarID		:		相关战场ID
5365 */
5367 {
5368 	SMatchPVPZoneInfoNode addNode;
5369 	addNode.dwPVPClassType	= dwPVPType;		// 跨服PVP类型 EMPVPClassType
5370 	addNode.dwWarID			= dwWarID;			// 相关战场ID
5371 	// PVP场景类型与相关ID映射信息
5383 /** 加入战争资源UID与相关ID映射信息
5384 @param  LONGLONG uid		:		实体UID
5385 @param  DWORD dwPVPType		:		跨服PVP类型 EMPVPClassType
5386 @param  DWORD dwWarID		:		相关战场ID
5387 @param  DWORD dwID			:		相关战争资源ID
5390 {
5391 	SWarEntityUIDResInfoNode addNode;
5392 	addNode.dwPVPClassType	= dwPVPType;		// 跨服PVP类型 EMPVPClassType
5393 	addNode.dwWarID			= dwWarID;			// 相关战场ID
5394 	addNode.dwID			= dwID;				// 相关战争资源ID
5897 	if (isPublicGameWorld() && dwMatchTypeID!=MatchTypeID_PublicFuBen)
5898 	{
5899 		sprintf_s(szMsg, sizeof(szMsg), "在跨服状态不能提交组队请求！");
5900 		// 发送消息给客户端
5901 		gZoneServiceProvider->GetChatServer()->sendSystemTips(TipType_Operate, dwPlayerID, InfoPos_ChatWindow|InfoPos_ActorRight, szMsg);
6098 				else
6099 				{
6100 					sprintf_s(szMsg, sizeof(szMsg), "共公区服务器未开启，不能提交跨服组队请求！");
6101 					// 发送消息给客户端
6102 					gZoneServiceProvider->GetChatServer()->sendSystemTips(TipType_Operate, dwPlayerID, InfoPos_ChatWindow|InfoPos_ActorRight, szMsg);
6105 			else
6106 			{
6107 				sprintf_s(szMsg, sizeof(szMsg), "共公区未开放，不能提交跨服组队请求！");
6108 				// 发送消息给客户端
6109 				gZoneServiceProvider->GetChatServer()->sendSystemTips(TipType_Operate, dwPlayerID, InfoPos_ChatWindow|InfoPos_ActorRight, szMsg);
6267 	if (isPublicGameWorld() && dwMatchTypeID!=MatchTypeID_PublicFuBen)
6268 	{
6269 		sprintf_s(szMsg, sizeof(szMsg), "%s 在跨服状态不能提交组队请求！",strCharHead.c_str());
6270 		// 发送消息给客户端
6271 		gZoneServiceProvider->GetChatServer()->worldSendSystemTips(dwChatWorldID,TipType_Operate, dwChatActorID, InfoPos_ChatWindow|InfoPos_ActorRight, szMsg);
6504 				else
6505 				{
6506 					sprintf_s(szMsg, sizeof(szMsg), "%s 共公区服务器未开启，不能提交跨服组队请求！",strCharHead.c_str());
6507 					// 发送消息给客户端
6508 					gZoneServiceProvider->GetChatServer()->worldSendSystemTips(dwChatWorldID,TipType_Operate, dwChatActorID, InfoPos_ChatWindow|InfoPos_ActorRight, szMsg);
6511 			else
6512 			{
6513 				sprintf_s(szMsg, sizeof(szMsg), "%s 共公区未开放，不能提交跨服组队请求！",strCharHead.c_str());
6514 				// 发送消息给客户端
6515 				gZoneServiceProvider->GetChatServer()->worldSendSystemTips(dwChatWorldID,TipType_Operate, dwChatActorID, InfoPos_ChatWindow|InfoPos_ActorRight, szMsg);
6664 	default:
6665 		{
6666 			ErrorLn("跨服组队撮合系统有一个桥服务器发过来的消息未处理，actionId = "<< actionId);
6667 		}
6668 		break;
6728 	default:
6729 		{
6730 			ErrorLn("跨服组队撮合系统模块有一个服务器消息未处理，actionId = "<< actionId);
6731 		}
6732 		break;
6780 	default:
6781 		{
6782 			ErrorLn("跨服组队撮合系统模块有一个客户端消息未处理，actionId = "<< actionId);
6783 		}
6784 		break;
6803 	// 调式代码
6804 	char szBuf[512]={0};
6805 	sprintf_s(szBuf,sizeof(szBuf), "CMatchServer::OnBridgeMsgMatchSubMsg()  跨服 服务器撮合信息子消息:来源游戏世界ID=%d,来源服务器ID=%d,子消息代码=%d,len=%d,用户数据=%d,%d,%d",
6806 		bridgeHead.dwWorldID,bridgeHead.dwServerID,pMsg->dwMsgCode,len,pMsg->dwUserData1,pMsg->dwUserData2,pMsg->dwUserData3);
6807 	TraceLn(szBuf);
6876 	default:
6877 		{
6878 			ErrorLn("跨服组队撮合系统有一个跨服撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
6879 		}
6880 		break;
7009 	default:
7010 		{
7011 			ErrorLn("跨服组队撮合系统有一个服务器撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
7012 		}
7013 		break;
7254 	default:
7255 		{
7256 			ErrorLn("跨服组队撮合系统有一个客户端撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
7257 		}
7258 		break;

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcClient\Client\MatchClient\MatchClient.cpp 134 KB CPP 文件 2014/2/25 8:34:44 2018/10/23 19:52:18 2018/10/23 19:52:18 8
5 ** 日  期:	2010-7-13
6 ** 版  本:	1.0
7 ** 描  述:	跨服组队撮合系统客户端
8 ** 应  用:	
10 **************************** 修改记录 ******************************
186 	return new CPersonStrikePart();
187 }
190 /** 取得跨服竞技撮合系统接口
191 */
192 IStrikeMatch* CMatchClient::GetStrikeMatch()
227 	return m_EctypeAssist;
228 }
230 // 取得跨服竞技撮合系统
231 CStrikeMatch& CMatchClient::GetStrikeMatchInstance()
232 {
381 			schemaInfo.nLevelRange		=  pCSVReader->GetInt(i, 3, 0);			// 上下浮动等级 组队时成员间的等级浮动范围 为0表示所有等级
382 			schemaInfo.nStrikeID		=  pCSVReader->GetInt(i, 4, 0);			// 竞技场类型ID Strike.csv nID 
383 			schemaInfo.nType			=  pCSVReader->GetInt(i, 5, 0);			// 跨服类型  1.跨服类型 2.本服类型
384 			schemaInfo.nMinNum			=  pCSVReader->GetInt(i, 6, 0);			// 撮合最少人数 主要是为了玩家在提交竞技请求时，撮合系统满足这个数值后，将组合好的玩家一次性提交到场景服中开场地竞技用
385 			schemaInfo.nFlag			=  pCSVReader->GetInt(i, 7, 0);			// 控制标识 
1696 	default:
1697 		{
1698 			ErrorLn("跨服组队撮合系统客户端有一个事件订阅了但未处理，wEventID = "<<wEventID);
1699 		}
1700 		break;
3010 	/*
3011 	MatchTypeID_None = 0,		//	无效类型
3012 	MatchTypeID_PublicFuBen,	//	跨服副本组队类型
3013 	MatchTypeID_LocalFuBen,		//	本服副本组队类型
3014 	MatchTypeID_Local,			//	本地组队
4078 	default:
4079 		{
4080 			ErrorLn("跨服组队撮合系统有一个服务器撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
4081 		}
4082 		break;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcClient\Client\MatchClient\MatchClient.cpp 135 KB CPP 文件 2014/2/25 13:44:51 2018/10/23 19:34:25 2018/10/23 19:34:25 8
5 ** 日  期:	2010-7-13
6 ** 版  本:	1.0
7 ** 描  述:	跨服组队撮合系统客户端
8 ** 应  用:	
10 **************************** 修改记录 ******************************
186 	return new CPersonStrikePart();
187 }
190 /** 取得跨服竞技撮合系统接口
191 */
192 IStrikeMatch* CMatchClient::GetStrikeMatch()
227 	return m_EctypeAssist;
228 }
230 // 取得跨服竞技撮合系统
231 CStrikeMatch& CMatchClient::GetStrikeMatchInstance()
232 {
382 			schemaInfo.nLevelRange		=  pCSVReader->GetInt(i, 3, 0);			// 上下浮动等级 组队时成员间的等级浮动范围 为0表示所有等级
383 			schemaInfo.nStrikeID		=  pCSVReader->GetInt(i, 4, 0);			// 竞技场类型ID Strike.csv nID 
384 			schemaInfo.nType			=  pCSVReader->GetInt(i, 5, 0);			// 跨服类型  1.跨服类型 2.本服类型
385 			schemaInfo.nMinNum			=  pCSVReader->GetInt(i, 6, 0);			// 撮合最少人数 主要是为了玩家在提交竞技请求时，撮合系统满足这个数值后，将组合好的玩家一次性提交到场景服中开场地竞技用
386 			schemaInfo.nFlag			=  pCSVReader->GetInt(i, 7, 0);			// 控制标识 
1696 	default:
1697 		{
1698 			ErrorLn("跨服组队撮合系统客户端有一个事件订阅了但未处理，wEventID = "<<wEventID);
1699 		}
1700 		break;
3008 	/*
3009 	MatchTypeID_None = 0,		//	无效类型
3010 	MatchTypeID_PublicFuBen,	//	跨服副本组队类型
3011 	MatchTypeID_LocalFuBen,		//	本服副本组队类型
3012 	MatchTypeID_Local,			//	本地组队
4076 	default:
4077 		{
4078 			ErrorLn("跨服组队撮合系统有一个服务器撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
4079 		}
4080 		break;

I:\work\source\书剑恩仇录\书剑恩仇录_zccode.com\书剑恩仇录\金\Src\MapServer\Server\Map\MapCore.cpp 35 KB CPP 文件 2013/3/3 13:58:50 2018/10/23 13:34:39 2018/10/23 13:34:39 1
536 		{
537 			if ((pSceneData->m_uExtraType & EXTRA_MAPTYPE_FUBENENTRANCE) ||
538 				pSceneData->m_MapID == g_pFubenManager->GetServerBakSceneID()) //modify by Michael 2011-07-08 支持跨服副本
539 			{
540 				//以上场景是副本入口场景 创建副本数据

I:\work\source\书剑恩仇录\[src.cool]书剑恩仇录\Src\MapServer\Server\Map\MapCore.cpp 35 KB CPP 文件 2013/3/3 13:58:50 2018/10/23 13:34:21 2018/10/23 13:34:21 1
536 		{
537 			if ((pSceneData->m_uExtraType & EXTRA_MAPTYPE_FUBENENTRANCE) ||
538 				pSceneData->m_MapID == g_pFubenManager->GetServerBakSceneID()) //modify by Michael 2011-07-08 支持跨服副本
539 			{
540 				//以上场景是副本入口场景 创建副本数据

I:\work\source\书剑恩仇录\书剑恩仇录_zccode.com\书剑恩仇录\金\Src\MapServer\Server\Script\LuaFunction_Chat.cpp 66 KB CPP 文件 2013/3/3 14:01:10 2018/10/23 13:34:44 2018/10/23 13:34:44 1
1072 		LUA_RETURNERROR_1;
1073 	}
1075 	//世界频道支持跨服 added by Michael Lin 2011-08-07
1076 	for( int i = 0 ;i<MAX_SERVER_CONNECTOR_POOL_SIZE; ++i )
1077 	{

I:\work\source\书剑恩仇录\[src.cool]书剑恩仇录\Src\MapServer\Server\Script\LuaFunction_Chat.cpp 66 KB CPP 文件 2013/3/3 14:01:10 2018/10/23 13:34:26 2018/10/23 13:34:26 1
1072 		LUA_RETURNERROR_1;
1073 	}
1075 	//世界频道支持跨服 added by Michael Lin 2011-08-07
1076 	for( int i = 0 ;i<MAX_SERVER_CONNECTOR_POOL_SIZE; ++i )
1077 	{

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\LuaService\LuaAPI.cpp 97 KB CPP 文件 2014/2/25 0:22:39 2018/10/23 20:09:00 2018/10/23 20:09:00 35
1733 DWORD GetMatchWaitTimes(DWORD dwAvgNodeCounts)
1734 {
1735 	// 取得跨服组队撮合系统服务
1736 	IMatchService* pMatchService = gGlobalSocialServer->GetMatchService();
1737 	if (NULL==pMatchService)
1948 void SetCanEnterPublicWorldStrike(bool bFlag)
1949 {
1950 	// 取得跨服组队撮合系统服务
1951 	IMatchService* pMatchService = gGlobalSocialServer->GetMatchService();
1952 	if (NULL==pMatchService)
2130 	return nVocation;
2131 }
2134 /** 设定指定游戏世界ID是否开启跨服国战
2135 @param   DWORD dwWorldID	: 游戏世界ID
2136 @param   bool bClose		: 是否关闭
2146 	pMatchService->SetCloseWorldCountryWar(dwWorldID,bClose);
2147 }
2149 /** 指定游戏世界ID是否开启跨服国战
2150 @param   DWORD dwWorldID	: 游戏世界ID
2151 @return bool 是否关闭
2219 	pChatService->broadcastSystemTipsById( type, id,channel,channel,text );
2221 }
2224 /** 手动更新所有国家的跨服边境连接
2225 @param
2226 */
2227 bool LuaReLinkAllWorldCountry(bool bCheckWeekDay)
2228 {
2229 	// 取得跨服组队撮合系统服务
2230 	IMatchService* pMatchService = gGlobalSocialServer->GetMatchService();
2231 	if (NULL==pMatchService)
2243 	return true;
2244 }
2246 /**  取得跨服组队撮合系统服务接口
2247 @param   
2247 @param   
2248 @return  跨服组队撮合系统服务接口
2249 */
2250 IMatchService * GetMatchService(void)
2273 	}
2274 }
2277 /// 开启跨服战场API ///////////////////////////////////////////////////////////////////////
2279 /** 立即创建跨服国战并开启副本
2280 @param
2281 */
2284 	if (dwAttackWorldID==0 || dwAttackCountryID==0 || dwDefendWorldID==0 || dwDefendCountryID==0)
2285 	{
2286 		ErrorLn("立即创建跨服国战并开启副本失败，有国家ID配置为0，dwAttackWorldID="<< dwAttackWorldID << ",dwAttackCountryID="<<dwAttackCountryID<<",dwDefendWorldID="<<dwDefendWorldID<<",dwDefendCountryID="<< dwDefendCountryID);
2287 		return false;
2288 	}
2287 		return false;
2288 	}
2289 	// 取得跨服组队撮合系统服务
2290 	IMatchService * pMatchService = gGlobalSocialServer->GetMatchService();
2291 	if (pMatchService==NULL)
2309 	DWORD dwFightTime = dwStartTime+(DWORD)pSchemeInfo->nReadyTime;		// 战前准备时间（秒）
2310 	DWORD dwEndTime	  = dwFightTime+(DWORD)pSchemeInfo->nRunTime;		// 战斗总时长（秒）
2312 	// 创建跨服国战记录
2313 	SCountryWorldWarInfo node;
2314 	node.dwPublicWorldID	= getThisGameWorldID();					// 所属公共区世界ID
2315 	node.dwStartTime		= dwStartTime;								// 开始时间
2316 	node.dwEndTime			= dwEndTime;								// 结束时间
2317 	node.dwType				= WarType_Country1;							// 跨服国战类型 EMWarItemType, 跨服国战-落日城
2318 	node.dwAttackWorldID	= dwAttackWorldID;							// 进攻国家所在游戏世界ID
2319 	node.dwAttackCountryID	= dwAttackCountryID;						// 进攻国家ID
2325 	node.dwData1			= dwFightTime;								// 参数1 开战时间
2326 	node.dwData2			= dwSceneID;								// 参数2 战场情景ID,为0自动
2328 	// 新建跨服国战
2329 	return pWarService->NewCountryWorldWar(isPublicGameWorld(), node);
2330 }
2329 	return pWarService->NewCountryWorldWar(isPublicGameWorld(), node);
2330 }
2332 /** 立即创建跨服边境并开启副本
2333 @param
2334 */
2337 	if (dwAttackWorldID==0 || dwAttackCountryID==0)
2338 	{
2339 		ErrorLn("立即创建跨服边境并开启副本失败，有国家ID配置为0，dwAttackWorldID="<< dwAttackWorldID << ",dwAttackCountryID="<<dwAttackCountryID);
2340 		return false;
2341 	}
2340 		return false;
2341 	}
2342 	// 取得跨服组队撮合系统服务
2343 	IMatchService * pMatchService = gGlobalSocialServer->GetMatchService();
2344 	if (pMatchService==NULL)
2362 	DWORD dwFightTime = dwStartTime+(DWORD)pSchemeInfo->nReadyTime;		// 战前准备时间（秒）
2363 	DWORD dwEndTime	  = dwFightTime+(DWORD)pSchemeInfo->nRunTime;		// 战斗总时长（秒）
2365 	// 创建跨服战场记录
2366 	SCountryWorldWarInfo node;
2367 	node.dwPublicWorldID	= getThisGameWorldID();					// 所属公共区世界ID
2368 	node.dwStartTime		= dwStartTime;								// 开始时间
2369 	node.dwEndTime			= dwEndTime;								// 结束时间
2370 	node.dwType				= WarType_CountryBorder;					// 跨服国战类型 EMWarItemType, 跨服战场-国家边境
2371 	node.dwAttackWorldID	= dwAttackWorldID;							// 进攻国家所在游戏世界ID
2372 	node.dwAttackCountryID	= dwAttackCountryID;						// 进攻国家ID
2378 	node.dwData1			= dwFightTime;								// 参数1 开战时间
2379 	node.dwData2			= dwSceneID;								// 参数2 战场情景ID,为0自动
2381 	// 新建跨服边境
2382 	return pWarService->NewCountryWorldBorderWar(isPublicGameWorld(), node);
2383 }
2382 	return pWarService->NewCountryWorldBorderWar(isPublicGameWorld(), node);
2383 }
2385 /* 强制让本区的跨服国战记录失效，用于处理公共区异常导致本区缓存的数据还运行的问题，不让客户端显示活动追踪及DIDA
2386 @Param	: DWORD dwDBID	跨服国战数据库记录ID
2387 @Param	: DWORD dwState	战场状态标识 EMWarState
2388 @Param	: DWORD dwRunStep	战场状态子类扩展
2390 bool LuaAbandLocalCountryWorldWarInfo(DWORD dwDBID, DWORD dwState, DWORD dwRunStep)
2391 {
2392 	// 取得跨服组队撮合系统服务
2393 	IMatchService * pMatchService = gGlobalSocialServer->GetMatchService();
2394 	if (pMatchService==NULL)
2402 		return false;
2403 	}
2405 	// 强制让本区的跨服国战记录失效
2406 	return pWarService->AbandLocalCountryWorldWarInfo(dwDBID, dwState, dwRunStep);
2407 }
3513 void onServerInfoUpdatedMatrixInfo(DWORD dwServerID, SERVER_STATE nState, ServerData *pInfo)
3514 {
3515 	// 取得跨服组队撮合系统服务
3516 	IMatchService *pMatchService = gGlobalSocialServer->GetMatchService();
3517 	if (pMatchService == NULL)
3535 void SaveMatrixInfo(DWORD dwClanID, bool bSaveAllMatrix)
3536 {
3537 	// 取得跨服组队撮合系统服务
3538 	IMatchService *pMatchService = gGlobalSocialServer->GetMatchService();
3539 	if (pMatchService == NULL)
3585 void SetMatrixRankList(BYTE nCountryID, DWORD dwQuiltPassCount, DWORD dwPrizeTime, BYTE nPrizeCivilGrade, BYTE nPrizeRank)
3586 {
3587 	// 取得跨服组队撮合系统服务
3588 	IMatchService *pMatchService = gGlobalSocialServer->GetMatchService();
3589 	if (pMatchService == NULL)
3616 bool GetIsMatrixClanPlace(DWORD dwClanID)
3617 {
3618 	// 取得跨服组队撮合系统服务
3619 	IMatchService *pMatchService = gGlobalSocialServer->GetMatchService();
3620 	if (pMatchService == NULL)
3645 bool GetMatrixOpen(void)
3646 {
3647 	// 取得跨服组队撮合系统服务
3648 	IMatchService *pMatchService = gGlobalSocialServer->GetMatchService();
3649 	if (pMatchService == NULL)
3667 void SetMatrixCheckDataTimerState(BYTE nState)
3668 {
3669 	// 取得跨服组队撮合系统服务
3670 	IMatchService *pMatchService = gGlobalSocialServer->GetMatchService();
3671 	if (pMatchService == NULL)
3689 void AgainSetClanMatrixSetData(void)
3690 {
3691 	// 取得跨服组队撮合系统服务
3692 	IMatchService *pMatchService = gGlobalSocialServer->GetMatchService();
3693 	if (pMatchService == NULL)
3711 void SetNewLaunchNotOpenMatrixTime(int nNotOpenMatrixTime)
3712 {
3713 	// 取得跨服组队撮合系统服务
3714 	IMatchService *pMatchService = gGlobalSocialServer->GetMatchService();
3715 	if (pMatchService == NULL)

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcClient\Client\LuaClient\LuaApi.cpp 72 KB CPP 文件 2014/2/25 8:34:03 2018/10/23 19:52:05 2018/10/23 19:52:05 2
884 	return gGlobalClient->getSuitClient();
885 }
887 // 取得跨服组队撮合系统客户端
888 IMatchClient* GetMatchClient()
889 {
890 	return gGlobalClient->getMatchClient();
891 }
893 // 取得跨服组队撮合系统客户端
894 IDistrictListClient* GetDistrictListClient()
895 {

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\LuaService\LuaAPI.cpp 97 KB CPP 文件 2014/2/25 14:31:26 2018/10/23 19:46:39 2018/10/23 19:46:39 35
1733 DWORD GetMatchWaitTimes(DWORD dwAvgNodeCounts)
1734 {
1735 	// 取得跨服组队撮合系统服务
1736 	IMatchService* pMatchService = gGlobalSocialServer->GetMatchService();
1737 	if (NULL==pMatchService)
1948 void SetCanEnterPublicWorldStrike(bool bFlag)
1949 {
1950 	// 取得跨服组队撮合系统服务
1951 	IMatchService* pMatchService = gGlobalSocialServer->GetMatchService();
1952 	if (NULL==pMatchService)
2130 	return nVocation;
2131 }
2134 /** 设定指定游戏世界ID是否开启跨服国战
2135 @param   DWORD dwWorldID	: 游戏世界ID
2136 @param   bool bClose		: 是否关闭
2146 	pMatchService->SetCloseWorldCountryWar(dwWorldID,bClose);
2147 }
2149 /** 指定游戏世界ID是否开启跨服国战
2150 @param   DWORD dwWorldID	: 游戏世界ID
2151 @return bool 是否关闭
2219 	pChatService->broadcastSystemTipsById( type, id,channel,channel,text );
2221 }
2224 /** 手动更新所有国家的跨服边境连接
2225 @param
2226 */
2227 bool LuaReLinkAllWorldCountry(bool bCheckWeekDay)
2228 {
2229 	// 取得跨服组队撮合系统服务
2230 	IMatchService* pMatchService = gGlobalSocialServer->GetMatchService();
2231 	if (NULL==pMatchService)
2243 	return true;
2244 }
2246 /**  取得跨服组队撮合系统服务接口
2247 @param   
2247 @param   
2248 @return  跨服组队撮合系统服务接口
2249 */
2250 IMatchService * GetMatchService(void)
2273 	}
2274 }
2277 /// 开启跨服战场API ///////////////////////////////////////////////////////////////////////
2279 /** 立即创建跨服国战并开启副本
2280 @param
2281 */
2284 	if (dwAttackWorldID==0 || dwAttackCountryID==0 || dwDefendWorldID==0 || dwDefendCountryID==0)
2285 	{
2286 		ErrorLn("立即创建跨服国战并开启副本失败，有国家ID配置为0，dwAttackWorldID="<< dwAttackWorldID << ",dwAttackCountryID="<<dwAttackCountryID<<",dwDefendWorldID="<<dwDefendWorldID<<",dwDefendCountryID="<< dwDefendCountryID);
2287 		return false;
2288 	}
2287 		return false;
2288 	}
2289 	// 取得跨服组队撮合系统服务
2290 	IMatchService * pMatchService = gGlobalSocialServer->GetMatchService();
2291 	if (pMatchService==NULL)
2309 	DWORD dwFightTime = dwStartTime+(DWORD)pSchemeInfo->nReadyTime;		// 战前准备时间（秒）
2310 	DWORD dwEndTime	  = dwFightTime+(DWORD)pSchemeInfo->nRunTime;		// 战斗总时长（秒）
2312 	// 创建跨服国战记录
2313 	SCountryWorldWarInfo node;
2314 	node.dwPublicWorldID	= getThisGameWorldID();					// 所属公共区世界ID
2315 	node.dwStartTime		= dwStartTime;								// 开始时间
2316 	node.dwEndTime			= dwEndTime;								// 结束时间
2317 	node.dwType				= WarType_Country1;							// 跨服国战类型 EMWarItemType, 跨服国战-落日城
2318 	node.dwAttackWorldID	= dwAttackWorldID;							// 进攻国家所在游戏世界ID
2319 	node.dwAttackCountryID	= dwAttackCountryID;						// 进攻国家ID
2325 	node.dwData1			= dwFightTime;								// 参数1 开战时间
2326 	node.dwData2			= dwSceneID;								// 参数2 战场情景ID,为0自动
2328 	// 新建跨服国战
2329 	return pWarService->NewCountryWorldWar(isPublicGameWorld(), node);
2330 }
2329 	return pWarService->NewCountryWorldWar(isPublicGameWorld(), node);
2330 }
2332 /** 立即创建跨服边境并开启副本
2333 @param
2334 */
2337 	if (dwAttackWorldID==0 || dwAttackCountryID==0)
2338 	{
2339 		ErrorLn("立即创建跨服边境并开启副本失败，有国家ID配置为0，dwAttackWorldID="<< dwAttackWorldID << ",dwAttackCountryID="<<dwAttackCountryID);
2340 		return false;
2341 	}
2340 		return false;
2341 	}
2342 	// 取得跨服组队撮合系统服务
2343 	IMatchService * pMatchService = gGlobalSocialServer->GetMatchService();
2344 	if (pMatchService==NULL)
2362 	DWORD dwFightTime = dwStartTime+(DWORD)pSchemeInfo->nReadyTime;		// 战前准备时间（秒）
2363 	DWORD dwEndTime	  = dwFightTime+(DWORD)pSchemeInfo->nRunTime;		// 战斗总时长（秒）
2365 	// 创建跨服战场记录
2366 	SCountryWorldWarInfo node;
2367 	node.dwPublicWorldID	= getThisGameWorldID();					// 所属公共区世界ID
2368 	node.dwStartTime		= dwStartTime;								// 开始时间
2369 	node.dwEndTime			= dwEndTime;								// 结束时间
2370 	node.dwType				= WarType_CountryBorder;					// 跨服国战类型 EMWarItemType, 跨服战场-国家边境
2371 	node.dwAttackWorldID	= dwAttackWorldID;							// 进攻国家所在游戏世界ID
2372 	node.dwAttackCountryID	= dwAttackCountryID;						// 进攻国家ID
2378 	node.dwData1			= dwFightTime;								// 参数1 开战时间
2379 	node.dwData2			= dwSceneID;								// 参数2 战场情景ID,为0自动
2381 	// 新建跨服边境
2382 	return pWarService->NewCountryWorldBorderWar(isPublicGameWorld(), node);
2383 }
2382 	return pWarService->NewCountryWorldBorderWar(isPublicGameWorld(), node);
2383 }
2385 /* 强制让本区的跨服国战记录失效，用于处理公共区异常导致本区缓存的数据还运行的问题，不让客户端显示活动追踪及DIDA
2386 @Param	: DWORD dwDBID	跨服国战数据库记录ID
2387 @Param	: DWORD dwState	战场状态标识 EMWarState
2388 @Param	: DWORD dwRunStep	战场状态子类扩展
2390 bool LuaAbandLocalCountryWorldWarInfo(DWORD dwDBID, DWORD dwState, DWORD dwRunStep)
2391 {
2392 	// 取得跨服组队撮合系统服务
2393 	IMatchService * pMatchService = gGlobalSocialServer->GetMatchService();
2394 	if (pMatchService==NULL)
2402 		return false;
2403 	}
2405 	// 强制让本区的跨服国战记录失效
2406 	return pWarService->AbandLocalCountryWorldWarInfo(dwDBID, dwState, dwRunStep);
2407 }
3513 void onServerInfoUpdatedMatrixInfo(DWORD dwServerID, SERVER_STATE nState, ServerData *pInfo)
3514 {
3515 	// 取得跨服组队撮合系统服务
3516 	IMatchService *pMatchService = gGlobalSocialServer->GetMatchService();
3517 	if (pMatchService == NULL)
3535 void SaveMatrixInfo(DWORD dwClanID, bool bSaveAllMatrix)
3536 {
3537 	// 取得跨服组队撮合系统服务
3538 	IMatchService *pMatchService = gGlobalSocialServer->GetMatchService();
3539 	if (pMatchService == NULL)
3585 void SetMatrixRankList(BYTE nCountryID, DWORD dwQuiltPassCount, DWORD dwPrizeTime, BYTE nPrizeCivilGrade, BYTE nPrizeRank)
3586 {
3587 	// 取得跨服组队撮合系统服务
3588 	IMatchService *pMatchService = gGlobalSocialServer->GetMatchService();
3589 	if (pMatchService == NULL)
3616 bool GetIsMatrixClanPlace(DWORD dwClanID)
3617 {
3618 	// 取得跨服组队撮合系统服务
3619 	IMatchService *pMatchService = gGlobalSocialServer->GetMatchService();
3620 	if (pMatchService == NULL)
3645 bool GetMatrixOpen(void)
3646 {
3647 	// 取得跨服组队撮合系统服务
3648 	IMatchService *pMatchService = gGlobalSocialServer->GetMatchService();
3649 	if (pMatchService == NULL)
3667 void SetMatrixCheckDataTimerState(BYTE nState)
3668 {
3669 	// 取得跨服组队撮合系统服务
3670 	IMatchService *pMatchService = gGlobalSocialServer->GetMatchService();
3671 	if (pMatchService == NULL)
3689 void AgainSetClanMatrixSetData(void)
3690 {
3691 	// 取得跨服组队撮合系统服务
3692 	IMatchService *pMatchService = gGlobalSocialServer->GetMatchService();
3693 	if (pMatchService == NULL)
3711 void SetNewLaunchNotOpenMatrixTime(int nNotOpenMatrixTime)
3712 {
3713 	// 取得跨服组队撮合系统服务
3714 	IMatchService *pMatchService = gGlobalSocialServer->GetMatchService();
3715 	if (pMatchService == NULL)

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcClient\Client\LuaClient\LuaApi.cpp 72 KB CPP 文件 2014/2/25 13:44:19 2018/10/23 19:34:21 2018/10/23 19:34:21 2
891 	return gGlobalClient->getSuitClient();
892 }
894 // 取得跨服组队撮合系统客户端
895 IMatchClient* GetMatchClient()
896 {
897 	return gGlobalClient->getMatchClient();
898 }
900 // 取得跨服组队撮合系统客户端
901 IDistrictListClient* GetDistrictListClient()
902 {

I:\work\source\天空之剑\[src.cool]天空之剑\sky\Code\SrcServer\ScriptEngine\LUAApi.cpp 46 KB CPP 文件 2013/5/24 13:12:24 2018/10/23 14:48:35 2018/10/23 14:48:35 1
801 	return true;
802 }
804 // 传送玩家到跨服务器的某个地图
805 bool SLuaFnPlayer::PlayerSwtichGS(int nPlayerDBID, long lServerID, \
806 	long lMapID, int nMapCopyIndex, long x, long y)

I:\work\source\猎灵\[src.cool]猎灵\ServerMergeTool\Loong_ServerMerge.cpp 42 KB CPP 文件 2012/5/18 13:47:55 2018/10/19 15:58:05 2018/10/19 15:58:05 1
55 {
56 	BOOL bRet = FALSE;
58 	//如果是跨服合并
59 	if(eMergeType == EM_MERGE_CROSS_SECTION)
60 	{

I:\work\source\猎灵\[src.cool]猎灵\MultiServerMergeTool\Loong_ServerMerge.cpp 42 KB CPP 文件 2012/3/9 10:06:48 2018/10/19 15:57:56 2018/10/19 15:57:56 1
55 {
56 	BOOL bRet = FALSE;
58 	//如果是跨服合并
59 	if(eMergeType == EM_MERGE_CROSS_SECTION)
60 	{

I:\work\source\剑侠情缘3\sword3\Sources\MultiServer\GameServer\KSOServer.cpp 100 KB CPP 文件 2014/3/9 20:39:26 2018/10/19 14:09:42 2018/10/19 14:09:42 1
2767 		if (m_pGameStatus[lnID].nGameStatus == enumPlayerPlaying
2768 			|| (m_pGameStatus[lnID].nGameStatus == enumPlayerExchangingServer 
2769 			&& m_pGameStatus[lnID].nExchangeStatus != enumExchangeCleaning))	// 跨服务器时自己处理
2770 		{
2771 			int nIndex = m_pGameStatus[lnID].nPlayerIndex;

I:\work\source\剑侠情缘3\sword3\Sources\LINUX\KSOServer.cpp 100 KB CPP 文件 2014/3/9 20:39:14 2018/10/19 14:09:42 2018/10/19 14:09:42 1
2767 		if (m_pGameStatus[lnID].nGameStatus == enumPlayerPlaying
2768 			|| (m_pGameStatus[lnID].nGameStatus == enumPlayerExchangingServer 
2769 			&& m_pGameStatus[lnID].nExchangeStatus != enumExchangeCleaning))	// 跨服务器时自己处理
2770 		{
2771 			int nIndex = m_pGameStatus[lnID].nPlayerIndex;

I:\work\source\剑侠情缘3\sword3\Sources\Kernel\KSOServer.cpp 100 KB CPP 文件 2014/3/9 20:39:05 2018/10/19 14:09:40 2018/10/19 14:09:40 1
2767 		if (m_pGameStatus[lnID].nGameStatus == enumPlayerPlaying
2768 			|| (m_pGameStatus[lnID].nGameStatus == enumPlayerExchangingServer 
2769 			&& m_pGameStatus[lnID].nExchangeStatus != enumExchangeCleaning))	// 跨服务器时自己处理
2770 		{
2771 			int nIndex = m_pGameStatus[lnID].nPlayerIndex;

I:\work\source\剑侠情缘3\sword3\Sources\sources\core\src\KPlayerDBFuns.cpp 28 KB CPP 文件 2014/3/9 20:40:23 2018/10/19 14:09:45 2018/10/19 14:09:45 2
413 	// 登入游戏时战斗模式
414 	pNpc->m_FightMode = pRoleData->BaseInfo.cFightMode;
415 	// 是否是处于跨服务器状态
416 	if (pRoleData->BaseInfo.cIsExchange)
417 	{
784 	pRoleData->BaseInfo.irevivalx = 	m_sLoginRevivalPos.m_ReviveID;
785 	pRoleData->BaseInfo.irevivaly = 	0;
787 	if (m_bExchangeServer)	// 准备跨服务器：把存盘点设为目标点
788 	{
789 		pRoleData->BaseInfo.cUseRevive = 0;

I:\work\source\剑侠情缘3\sword3\Sources\LINUX\Core\KPlayerDBFuns.cpp 28 KB CPP 文件 2014/3/9 20:39:10 2018/10/19 14:09:41 2018/10/19 14:09:41 2
413 	// 登入游戏时战斗模式
414 	pNpc->m_FightMode = pRoleData->BaseInfo.cFightMode;
415 	// 是否是处于跨服务器状态
416 	if (pRoleData->BaseInfo.cIsExchange)
417 	{
784 	pRoleData->BaseInfo.irevivalx = 	m_sLoginRevivalPos.m_ReviveID;
785 	pRoleData->BaseInfo.irevivaly = 	0;
787 	if (m_bExchangeServer)	// 准备跨服务器：把存盘点设为目标点
788 	{
789 		pRoleData->BaseInfo.cUseRevive = 0;

I:\work\source\剑侠情缘3\sword3\Sources\Kernel\Core\KPlayerDBFuns.cpp 28 KB CPP 文件 2014/3/9 20:38:49 2018/10/19 14:09:40 2018/10/19 14:09:40 2
413 	// 登入游戏时战斗模式
414 	pNpc->m_FightMode = pRoleData->BaseInfo.cFightMode;
415 	// 是否是处于跨服务器状态
416 	if (pRoleData->BaseInfo.cIsExchange)
417 	{
784 	pRoleData->BaseInfo.irevivalx = 	m_sLoginRevivalPos.m_ReviveID;
785 	pRoleData->BaseInfo.irevivaly = 	0;
787 	if (m_bExchangeServer)	// 准备跨服务器：把存盘点设为目标点
788 	{
789 		pRoleData->BaseInfo.cUseRevive = 0;

I:\work\source\剑侠情缘3\sword3\Sources\sources\core\src\KNpc.cpp 143 KB CPP 文件 2014/3/9 20:40:22 2018/10/19 14:09:45 2018/10/19 14:09:45 1
5556 		return 2;	// 需要加切换服务器的处理 -- spe
5557 	}
5559 	Player[m_nPlayerIdx].m_nPrePayMoney = 0;// 不是跨服务器，不用还钱
5560 	// 切换的世界就是本身
5561 	if (nTargetSubWorld == m_SubWorldIndex)

I:\work\source\剑侠情缘3\sword3\Sources\LINUX\Core\KNpc.cpp 143 KB CPP 文件 2014/3/9 20:39:09 2018/10/19 14:09:41 2018/10/19 14:09:41 1
5556 		return 2;	// 需要加切换服务器的处理 -- spe
5557 	}
5559 	Player[m_nPlayerIdx].m_nPrePayMoney = 0;// 不是跨服务器，不用还钱
5560 	// 切换的世界就是本身
5561 	if (nTargetSubWorld == m_SubWorldIndex)

I:\work\source\剑侠情缘3\sword3\Sources\Kernel\Core\KNpc.cpp 143 KB CPP 文件 2014/3/9 20:38:49 2018/10/19 14:09:40 2018/10/19 14:09:40 1
5556 		return 2;	// 需要加切换服务器的处理 -- spe
5557 	}
5559 	Player[m_nPlayerIdx].m_nPrePayMoney = 0;// 不是跨服务器，不用还钱
5560 	// 切换的世界就是本身
5561 	if (nTargetSubWorld == m_SubWorldIndex)

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\KinServer\KinTankManager.cpp 42 KB CPP 文件 2014/2/25 0:09:00 2018/10/23 20:05:21 2018/10/23 20:05:21 2
1320 	//-------------------------------------------------------
1321 	//跨场景服处理
1322 	//如果玩家只是跨服，而不是真正的上下线，不进行请求或者设置状态
1323 	if (pLogin->nMode != loginXlogout_Mode_Offline)
1324 	{
1360 	//玩家下线之后隐藏kintank
1361 	//跨场景服处理
1362 	//如果玩家只是跨服，而不是真正的上下线，不进行请求或者设置状态
1363 	if (pLogoutContext->nMode != loginXlogout_Mode_Offline)
1364 	{

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\KinServer\KinTankManager.cpp 42 KB CPP 文件 2014/2/25 14:25:39 2018/10/23 19:44:13 2018/10/23 19:44:13 2
1320 	//-------------------------------------------------------
1321 	//跨场景服处理
1322 	//如果玩家只是跨服，而不是真正的上下线，不进行请求或者设置状态
1323 	if (pLogin->nMode != loginXlogout_Mode_Offline)
1324 	{
1360 	//玩家下线之后隐藏kintank
1361 	//跨场景服处理
1362 	//如果玩家只是跨服，而不是真正的上下线，不进行请求或者设置状态
1363 	if (pLogoutContext->nMode != loginXlogout_Mode_Offline)
1364 	{

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\KinService\KinServiceBase.cpp 22 KB CPP 文件 2014/2/25 0:22:23 2018/10/23 20:08:58 2018/10/23 20:08:58 1
364 		}
365 	}
367 	// 解决外网公共区跨服国战收到其它家族烟火的问题(by penglu 2013-07-01)
368 	// 无论玩家是否在线都需要向场景服通告删除成员
369 	obuf512 ob;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\KinService\KinServiceBase.cpp 22 KB CPP 文件 2014/2/25 14:31:19 2018/10/23 19:46:37 2018/10/23 19:46:37 1
364 		}
365 	}
367 	// 解决外网公共区跨服国战收到其它家族烟火的问题(by penglu 2013-07-01)
368 	// 无论玩家是否在线都需要向场景服通告删除成员
369 	obuf512 ob;

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\KinService\KinService.cpp 141 KB CPP 文件 2014/2/25 0:22:19 2018/10/23 20:08:58 2018/10/23 20:08:58 1
4037 		return;
4038 	}
4040 	// 取得跨服组队撮合系统服务
4041 	IMatchService *pMatchService = gGlobalSocialServer->GetMatchService();
4042 	if (pMatchService == NULL)

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\KinService\KinService.cpp 141 KB CPP 文件 2014/2/25 14:31:18 2018/10/23 19:46:37 2018/10/23 19:46:37 1
4037 		return;
4038 	}
4040 	// 取得跨服组队撮合系统服务
4041 	IMatchService *pMatchService = gGlobalSocialServer->GetMatchService();
4042 	if (pMatchService == NULL)

I:\work\source\书剑恩仇录\书剑恩仇录_zccode.com\书剑恩仇录\金\Src\MapServer\Server\GameLogic\Item_Manager.cpp 15 KB CPP 文件 2013/3/3 13:58:24 2018/10/23 13:34:39 2018/10/23 13:34:39 1
278 {
279 	__GUARD__ ig.m_Server = (uchar) m_ServerId;
280 	ig.m_World = (uchar) m_WorldId; //todo 跨服是否需要处理 added by Michael Lin 2011-07-28
281 	ig.m_Serial = GenItemSN();
283 	return TRUE;

I:\work\source\书剑恩仇录\[src.cool]书剑恩仇录\Src\MapServer\Server\GameLogic\Item_Manager.cpp 15 KB CPP 文件 2013/3/3 13:58:24 2018/10/23 13:34:20 2018/10/23 13:34:20 1
278 {
279 	__GUARD__ ig.m_Server = (uchar) m_ServerId;
280 	ig.m_World = (uchar) m_WorldId; //todo 跨服是否需要处理 added by Michael Lin 2011-07-28
281 	ig.m_Serial = GenItemSN();
283 	return TRUE;

I:\work\source\预言OL\yl code\code\Server\GameServer\mapgroupkernel\Item.cpp 76 KB CPP 文件 2010/1/6 16:09:05 2018/10/23 19:32:11 2018/10/23 19:32:11 1
2201 }
2203 //////////////////////////////////////////////////////////////////////////
2204 //是否是传送旗(已记录)，包括普通和超级， (超级就是可以跨服传送的)
2205 bool CItem::IsPointTransmissionLater()
2206 {

I:\work\source\预言OL\[src.cool]预言OL\yuyancode\code\Server\GameServer\mapgroupkernel\Item.cpp 76 KB CPP 文件 2010/1/6 16:09:05 2018/10/23 19:32:51 2018/10/23 19:32:51 1
2201 }
2203 //////////////////////////////////////////////////////////////////////////
2204 //是否是传送旗(已记录)，包括普通和超级， (超级就是可以跨服传送的)
2205 bool CItem::IsPointTransmissionLater()
2206 {

I:\work\source\盛世OL\[src.cool]盛世OL\Server\GameServer\mapgroupkernel\Item.cpp 104 KB CPP 文件 2014/2/25 15:43:00 2018/10/23 13:19:18 2018/10/23 13:19:18 1
2791 }
2793 //////////////////////////////////////////////////////////////////////////
2794 //是否是传送旗(已记录)，包括普通和超级， (超级就是可以跨服传送的)
2795 bool CItem::IsPointTransmissionLater()
2796 {

I:\work\source\剑侠时代\jxsd\core\地图插件\jxsd\code\Server\GameServer\mapgroupkernel\Item.cpp 75 KB CPP 文件 2010/12/21 10:13:14 2018/10/19 14:11:33 2018/10/19 14:11:33 1
2200 }
2202 //////////////////////////////////////////////////////////////////////////
2203 //是否是传送旗(已记录)，包括普通和超级， (超级就是可以跨服传送的)
2204 bool CItem::IsPointTransmissionLater()
2205 {

I:\work\source\剑侠时代\[src.cool]剑侠时代\jxsd\code\Server\GameServer\mapgroupkernel\Item.cpp 75 KB CPP 文件 2010/12/21 10:13:14 2018/10/19 14:11:13 2018/10/19 14:11:13 1
2200 }
2202 //////////////////////////////////////////////////////////////////////////
2203 //是否是传送旗(已记录)，包括普通和超级， (超级就是可以跨服传送的)
2204 bool CItem::IsPointTransmissionLater()
2205 {

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\CountryService\IPCityInfo.cpp 31 KB CPP 文件 2014/2/25 0:21:33 2018/10/23 20:08:53 2018/10/23 20:08:53 2
974 		return;
975 	}
976 	// 向数据库读取跨服国战信息记录
977 	IDBEngine * pDBEngine = g_ExternalFacade.GetDBEngine();
978 	if(pDBEngine == NULL)
999 	dbParam.dwTimes		= dwSaveTimes;								// 时间,同一批数据一样,并且不同游戏区时间统一处理成一样的数字
1000 	dbParam.dwWorldID	= dwGameWorldID;							// 所在游戏世界ID
1002 	// 修改跨服国战信息 : 传入参数结构
1003 	DB_Param_Add_IPCityLocationInfoNode recordData;
1005 	// 无地区的信息

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\CountryService\IPCityInfo.cpp 31 KB CPP 文件 2014/2/25 14:30:55 2018/10/23 19:46:34 2018/10/23 19:46:34 2
974 		return;
975 	}
976 	// 向数据库读取跨服国战信息记录
977 	IDBEngine * pDBEngine = g_ExternalFacade.GetDBEngine();
978 	if(pDBEngine == NULL)
999 	dbParam.dwTimes		= dwSaveTimes;								// 时间,同一批数据一样,并且不同游戏区时间统一处理成一样的数字
1000 	dbParam.dwWorldID	= dwGameWorldID;							// 所在游戏世界ID
1002 	// 修改跨服国战信息 : 传入参数结构
1003 	DB_Param_Add_IPCityLocationInfoNode recordData;
1005 	// 无地区的信息

I:\work\source\书剑恩仇录\书剑恩仇录_zccode.com\书剑恩仇录\金\Src\MapServer\Server\Messages\GXRetChangeSceneDispatch.cpp 6 KB CPP 文件 2013/3/3 14:00:00 2018/10/23 13:34:42 2018/10/23 13:34:42 1
106 				KCheck(MapID != INVALID_ID);
108 				ID_t		ServerID = g_pMapManager->GetMapData(MapID)->m_ServerID;
111 				// 2011-06-28 by Michael 根据跨服不同进行不同 ip port 查找
112 				if (0 == g_Config.m_MultiGroupConfig.m_nGroupCount)
113 				{

I:\work\source\书剑恩仇录\[src.cool]书剑恩仇录\Src\MapServer\Server\Messages\GXRetChangeSceneDispatch.cpp 6 KB CPP 文件 2013/3/3 14:00:00 2018/10/23 13:34:25 2018/10/23 13:34:25 1
106 				KCheck(MapID != INVALID_ID);
108 				ID_t		ServerID = g_pMapManager->GetMapData(MapID)->m_ServerID;
111 				// 2011-06-28 by Michael 根据跨服不同进行不同 ip port 查找
112 				if (0 == g_Config.m_MultiGroupConfig.m_nGroupCount)
113 				{

I:\work\source\神仙传\[src.cool]神仙传\GAME\Project1\ZoneClientEditor\Source\UI\guiMessageList.cpp 9 KB CPP 文件 2010/3/22 9:23:40 2018/10/23 13:31:20 2018/10/23 13:31:20 1
104 		AddEntry(nChannel,"<i s='gameres/gui/images/GUIWindow15_1_038.png' />", msg,TYPE_SYS,reserveID,name);
105 		break;
106 	case CHAT_MSG_TYPE_WORLD:// 跨服
107 		AddEntry(nChannel,"",msg,TYPE_CHANNEL,reserveID,name);
108 		break;

I:\work\source\神仙传\[src.cool]神仙传\GAME\Project1\ZoneClientEditor\Source\UI\guiBigViewMap.cpp 19 KB CPP 文件 2010/3/22 9:23:38 2018/10/23 13:31:20 2018/10/23 13:31:20 1
380 void GuiBigViewMap::moveToPos3D(S32 mapId,Point3F &pos3D,Point2I pos2D)
381 {
382 	//899999999大地图跨服专用ID
383 	RouteData* pData =  g_RouteRepository.getRouteData(899999999);
384 	if(NULL == pData)

I:\work\source\神魔传奇\[src.cool]神魔传奇代码\Server\ScenesServer\GuardNpc.cpp 12 KB CPP 文件 2012/1/17 23:01:19 2018/10/23 13:18:01 2018/10/23 13:18:01 1
464 }
466 /*
467 * \brief 保存护卫NPC的数据到指定位置（跨服时用）
468 *
469 * \param dest 目的地址

I:\work\source\征途\征途-2\zhengtu\src\libscenesserver\GuardNpc.cpp 12 KB CPP 文件 2009/2/26 11:33:10 2018/10/23 19:34:23 2018/10/23 19:34:23 1
454 }
456 /*
457  * \brief 保存护卫NPC的数据到指定位置（跨服时用）
458  *
459  * \param dest 目的地址

I:\work\source\征途\征途-1\zhengtu\征途\server\src\ScenesServer\GuardNpc.cpp 12 KB CPP 文件 2006/6/10 13:45:50 2018/10/23 19:35:35 2018/10/23 19:35:35 1
470 }
472 /*
473  * \brief 保存护卫NPC的数据到指定位置（跨服时用）
474  *
475  * \param dest 目的地址

I:\work\source\龙腾世界\[src.cool]龙腾世界\Code\Code\GraphNetServer\GSDataMng.cpp 43 KB CPP 文件 2007/2/1 15:23:22 2018/10/22 15:45:41 2018/10/22 15:45:41 1
1098 			if ( vPos.x < 0.0f && vPos.z < 0.0f )
1099 			{
1100 				//用gotoscene跨服务器切换场景时，不知道对面场景的尺寸，所以x,z都填-1，让目标场景自动定位到中央
1101 				vPos.x = pScene->GetMap()->GetCenterX();
1102 				vPos.z = pScene->GetMap()->GetCenterZ();

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\TeamService\GroupManager.cpp 99 KB CPP 文件 2014/2/25 0:25:04 2018/10/23 20:09:16 2018/10/23 20:09:16 2
1003 			else
1004 			{
1005 				if(pTeam != NULL && pTeam->IsSettingFlag(tTeamSetting_Flag_ForbidKick)/*跨服状态不允许换队*/)
1006 				{
1007 					ssprintf_s(szBuf, sizeof(szBuf), "%s不允许换队.", GetPublicWorldShowName());
1048 			else
1049 			{
1050 				if(pTeam->IsSettingFlag(tTeamSetting_Flag_ForbidKick)/*跨服状态不允许踢人*/)
1051 				{
1052 					ssprintf_s(szBuf, sizeof(szBuf), "%s不允许踢队友.", GetPublicWorldShowName());

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\TeamService\GroupManager.cpp 99 KB CPP 文件 2014/2/25 14:32:24 2018/10/23 19:46:55 2018/10/23 19:46:55 2
1003 			else
1004 			{
1005 				if(pTeam != NULL && pTeam->IsSettingFlag(tTeamSetting_Flag_ForbidKick)/*跨服状态不允许换队*/)
1006 				{
1007 					ssprintf_s(szBuf, sizeof(szBuf), "%s不允许换队.", GetPublicWorldShowName());
1048 			else
1049 			{
1050 				if(pTeam->IsSettingFlag(tTeamSetting_Flag_ForbidKick)/*跨服状态不允许踢人*/)
1051 				{
1052 					ssprintf_s(szBuf, sizeof(szBuf), "%s不允许踢队友.", GetPublicWorldShowName());

I:\work\source\书剑恩仇录\书剑恩仇录_zccode.com\书剑恩仇录\金\Src\MapServer\Server\Messages\GMRoomBattleDispatch.cpp 5 KB CPP 文件 2013/3/3 13:59:46 2018/10/23 13:34:41 2018/10/23 13:34:41 1
53 	else
54 	{
55 		MapID_t nBackSceneID = g_pFubenManager->GetServerBakSceneID();  //跨服处的副本入口场景
57 		MapID_t nTarSceneId = pPacket->GetRoomBattle()->u_RoomBattleData.m_SceneID;
58 		

I:\work\source\书剑恩仇录\[src.cool]书剑恩仇录\Src\MapServer\Server\Messages\GMRoomBattleDispatch.cpp 5 KB CPP 文件 2013/3/3 13:59:46 2018/10/23 13:34:24 2018/10/23 13:34:24 1
53 	else
54 	{
55 		MapID_t nBackSceneID = g_pFubenManager->GetServerBakSceneID();  //跨服处的副本入口场景
57 		MapID_t nTarSceneId = pPacket->GetRoomBattle()->u_RoomBattleData.m_SceneID;
58 		

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\ChatService\GMCommand.cpp 68 KB CPP 文件 2014/2/25 0:21:01 2018/10/23 20:08:50 2018/10/23 20:08:50 5
258 	if(pBridgeConnector != NULL && pBridgeConnector->IsConnected())
259 	{
260 		// 跨服发消息
261 		// pBridgeConnector->SendDataToServer(0, buf.data(), buf.size(), true);
263 		// 发往场景服
504 				record._rule = mr;
505 				MuteManager::getInstancePtr()->addRecord(record);
506 				osb<<"玩家不在线或跨服了 ,如果他离线了，"<<args[0]<<"已被成功离线禁言"<<t<<"分钟";
507 			}
508 			else
516 		if(pBridgeConnector != NULL && pBridgeConnector->IsConnected())
517 		{
518 			// 跨服发消息
519 			if (isPublicGameWorld())
520 			{
545 					if (t > 0)
546 					{
547 						osb<<"玩家"<<args[0]<<"不在线或跨服了，如果他在公共区，那么已被成功禁言 "<<t<<" 分钟";
548 					}
549 					else
549 					else
550 					{
551 						osb<<"玩家"<<args[0]<<"不在线或跨服了，如果他在公共区，那么已被成功解除禁言";
552 					}
553 					sendSystemTips(TipType_Operate, sender, InfoPos_ChatWindow, osb.c_str());

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\ChatService\GMCommand.cpp 68 KB CPP 文件 2014/2/25 14:30:36 2018/10/23 19:46:31 2018/10/23 19:46:31 5
258 	if(pBridgeConnector != NULL && pBridgeConnector->IsConnected())
259 	{
260 		// 跨服发消息
261 		// pBridgeConnector->SendDataToServer(0, buf.data(), buf.size(), true);
263 		// 发往场景服
504 				record._rule = mr;
505 				MuteManager::getInstancePtr()->addRecord(record);
506 				osb<<"玩家不在线或跨服了 ,如果他离线了，"<<args[0]<<"已被成功离线禁言"<<t<<"分钟";
507 			}
508 			else
516 		if(pBridgeConnector != NULL && pBridgeConnector->IsConnected())
517 		{
518 			// 跨服发消息
519 			if (isPublicGameWorld())
520 			{
545 					if (t > 0)
546 					{
547 						osb<<"玩家"<<args[0]<<"不在线或跨服了，如果他在公共区，那么已被成功禁言 "<<t<<" 分钟";
548 					}
549 					else
549 					else
550 					{
551 						osb<<"玩家"<<args[0]<<"不在线或跨服了，如果他在公共区，那么已被成功解除禁言";
552 					}
553 					sendSystemTips(TipType_Operate, sender, InfoPos_ChatWindow, osb.c_str());

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\SocialServer\GlobalSocialServer.cpp 64 KB CPP 文件 2014/2/25 0:23:56 2018/10/23 20:09:11 2018/10/23 20:09:11 10
484 			// 更新实时数据 在线数
485 			m_ManagerConnector->SetRealTimeData(MG_SocialRTData_OnLineCounts,(int)dwUserCounts);
487 			// 跨服在线角色个数
488 			DWORD dwOtherWorldUserCounts = 0;
489 			if (m_MatchService!=NULL)
491 				dwOtherWorldUserCounts = m_MatchService->GetOtherWorldUserCounts();
492 			}
493 			// 更新实时数据 跨服在线数
494 			m_ManagerConnector->SetRealTimeData(MG_SocialRTData_OtherOnLineCounts,(int)dwOtherWorldUserCounts);
495 		}
1475 		}
1476 		CREATE_SUCCESS();
1478 		// 跨服组队撮合系统服务
1479 		CREATE_BEGIN("CreateMatchService(跨服组队撮合系统服务) ......");
1480 		if ((m_MatchService = CreateMatchServiceProc()) == NULL)
1481 		{
1673 		MyRelease(mTransportService);
1674 		Trace("Close TransportService"<<endl);
1676 		//  跨服组队撮合系统服务
1677 		MyRelease(m_MatchService);
1677 		MyRelease(m_MatchService);
1678 		Trace("Close MatchService(跨服组队撮合系统服务)"<<endl);
1680 		// 国家系统服务
1681 		MyRelease(mCountryService);
1922 			dwUserCounts = pUserManager->getUserCount();
1923 		}
1925 		// 跨服在线角色个数
1926 		DWORD dwOtherWorldUserCounts = 0;
1927 		if (m_MatchService!=NULL)
1934 		addNode.dwTime			= dwNowTime;				// 时间
1935 		addNode.dwUserCounts	= dwUserCounts;				// 本区在线
1936 		addNode.dwOtherCounts	= dwOtherWorldUserCounts;	// 跨服在线角色个数
1938 		m_OnlineUserInfoList.push_back(addNode);	// 加入一个节点数据
1940 		bool bSaveOnline = false;	// 是否要保存
2038 			if (dwLastTraceTimes==0)
2039 			{
2040 				EmphasisLn("存入在线数据到DB,当前在线:"<<dwUserCounts<<",跨服在线:"<<dwOtherWorldUserCounts<<" (1分钟存一次,10分钟提示一次!)");
2041 				EmphasisLn("本分钟内,本区[最高="<<dbParam.nOnlineMaxNum<<",最小="<<dbParam.nOnlineMinNum<<",平均="<<dbParam.nOnlineAvgNum<<"] 跨服[最高="<<dbParam.nOnlineAreaMaxNum<<",最小="<<dbParam.nOnlineAreaMinNum<<",平均="<<dbParam.nOnlineAreaAvgNum<<"]");
2042 			}
2043 			dwLastTraceTimes++;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\SocialServer\GlobalSocialServer.cpp 64 KB CPP 文件 2014/2/25 14:32:01 2018/10/23 19:46:48 2018/10/23 19:46:48 10
484 			// 更新实时数据 在线数
485 			m_ManagerConnector->SetRealTimeData(MG_SocialRTData_OnLineCounts,(int)dwUserCounts);
487 			// 跨服在线角色个数
488 			DWORD dwOtherWorldUserCounts = 0;
489 			if (m_MatchService!=NULL)
491 				dwOtherWorldUserCounts = m_MatchService->GetOtherWorldUserCounts();
492 			}
493 			// 更新实时数据 跨服在线数
494 			m_ManagerConnector->SetRealTimeData(MG_SocialRTData_OtherOnLineCounts,(int)dwOtherWorldUserCounts);
495 		}
1475 		}
1476 		CREATE_SUCCESS();
1478 		// 跨服组队撮合系统服务
1479 		CREATE_BEGIN("CreateMatchService(跨服组队撮合系统服务) ......");
1480 		if ((m_MatchService = CreateMatchServiceProc()) == NULL)
1481 		{
1673 		MyRelease(mTransportService);
1674 		Trace("Close TransportService"<<endl);
1676 		//  跨服组队撮合系统服务
1677 		MyRelease(m_MatchService);
1677 		MyRelease(m_MatchService);
1678 		Trace("Close MatchService(跨服组队撮合系统服务)"<<endl);
1680 		// 国家系统服务
1681 		MyRelease(mCountryService);
1922 			dwUserCounts = pUserManager->getUserCount();
1923 		}
1925 		// 跨服在线角色个数
1926 		DWORD dwOtherWorldUserCounts = 0;
1927 		if (m_MatchService!=NULL)
1934 		addNode.dwTime			= dwNowTime;				// 时间
1935 		addNode.dwUserCounts	= dwUserCounts;				// 本区在线
1936 		addNode.dwOtherCounts	= dwOtherWorldUserCounts;	// 跨服在线角色个数
1938 		m_OnlineUserInfoList.push_back(addNode);	// 加入一个节点数据
1940 		bool bSaveOnline = false;	// 是否要保存
2038 			if (dwLastTraceTimes==0)
2039 			{
2040 				EmphasisLn("存入在线数据到DB,当前在线:"<<dwUserCounts<<",跨服在线:"<<dwOtherWorldUserCounts<<" (1分钟存一次,10分钟提示一次!)");
2041 				EmphasisLn("本分钟内,本区[最高="<<dbParam.nOnlineMaxNum<<",最小="<<dbParam.nOnlineMinNum<<",平均="<<dbParam.nOnlineAvgNum<<"] 跨服[最高="<<dbParam.nOnlineAreaMaxNum<<",最小="<<dbParam.nOnlineAreaMinNum<<",平均="<<dbParam.nOnlineAreaAvgNum<<"]");
2042 			}
2043 			dwLastTraceTimes++;

I:\work\source\远征\[src.cool]远征\Xgame2001_source\Common\GlobalEnumName.cpp 5 KB CPP 文件 2014/2/25 11:36:44 2018/10/23 19:49:31 2018/10/23 19:49:31 1
176 LPCSTR GetPublicWorldShowName()
177 {
178 	return "跨服状态";
179 }
182 /** 取得装备链接加上一个前缀，设别链接来源服务器

I:\work\source\远征\[src.cool]远征\Xgame2001_build\Common\GlobalEnumName.cpp 5 KB CPP 文件 2014/2/25 14:53:57 2018/10/23 19:32:39 2018/10/23 19:32:39 1
176 LPCSTR GetPublicWorldShowName()
177 {
178 	return "跨服状态";
179 }
182 /** 取得装备链接加上一个前缀，设别链接来源服务器

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcClient\Client\Game\GlobalClient.cpp 86 KB CPP 文件 2014/2/25 8:33:03 2018/10/23 19:51:37 2018/10/23 19:51:37 1
1095 		}
1096 		CREATE_SUCCESS();
1097 		// 跨服组队撮合系统客户端
1098 		CREATE_BEGIN("CreateMatchClient......");
1099 		if ((mMatchClient = CreateMatchClientProc()) == NULL)

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcClient\Client\Game\GlobalClient.cpp 74 KB CPP 文件 2014/2/25 13:43:32 2018/10/23 19:34:17 2018/10/23 19:34:17 1
1094 		}
1095 		CREATE_SUCCESS();
1096 		// 跨服组队撮合系统客户端
1097 		CREATE_BEGIN("CreateMatchClient......");
1098 		if ((mMatchClient = CreateMatchClientProc()) == NULL)

I:\work\source\书剑恩仇录\书剑恩仇录_zccode.com\书剑恩仇录\金\Src\GLServer\GL\Run\GL.cpp 41 KB CPP 文件 2013/3/3 13:57:44 2018/10/23 13:34:38 2018/10/23 13:34:38 3
657 	KCheck(g_pGLDynamicShopManager);
658 	QLogSystem::SLOW_LOG(SLOW_LOG_WORLD, "[New] new g_pGLDynamicShopManager...OK");
660 	// 跨服管理器
661 	QLogSystem::SLOW_LOG(SLOW_LOG_WORLD, "[New] Begin new g_pMutiGroupMapServerManager ... ");
662 	g_pMutiGroupMapServerManager = new MutiGroupMapServerManager;
876 	KCheck(ret);
877 	QLogSystem::SLOW_LOG(SLOW_LOG_WORLD, "g_pGLDynamicShopManager->Init()...OK");
879 	//跨服管理器
880 	QLogSystem::SLOW_LOG(SLOW_LOG_WORLD, "[Init] g_pMutiGroupMapServerManager->Init()...OK");
881 	ret = g_pMutiGroupMapServerManager->Init();
1037 	KSafeDelete(g_pGLDynamicShopManager);
1038 	QLogSystem::SLOW_LOG(SLOW_LOG_WORLD, "g_pGLDynamicShopManager delete...OK");
1040 	//跨服管理器
1041 	KSafeDelete(g_pMutiGroupMapServerManager);
1042 	QLogSystem::SLOW_LOG(SLOW_LOG_WORLD, "g_pMutiGroupMapServerManager delete...OK");

I:\work\source\书剑恩仇录\[src.cool]书剑恩仇录\Src\GLServer\GL\Run\GL.cpp 41 KB CPP 文件 2013/3/3 13:57:44 2018/10/23 13:34:16 2018/10/23 13:34:16 3
657 	KCheck(g_pGLDynamicShopManager);
658 	QLogSystem::SLOW_LOG(SLOW_LOG_WORLD, "[New] new g_pGLDynamicShopManager...OK");
660 	// 跨服管理器
661 	QLogSystem::SLOW_LOG(SLOW_LOG_WORLD, "[New] Begin new g_pMutiGroupMapServerManager ... ");
662 	g_pMutiGroupMapServerManager = new MutiGroupMapServerManager;
876 	KCheck(ret);
877 	QLogSystem::SLOW_LOG(SLOW_LOG_WORLD, "g_pGLDynamicShopManager->Init()...OK");
879 	//跨服管理器
880 	QLogSystem::SLOW_LOG(SLOW_LOG_WORLD, "[Init] g_pMutiGroupMapServerManager->Init()...OK");
881 	ret = g_pMutiGroupMapServerManager->Init();
1037 	KSafeDelete(g_pGLDynamicShopManager);
1038 	QLogSystem::SLOW_LOG(SLOW_LOG_WORLD, "g_pGLDynamicShopManager delete...OK");
1040 	//跨服管理器
1041 	KSafeDelete(g_pMutiGroupMapServerManager);
1042 	QLogSystem::SLOW_LOG(SLOW_LOG_WORLD, "g_pMutiGroupMapServerManager delete...OK");

I:\work\source\最游记\[src.cool]最游记\Server\Server\Server\GateServer\Source\GateServer.cpp 86 KB CPP 文件 2013/8/12 16:30:51 2018/10/23 19:50:11 2018/10/23 19:50:11 3
1259                     
1260                     // 设置账号来源的服务器ID
1261                     // 跨服使用的服务器编号数据
1262                     pClient->SetServerID(pLoginInfo->GetServerID());
1263                     break;
1374         {
1375             // 设置账号来源的服务器ID
1376             // 跨服使用的服务器编号数据
1377             pMsg->SetServerId(pClient->GetServerID());
1378             MessageType dwType = pMsg->GetType();
2068     ItrLoginInfoContainer it = _loginInfos.find( nKey );
2069     // 设置账号来源的服务器ID
2070     // 跨服使用的服务器编号数据
2072     if ( it != _loginInfos.end())
2073     {

I:\work\source\蜀山神话\[src.cool]蜀山神话\src\server\gatesvr\GateClient.cpp 29 KB CPP 文件 2012/4/21 1:05:19 2018/10/23 13:25:15 2018/10/23 13:25:15 1
788     {
789         this->SetMapMoveTo(move.m_sector, move.m_x, move.m_y, move.m_z);
790         //跨服传送中，GateClient一直处于GCS_SVR_MOVINGTO状态
791         //期间所有的协议都是通过SyncManager中转的，最后由SynchManager
792         //在所有的数据都同步完成之后，发送GTEVTTRANSREQUEST给状态机

I:\work\source\仙剑神曲\[src.cool]仙剑神曲\src\server\gatesvr\GateClient.cpp 31 KB CPP 文件 2012/4/22 2:05:36 2018/10/23 16:11:28 2018/10/23 16:11:28 1
823     {
824         this->SetMapMoveTo(move.m_sector, move.m_x, move.m_y, move.m_z);
825         //跨服传送中，GateClient一直处于GCS_SVR_MOVINGTO状态
826         //期间所有的协议都是通过SyncManager中转的，最后由SynchManager
827         //在所有的数据都同步完成之后，发送GTEVTTRANSREQUEST给状态机

I:\work\source\书剑恩仇录\书剑恩仇录_zccode.com\书剑恩仇录\金\Src\Client\Game\GameManager\GameStateRun.cpp 87 KB CPP 文件 2013/3/3 13:28:18 2018/10/23 13:33:17 2018/10/23 13:33:17 2
642 	//请求帮会令数据
643 	GAME_DATA_PTR->askGuildOrderData();
645 	//跨服关卡的处理  2011-08-26 added by Michael Lin
647 	//清除小地图上的军团信息
648 	GAME_DATA_RELATION_PTR->GetCorps()->ClearCorpsInfo();
659 	//请求军团数据
660 	GAME_DATA_QUEST_PTR->AskRoomBattleGroupData();
661 	/////跨服关卡的处理	
662 }
664 // 判断场景是否加载完毕， 处理进入游戏事件

I:\work\source\书剑恩仇录\[src.cool]书剑恩仇录\Src\Client\Game\GameManager\GameStateRun.cpp 87 KB CPP 文件 2013/3/3 13:28:18 2018/10/23 13:33:06 2018/10/23 13:33:06 2
642 	//请求帮会令数据
643 	GAME_DATA_PTR->askGuildOrderData();
645 	//跨服关卡的处理  2011-08-26 added by Michael Lin
647 	//清除小地图上的军团信息
648 	GAME_DATA_RELATION_PTR->GetCorps()->ClearCorpsInfo();
659 	//请求军团数据
660 	GAME_DATA_QUEST_PTR->AskRoomBattleGroupData();
661 	/////跨服关卡的处理	
662 }
664 // 判断场景是否加载完毕， 处理进入游戏事件

I:\work\source\书剑恩仇录\书剑恩仇录_zccode.com\书剑恩仇录\金\Src\Client\Game\GameManager\GameStateChangeServer.cpp 8 KB CPP 文件 2013/3/3 13:28:14 2018/10/23 13:33:17 2018/10/23 13:33:17 1
210 			::GetPrivateProfileString( "Debug", "Login.WorldID", "", szReadTemp, MAX_PATH, DEBUG_FILE_NAME );
211 			static ID_t s_nWorldID = atoi(szReadTemp); 
212 			GAME_DATA_PLAYER_PTR->SetWorldID(s_nWorldID); //added by Michael 2011-06-27 支持跨服自架测试
213 		}
214 	}

I:\work\source\书剑恩仇录\[src.cool]书剑恩仇录\Src\Client\Game\GameManager\GameStateChangeServer.cpp 8 KB CPP 文件 2013/3/3 13:28:14 2018/10/23 13:33:06 2018/10/23 13:33:06 1
210 			::GetPrivateProfileString( "Debug", "Login.WorldID", "", szReadTemp, MAX_PATH, DEBUG_FILE_NAME );
211 			static ID_t s_nWorldID = atoi(szReadTemp); 
212 			GAME_DATA_PLAYER_PTR->SetWorldID(s_nWorldID); //added by Michael 2011-06-27 支持跨服自架测试
213 		}
214 	}

I:\work\source\蜀山神话\[src.cool]蜀山神话\src\server\gamesvr\GamePlayer.cpp 171 KB CPP 文件 2012/4/21 1:05:17 2018/10/23 13:25:10 2018/10/23 13:25:10 2
412 		// Modify By : Guoqiang
413 		// Date      : 2008-06-16
414 		// commnet   : 真正离开游戏，非跨服情况，保存玩家本次离开的时间,
415 		//             玩家在跨越物理服务器的时候也会保存一下离开时间，来保证
416 		//             带有时间属性的物品，并且以物理时间来计时物品的生存周期的
4127     m_bSaveLastExitTime = true;
4128 }
4130 // 跨服过程，设置在线奖励状态
4131 // 1. 如果玩家有奖励正在计时，则设置剩余时间继续开始计时，如果该奖励跨天则设置needrestart
4132 // 2. 如果玩家当前奖励计时已经完成，则看该奖励是否跨天，如果跨天则设置needrestart

I:\work\source\最游记\[src.cool]最游记\Server\Server\Server\Common\GamePlayer.cpp 605 KB CPP 文件 2013/6/28 13:59:40 2018/10/23 19:49:43 2018/10/23 19:49:43 2
3011     HelperFunc::SafeNCpy( pMsg->szSignature, m_pRelation->GetSignature()  , RelationDefine::MaxSignLength );
3012     
3013     //跨服服务器都使用这个
3014     if (g_Cfg.IsInstanceServer())
3015     { HelperFunc::SafeNCpy( pMsg->szServerName, g_Cfg.GetCenterName(GetServerID()) ,MAX_SERVERNAME);}
12718             return false;
12719         }
12721         // 因跨服战场在匹配好玩家之后就会创建副本地图，所以这块直接飞进去
12722         return ChangeToMap(pStage, fX, fY, fZ, fDir, __FUNCTION__, __LINE__);
12723     }

I:\work\source\仙剑神曲\[src.cool]仙剑神曲\src\server\gamesvr\GamePlayer.cpp 127 KB CPP 文件 2012/4/22 2:05:34 2018/10/23 16:11:01 2018/10/23 16:11:01 1
498 		// Modify By : Guoqiang
499 		// Date      : 2008-06-16
500 		// commnet   : 真正离开游戏，非跨服情况，保存玩家本次离开的时间,
501 		//             玩家在跨越物理服务器的时候也会保存一下离开时间，来保证
502 		//             带有时间属性的物品，并且以物理时间来计时物品的生存周期的

I:\work\source\蜀山神话\[src.cool]蜀山神话\src\server\tracksvr\GameMessageDispatcher.cpp 77 KB CPP 文件 2012/4/21 1:05:04 2018/10/23 13:25:20 2018/10/23 13:25:20 4
307     // 客户端请求宗派援助
308     void HandleRequestGuildAssistance(FiMessage* pMsg);
309 	//请求跨服查询
310 	void HandleObserverOtherGameRequest(FiMessage* pMsg);
311 	//回复玩家观察角色装备信息
2746 	}
2747 }
2749 //请求跨服查询
2750 void GameMessageDispatcher::HandleObserverOtherGameRequest(FiMessage* pMsg)
2751 {
2758 	}
2759 }
2761 //跨服查询回复角色装备信息
2762 void GameMessageDispatcher::HandleObserverResponse(FiMessage* pMsg)
2763 {
2770 	}
2772 }
2774 //跨服查询回复宠物信息
2775 void GameMessageDispatcher::HandleObserverPetPetdetail(FiMessage* pMsg)
2776 {

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\LuaServer\GameMatchAPI.cpp 68 KB CPP 文件 2014/2/25 0:09:17 2018/10/23 20:06:04 2018/10/23 20:06:04 11
5 ** 日  期:	2010-7-13
6 ** 版  本:	1.0
7 ** 描  述:	跨服组队撮合系统API接口
8 ** 应  用:  	
10 **************************** 修改记录 ******************************
761 }
763 ///////////// 跨区战场API /////////////////////////////////////////////////////////////
765 /** 用现场创建跨服国战
766 @param  DWORD dwWarTypeID		: 战场场类型 EMWarItemType
767 @param  const char * szCampNames: 阵营名称列表，分号分割阵营名
998 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->GetWarStringProp( dwZoneID,  dwPropID);
999 }
1002 /** 跨服领地BOSS战接收外部数据结构信息
1003 @param	 DWORD dwActorID	:玩家序列号
1004 @param	 DWORD dwWarID		:战场ID
1009 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->GetCastleBossWarExtData( dwActorID, dwWarID);
1010 }
1012 /** 跨服领地BOSS战接收外部数据结构信息
1013 @param	 DWORD dwActorID	:玩家序列号
1014 @param	 DWORD dwWarID		:战场ID
1022 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->SetCastleBossWarExtData( dwActorID, dwWarID,  dwCivilGrade,  dwBossID,  szClanIDs);
1023 }
1025 /** 跨服领地BOSS战接收外部数据结构中指定帮会信息
1026 @param	 DWORD dwActorID	:玩家序列号
1027 @param	 DWORD dwWarID		:战场ID
1047 return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->GetWarGameUpLevelLimit( dwZoneID);
1048 }
1050 /** 取得跨服边境战场对象
1051 @param	 DWORD dwZoneID		:场景ID
1052 @return  SCountryWarInfo *
1056 return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->GetCountryBorderWar( dwZoneID);
1057 }
1059 /** 跨服边境战场内传送玩家
1060 @param	 DWORD dwActorID	:玩家序列号
1061 @param	 DWORD dwTransFlag	:传送标识 EMCountryBorderWarTransFlag
1066 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->CountryBorderWarTransActor( dwActorID, dwTransFlag);
1067 }
1069 /** 跨服边境战场内传送玩家是否能传送到天上战场
1070 @param	 DWORD dwActorID	:玩家序列号
1071 @param	 DWORD dwZoneID		:场景ID
1076 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->CountryBorderWarActorCanTransSky(dwActorID);
1078 }
1080 /** 跨服边境战场击杀BOSS时AI触发事件后处理
1081 @param	DWORD dwActorID		: 玩家序列号
1082 @param	bool bSendResult	: 是否要发送结果信息到社会服,false=不发送
1087 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->DoCountryBorderWarKillBossEvent( dwActorID,  bSendResult);
1088 }
1091 /** 检测跨服边境战场是否开启任务
1092 @param	DWORD dwActorID		: 玩家序列号
1093 @return  bool
1097 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->CheckCountryBorderWarOpenTask(dwActorID);
1098 }
1100 /** 检测跨服边境战场阵营数量
1101 @param	DWORD dwActorID		: 玩家序列号
1102 @return  DWORD

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\LuaServer\GameMatchAPI.cpp 68 KB CPP 文件 2014/2/25 14:25:52 2018/10/23 19:44:39 2018/10/23 19:44:39 11
5 ** 日  期:	2010-7-13
6 ** 版  本:	1.0
7 ** 描  述:	跨服组队撮合系统API接口
8 ** 应  用:  	
10 **************************** 修改记录 ******************************
761 }
763 ///////////// 跨区战场API /////////////////////////////////////////////////////////////
765 /** 用现场创建跨服国战
766 @param  DWORD dwWarTypeID		: 战场场类型 EMWarItemType
767 @param  const char * szCampNames: 阵营名称列表，分号分割阵营名
998 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->GetWarStringProp( dwZoneID,  dwPropID);
999 }
1002 /** 跨服领地BOSS战接收外部数据结构信息
1003 @param	 DWORD dwActorID	:玩家序列号
1004 @param	 DWORD dwWarID		:战场ID
1009 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->GetCastleBossWarExtData( dwActorID, dwWarID);
1010 }
1012 /** 跨服领地BOSS战接收外部数据结构信息
1013 @param	 DWORD dwActorID	:玩家序列号
1014 @param	 DWORD dwWarID		:战场ID
1022 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->SetCastleBossWarExtData( dwActorID, dwWarID,  dwCivilGrade,  dwBossID,  szClanIDs);
1023 }
1025 /** 跨服领地BOSS战接收外部数据结构中指定帮会信息
1026 @param	 DWORD dwActorID	:玩家序列号
1027 @param	 DWORD dwWarID		:战场ID
1047 return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->GetWarGameUpLevelLimit( dwZoneID);
1048 }
1050 /** 取得跨服边境战场对象
1051 @param	 DWORD dwZoneID		:场景ID
1052 @return  SCountryWarInfo *
1056 return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->GetCountryBorderWar( dwZoneID);
1057 }
1059 /** 跨服边境战场内传送玩家
1060 @param	 DWORD dwActorID	:玩家序列号
1061 @param	 DWORD dwTransFlag	:传送标识 EMCountryBorderWarTransFlag
1066 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->CountryBorderWarTransActor( dwActorID, dwTransFlag);
1067 }
1069 /** 跨服边境战场内传送玩家是否能传送到天上战场
1070 @param	 DWORD dwActorID	:玩家序列号
1071 @param	 DWORD dwZoneID		:场景ID
1076 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->CountryBorderWarActorCanTransSky(dwActorID);
1078 }
1080 /** 跨服边境战场击杀BOSS时AI触发事件后处理
1081 @param	DWORD dwActorID		: 玩家序列号
1082 @param	bool bSendResult	: 是否要发送结果信息到社会服,false=不发送
1087 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->DoCountryBorderWarKillBossEvent( dwActorID,  bSendResult);
1088 }
1091 /** 检测跨服边境战场是否开启任务
1092 @param	DWORD dwActorID		: 玩家序列号
1093 @return  bool
1097 	return gZoneServiceProvider->GetMatchServer()->GetGameMatchAPI()->CheckCountryBorderWarOpenTask(dwActorID);
1098 }
1100 /** 检测跨服边境战场阵营数量
1101 @param	DWORD dwActorID		: 玩家序列号
1102 @return  DWORD

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcClient\Client\controller\GameForm.cpp 65 KB CPP 文件 2014/2/25 8:37:01 2018/10/23 19:50:53 2018/10/23 19:50:53 1
1469 					gGlobalClient->getNetConnection()->SendData(ob.data(), ob.size());;
1471 					//ConnectNewAreaGateway();
1472 					// 执行一段处理跨服额外功能
1473 					gGlobalClient->getLuaEngine()->RunLuaFunction("OnFireStartAreaSwitchHandle");
1474 				}

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcClient\Client\controller\GameForm.cpp 66 KB CPP 文件 2014/2/25 13:46:38 2018/10/23 19:33:49 2018/10/23 19:33:49 1
1488 					gGlobalClient->getNetConnection()->SendData(ob.data(), ob.size());;
1490 					//ConnectNewAreaGateway();
1491 					// 执行一段处理跨服额外功能
1492 					gGlobalClient->getLuaEngine()->RunLuaFunction("OnFireStartAreaSwitchHandle");
1493 				}

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\CountryService\GameCountryAPI.cpp 69 KB CPP 文件 2014/2/25 0:21:30 2018/10/23 20:08:53 2018/10/23 20:08:53 2
2690 	return pCountryServer->OpenManagerCmd(dwPlayerID,dwManagerPlayerID);
2691 }
2694 // 检查明天是否有跨服国战
2695 bool CheckCountryWorldWar(DWORD dwFromWorldID,DWORD dwFromCountryID,DWORD dwWorldID,DWORD dwCountryID)
2696 {
2700 		return false;
2701 	}
2702 	// 取地跨服国战系统接口
2703 	IWorldWar* pWorldWar = pCountryServer->GetWorldWarPart();
2704 	if (pWorldWar==NULL)

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\CountryService\GameCountryAPI.cpp 69 KB CPP 文件 2014/2/25 14:30:54 2018/10/23 19:46:34 2018/10/23 19:46:34 2
2690 	return pCountryServer->OpenManagerCmd(dwPlayerID,dwManagerPlayerID);
2691 }
2694 // 检查明天是否有跨服国战
2695 bool CheckCountryWorldWar(DWORD dwFromWorldID,DWORD dwFromCountryID,DWORD dwWorldID,DWORD dwCountryID)
2696 {
2700 		return false;
2701 	}
2702 	// 取地跨服国战系统接口
2703 	IWorldWar* pWorldWar = pCountryServer->GetWorldWarPart();
2704 	if (pWorldWar==NULL)

I:\work\source\书剑恩仇录\书剑恩仇录_zccode.com\书剑恩仇录\金\Src\MapServer\Server\Map\FubenManager.cpp 15 KB CPP 文件 2013/3/3 13:58:48 2018/10/23 13:34:39 2018/10/23 13:34:39 2
94 	if (g_Config.m_MultiGroupConfig.m_nGroupCount > 0)
95 	{
96 		KCheck(FALSE);//跨服服务器上找不到报错
97 	}
98 	
456 	if (g_Config.m_MultiGroupConfig.m_nGroupCount > 0)
457 	{
458 		//以下开始通知广播,支持跨服架构
459 		for( int i = 0 ;i<MAX_SERVER_CONNECTOR_POOL_SIZE; ++i )
460 		{

I:\work\source\书剑恩仇录\[src.cool]书剑恩仇录\Src\MapServer\Server\Map\FubenManager.cpp 15 KB CPP 文件 2013/3/3 13:58:48 2018/10/23 13:34:21 2018/10/23 13:34:21 2
94 	if (g_Config.m_MultiGroupConfig.m_nGroupCount > 0)
95 	{
96 		KCheck(FALSE);//跨服服务器上找不到报错
97 	}
98 	
456 	if (g_Config.m_MultiGroupConfig.m_nGroupCount > 0)
457 	{
458 		//以下开始通知广播,支持跨服架构
459 		for( int i = 0 ;i<MAX_SERVER_CONNECTOR_POOL_SIZE; ++i )
460 		{

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcClient\Client\FriendClient\FriendClient.cpp 34 KB CPP 文件 2014/2/25 8:32:53 2018/10/23 19:51:33 2018/10/23 19:51:33 1
480 		ostrbuf osb;
481 		if ( bIsPublicOnline == true && isPublicGameWorld() == false)
482 			osb.add_format(_GT("您的好友 [%s] 使用跨服系统在公共区上线！"), name);
483 		else
484 			osb.add_format(_GT("您的好友 [%s] 已经上线！"), name);

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcClient\Client\FriendClient\FriendClient.cpp 34 KB CPP 文件 2014/2/25 13:43:24 2018/10/23 19:34:16 2018/10/23 19:34:16 1
480 		ostrbuf osb;
481 		if ( bIsPublicOnline == true && isPublicGameWorld() == false)
482 			osb.add_format(_GT("您的好友 [%s] 使用跨服系统在公共区上线！"), name);
483 		else
484 			osb.add_format(_GT("您的好友 [%s] 已经上线！"), name);

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\FriendService\Friend.cpp 39 KB CPP 文件 2014/2/25 0:21:52 2018/10/23 20:08:54 2018/10/23 20:08:54 1
231 			return;
232 		}
233 		/// 跨服私聊聊天
234 		OnPubliceChat(target,msg);
235 		return;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\FriendService\Friend.cpp 39 KB CPP 文件 2014/2/25 14:31:05 2018/10/23 19:46:35 2018/10/23 19:46:35 1
231 			return;
232 		}
233 		/// 跨服私聊聊天
234 		OnPubliceChat(target,msg);
235 		return;

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\TeamService\FlowController.cpp 16 KB CPP 文件 2014/2/25 0:24:56 2018/10/23 20:09:16 2018/10/23 20:09:16 1
200 				 if (pWarService->IsCountryWarFight(pSelfUserInfo,pTargetUserInfo))
201 				 {
202 					 g_ExternalFacade.SendActorRightTips(dwSelfPDBID, "对不起，跨服国战期间无法邀请对手玩家组队！");
203 					 return ;
204 				 }

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\TeamService\FlowController.cpp 16 KB CPP 文件 2014/2/25 14:32:22 2018/10/23 19:46:54 2018/10/23 19:46:54 1
200 				 if (pWarService->IsCountryWarFight(pSelfUserInfo,pTargetUserInfo))
201 				 {
202 					 g_ExternalFacade.SendActorRightTips(dwSelfPDBID, "对不起，跨服国战期间无法邀请对手玩家组队！");
203 					 return ;
204 				 }

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\MatchService\EctypeAssist.cpp 22 KB CPP 文件 2014/2/25 0:23:01 2018/10/23 20:09:03 2018/10/23 20:09:03 3
221 			ostrbuf osb;
222 			ostrbuf link;
223 			link << "<a color='#FF00FF00' href=\"" << "Z?17&2" << pEctypeTeam->dwEctypeType << "&" <<"\"> 点击进行跨服副本";
224 			osb << "<rich color='#FF12E4E4'>" << szWorldName << "区<rich color='FFFFFFFF'>的<rich color='#FF12E4E4'>" << first.szName << "<rich color='FFFFFFFF'>通过<rich color='#FF12E4E4'>跨服副本系统<rich color='FFFFFFFF'>成功进入<rich color='#FF12E4E4'>" << pScheme->szName << "　" << link << "<rich color='default'>";
226 			DWORD arrWorldID[256] = {0};
227 			DWORD dwCount = 0;
416 	default:
417 		{
418 			ErrorLn("跨区副本保姆有一个跨服撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
419 		}
420 		break;

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MatchServer\EctypeAssist.cpp 78 KB CPP 文件 2014/2/25 0:08:47 2018/10/23 20:06:22 2018/10/23 20:06:22 1
632 	// 调式代码
633 	char szBuf[512]={0};
634 	sprintf_s(szBuf,sizeof(szBuf), "CEctypeAssist::HandleBridgeMessage()  跨服 服务器撮合信息子消息:来源游戏世界ID=%d,来源服务器ID=%d,子消息代码=%d,len=%d,用户数据=%d,%d,%d",
635 		bridgeHead.dwWorldID,bridgeHead.dwServerID,pMsg->dwMsgCode,len,pMsg->dwUserData1,pMsg->dwUserData2,pMsg->dwUserData3);
636 	TraceLn(szBuf);

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcClient\Client\MatchClient\EctypeAssist.cpp 2 KB CPP 文件 2014/2/25 8:34:42 2018/10/23 19:52:17 2018/10/23 19:52:17 1
76 	default:
77 		{
78 			ErrorLn("跨服组队撮合系统有一个客户端撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
79 		}
80 		break;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\MatchService\EctypeAssist.cpp 22 KB CPP 文件 2014/2/25 14:31:37 2018/10/23 19:46:42 2018/10/23 19:46:42 3
221 			ostrbuf osb;
222 			ostrbuf link;
223 			link << "<a color='#FF00FF00' href=\"" << "Z?17&2" << pEctypeTeam->dwEctypeType << "&" <<"\"> 点击进行跨服副本";
224 			osb << "<rich color='#FF12E4E4'>" << szWorldName << "区<rich color='FFFFFFFF'>的<rich color='#FF12E4E4'>" << first.szName << "<rich color='FFFFFFFF'>通过<rich color='#FF12E4E4'>跨服副本系统<rich color='FFFFFFFF'>成功进入<rich color='#FF12E4E4'>" << pScheme->szName << "　" << link << "<rich color='default'>";
226 			DWORD arrWorldID[256] = {0};
227 			DWORD dwCount = 0;
416 	default:
417 		{
418 			ErrorLn("跨区副本保姆有一个跨服撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
419 		}
420 		break;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MatchServer\EctypeAssist.cpp 78 KB CPP 文件 2014/2/25 14:27:02 2018/10/23 19:45:10 2018/10/23 19:45:10 1
632 	// 调式代码
633 	char szBuf[512]={0};
634 	sprintf_s(szBuf,sizeof(szBuf), "CEctypeAssist::HandleBridgeMessage()  跨服 服务器撮合信息子消息:来源游戏世界ID=%d,来源服务器ID=%d,子消息代码=%d,len=%d,用户数据=%d,%d,%d",
635 		bridgeHead.dwWorldID,bridgeHead.dwServerID,pMsg->dwMsgCode,len,pMsg->dwUserData1,pMsg->dwUserData2,pMsg->dwUserData3);
636 	TraceLn(szBuf);

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcClient\Client\MatchClient\EctypeAssist.cpp 2 KB CPP 文件 2014/2/25 13:44:49 2018/10/23 19:34:25 2018/10/23 19:34:25 1
76 	default:
77 		{
78 			ErrorLn("跨服组队撮合系统有一个客户端撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
79 		}
80 		break;

I:\work\source\神魔传奇\[src.cool]神魔传奇代码\Server\ScenesServer\DynamicScene.cpp 27 KB CPP 文件 2012/1/17 23:01:19 2018/10/23 13:18:01 2018/10/23 13:18:01 1
432 	//pUser->charbase.mapid = tempid;//地图ID
433 	//strcpy( pUser->charbase.mapName,((std::string)GetMapName()).c_str());
435 	//Zebra::logger->info("%s(%d)跨服切换场景(%s-->%s)",pUser->name,pUser->id,pUser->scene->name,pUser->charbase.mapName);
436 	//pUser->charbase.x = _TargetPos.x;
437 	//pUser->charbase.y = _TargetPos.y;

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\MatchService\DummyServiceData.cpp 43 KB CPP 文件 2014/2/25 0:22:59 2018/10/23 20:09:03 2018/10/23 20:09:03 1
1509 void CDummyServiceData::UpdateAllDummyMemberData(DWORD dwServerID)
1510 {
1511 	// 取得跨服组队撮合系统服务
1512 	IMatchService *pMatchService = gGlobalSocialServer->GetMatchService();
1513 	if (pMatchService == NULL)

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\MatchService\DummyServiceData.cpp 43 KB CPP 文件 2014/2/25 14:31:37 2018/10/23 19:46:41 2018/10/23 19:46:41 1
1509 void CDummyServiceData::UpdateAllDummyMemberData(DWORD dwServerID)
1510 {
1511 	// 取得跨服组队撮合系统服务
1512 	IMatchService *pMatchService = gGlobalSocialServer->GetMatchService();
1513 	if (pMatchService == NULL)

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MatchServer\DummyServer.cpp 23 KB CPP 文件 2014/2/25 0:08:46 2018/10/23 20:06:22 2018/10/23 20:06:22 2
763 	// 调式代码
764 	char szBuf[512]={0};
765 	sprintf_s(szBuf,sizeof(szBuf), "CStrikeServer::HandleBridgeMessage()  跨服挑战假人系统服务器撮合信息子消息:来源游戏世界ID=%d,来源服务器ID=%d,子消息代码=%d,len=%d,用户数据=%d,%d,%d",
766 		bridgeHead.dwWorldID,bridgeHead.dwServerID,pMsg->dwMsgCode,len,pMsg->dwUserData1,pMsg->dwUserData2,pMsg->dwUserData3);
767 	TraceLn(szBuf);
776 	default:
777 		{
778 			ErrorLn("挑战假人系统系统有一个跨服撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
779 		}
780 		break;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MatchServer\DummyServer.cpp 23 KB CPP 文件 2014/2/25 14:27:01 2018/10/23 19:45:10 2018/10/23 19:45:10 2
763 	// 调式代码
764 	char szBuf[512]={0};
765 	sprintf_s(szBuf,sizeof(szBuf), "CStrikeServer::HandleBridgeMessage()  跨服挑战假人系统服务器撮合信息子消息:来源游戏世界ID=%d,来源服务器ID=%d,子消息代码=%d,len=%d,用户数据=%d,%d,%d",
766 		bridgeHead.dwWorldID,bridgeHead.dwServerID,pMsg->dwMsgCode,len,pMsg->dwUserData1,pMsg->dwUserData2,pMsg->dwUserData3);
767 	TraceLn(szBuf);
776 	default:
777 		{
778 			ErrorLn("挑战假人系统系统有一个跨服撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
779 		}
780 		break;

I:\work\source\书剑恩仇录\书剑恩仇录_zccode.com\书剑恩仇录\金\Src\MapServer\Server\Messages\CXUseItemDispatch.cpp 8 KB CPP 文件 2013/3/3 13:59:44 2018/10/23 13:34:41 2018/10/23 13:34:41 1
115 			(int32)pPlayer->GetInherenceLevel() >= pBagItem->GetReqInherenceLevel() && pPlayer->GetLevel() >= pBagItem->GetReqPersonLevel()))
116 	{
117 // 		by rj 2010-10-20 对跨服场景使用物品进行许可限制 
118 // 				if (g_Config.m_MultiGroupConfig.m_nGroupCount > 0)
119 // 				{

I:\work\source\书剑恩仇录\[src.cool]书剑恩仇录\Src\MapServer\Server\Messages\CXUseItemDispatch.cpp 8 KB CPP 文件 2013/3/3 13:59:44 2018/10/23 13:34:24 2018/10/23 13:34:24 1
115 			(int32)pPlayer->GetInherenceLevel() >= pBagItem->GetReqInherenceLevel() && pPlayer->GetLevel() >= pBagItem->GetReqPersonLevel()))
116 	{
117 // 		by rj 2010-10-20 对跨服场景使用物品进行许可限制 
118 // 				if (g_Config.m_MultiGroupConfig.m_nGroupCount > 0)
119 // 				{

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\EntityServer\CreatureCommonPart.cpp 128 KB CPP 文件 2014/2/25 0:06:56 2018/10/23 20:04:27 2018/10/23 20:04:27 2
3197 			{
3198 				// 其它游戏的角色
3199 				// 取得跨服组队撮合服务器
3200 				IMatchServer * pMatchServer = gZoneServiceProvider->GetMatchServer();
3201 				if (pMatchServer==NULL)
3316 			{
3317 				//// 其它游戏的角色
3318 				//// 取得跨服组队撮合服务器
3319 				//IMatchServer * pMatchServer = gZoneServiceProvider->GetMatchServer();
3320 				//if (pMatchServer==NULL)

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\EntityServer\CreatureCommonPart.cpp 128 KB CPP 文件 2014/2/25 14:24:41 2018/10/23 19:43:42 2018/10/23 19:43:42 2
3197 			{
3198 				// 其它游戏的角色
3199 				// 取得跨服组队撮合服务器
3200 				IMatchServer * pMatchServer = gZoneServiceProvider->GetMatchServer();
3201 				if (pMatchServer==NULL)
3316 			{
3317 				//// 其它游戏的角色
3318 				//// 取得跨服组队撮合服务器
3319 				//IMatchServer * pMatchServer = gZoneServiceProvider->GetMatchServer();
3320 				//if (pMatchServer==NULL)

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MatchServer\CountryWar.cpp 208 KB CPP 文件 2014/2/25 0:08:44 2018/10/23 20:06:22 2018/10/23 20:06:22 109
5 ** 日  期:	2011-2-11
6 ** 版  本:	1.0
7 ** 描  述:	跨服竞技系统
8 ** 应  用:  	
9 	
135 	memset(m_kingInfoList, 0, sizeof(m_kingInfoList));
137 	m_nStoneBrushID			= 0;		// 采集晶石 活动实例ID  创建后 需要保存起来 关闭时需要.
138 	m_dwTaskWorldWarID		= 0;		// 跨服国战信息ID，0为无效ID
139 	m_dwTaskPublicWorldID	= 0;		// 所属公共区世界ID
140 	m_dwBalanceKey			= CoutryWarBalanceDefaultKey;		// 平衡BUFF键值
237 	if (pSiegeWarServer != NULL)
238 	{
239 		// 设置跨服国战奖励倍率，因为跨服国战是开始时创建类，如果要设置倍率需在跨服开始后设置倍率
240 		// 太麻烦，而且还要人工操作。所以和国战绑定倍率
241 		pSiegeWarServer->GetSiegeWarActivityBase(m_fTicketBase, m_fExpOrCreditBase, m_nGoodsGiftBase);
308 	if (bRet)
309 	{
310 		// 强制性设置 跨服进入PVP类型
311 		pStrikeInfo->nEnterType = PVPClassType_War;
313 		// 重置玩家在踢人队列中的标识
502 	DWORD dwMaxOnline = 0;
503 	memcpy(&dwMaxOnline, nCampMaxOnline, sizeof(DWORD));
505 	// 跨服国战进行状态变化
506 	g_pMatchServer->GetWarServerInstance().OnCountryWarRunStepChanged(this,m_dwWarRunStep,dwUserData,dwMaxOnline,dwBossHP);
508 	// 同步回本区更新状态备本区玩家知晓国战状态 国战执行状态子类型变化
828 			if (AddPersonSore((*pNode) ,WarScore_KillPerson, dwAddScore))
829 			{
830 				sprintf_s(szMsgBuf, sizeof(szMsgBuf), "跨服国战击败玩家[%s]，获得积分%d点",pDeadPerson->GetName(), dwAddScore);
831 				SendSystemTips(TipType_PVP, dwPlayerID, InfoPos_ActorRight|InfoPos_ChatWindow,szMsgBuf);
832 			}
859 			if (nExploit>0)
860 			{
861 				pCountryEntityPart->AddCountryExploit(COUNTRY_EXPLOIT_TYPE_KILL,nExploit,OssResAdd_CountryWar,"跨服国战获取杀人功勋",false);
862 			}
863 			//  增加政绩
864 			if (nCbsScore > 0)
865 			{
866 				pCountryEntityPart->AddCountryContribute(COUNTRY_CONTRIBUTE_TYPE_KILL,nCbsScore,OssResAdd_CountryWar,"跨服国战获取杀人政绩",false);
867 			}
868 			//  增加本周政绩
869 			if (nCbsScore > 0)
870 			{
871 				pCountryEntityPart->AddCountryHonour(COUNTRY_HONOUR_TYPE_KILL,nCbsScore,OssResAdd_CountryWar,"跨服国战获取杀人本周政绩",false);
872 			}
873 		}
1002 			// 处理玩家补偿
1003 			DWORD dwAddMoney	= 0;				// 给绑金补偿数量
1004 			bool bFinishTask	= false;			// 是否自动替玩家完成跨服国战任务
1005 			char szMsg[512] = {0};
1006 			DWORD dwSystemMoney = (DWORD)m_WarSchemeInfo.nSpare6;		// 战场补偿数量 绑金，0.不处理
1012 				if (pPlaza!=NULL)
1013 				{
1014 					bool bFlag = pPlaza->AddBindTickets(pPerson,dwSystemMoney,OssResAdd_CountryWar,"跨服国战被传出获得绑定金币补偿",0,0);
1015 					// 增加绑金成功
1016 					if (bFlag)
1020 						dwAddMoney = dwSystemMoney;
1022 						// 发送消息给客户端
1023 						sprintf_s(szMsg, sizeof(szMsg), "<rich color='#FFFF80FF'>跨服国战被传出获得绑定金币补偿：%d<rich color='default'>", dwSystemMoney);
1024 						SendSystemTips(TipType_PVP, pPerson->GetNumProp(CREATURE_PROP_PDBID), InfoPos_ActorUnder|InfoPos_ChatWindow,szMsg);
1025 					}
1026 				}
1027 			}
1029 			// 没有完成任务，系统自动设置玩家任务完成，由于玩家可延迟接跨服国战任务
1030 			ILuaEngine * pLuaEngine = gZoneServiceProvider->GetLuaEngine();
1031 			if(NULL != pLuaEngine)
1050 				if (1==nOutVal1 || 1==nOutVal2)
1051 				{
1052 					// 设置自动替玩家完成跨服国战任务
1053 					bFinishTask = true;
1053 					bFinishTask = true;
1055 					sprintf_s(szMsg, sizeof(szMsg), "<rich color='#FFFF80FF'>跨服国战被传出补偿：本次所接的跨服国战任务将自动完成<rich color='default'>");
1056 					// 发送消息给客户端
1057 					SendSystemTips(TipType_PVP, pPerson->GetNumProp(CREATURE_PROP_PDBID), InfoPos_ActorUnder|InfoPos_ChatWindow,szMsg);
1069 				{
1070 					char szBuf[256] = {0};
1071 					sprintf_s(szBuf, sizeof(szBuf), "跨服国战被传出获得绑定金币补偿：%d", dwAddMoney);
1072 					strMoney = szBuf;
1073 				}
1074 				if (bFinishTask)
1075 				{
1076 					strTask = "跨服国战被传出补偿：本次所接的跨服国战任务自动完成";
1077 				}
1078 				// 发送到客户端
1361 	// 发送玩家获取积分事件
1362 	SEventMatchCountryWarGetScore_S eventData;
1363 	eventData.dwPVPClassType	= GetPVPClass()->GetClass();					// 跨服PVP类型 EMPVPClassType
1364 	eventData.dwWarID			= GetID();										// 相关战场ID
1365 	eventData.uidPlayer			= playerNode.uidPlayer;							// 玩家UID
1386 		{
1387 			CLuaParam param[5];
1388 			param[0] = eventData.dwPVPClassType;						//	跨服PVP类型 EMPVPClassType
1389 			param[1] = eventData.dwWarID;								//	相关战场ID
1390 			param[2] = ANALYZEUID_SERIALNO(eventData.uidPlayer);		//	玩家序列号
1609 	sendData.dwDefWorldID	= m_countryWarInfo.dwDefWorldID;		// 防守方世界ID
1610 	sendData.dwDefCountryID	= m_countryWarInfo.dwDefCountryID;		// 防守方国家ID
1613 	// 发跨服撮合信息消息 dwServerID:服务器ID ,跨服信息专用
1614 	return g_pMatchServer->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_RequestKqWarCall,dwCountryID,0,0,(const char *)&sendData,sizeof(sendData));
1615 }
1674 	}
1676 	char szMsg[512] = {0};
1677 	sprintf_s(szMsg, sizeof(szMsg), "跨服国战攻破城门，获得积分%d点", dwGateScore);	
1679 	// 攻方阵营添加积分
1680 	AddCampPlayersScore(CountryWarCamp_Attack, WarScore_KillPerson, dwGateScore, szMsg);
1799 		// 增加经验
1800 		pPerson->SetNumProp(CREATURE_PROP_EXP, dwAddExp, true);
1801 		pOSSLogServer->TrackAddExp(dwPlayerID, 0, dwAddExp, OssResAdd_CountryWar, 0, "跨服国战第一个占领敌国封印经验奖励");
1803 		sprintf_s(szMsg, sizeof(szMsg), "跨服国战占领敌国封印，增加经验：%d", dwAddExp);
1804 		SendSystemTips(TipType_PVP, dwPlayerID, InfoPos_ActorUnder|InfoPos_ChatWindow,szMsg);
1805 	}
1850 			// 设置玩家所得共享经验
1851 			pCampPerson->SetNumProp(CREATURE_PROP_EXP, dwShareExp, true);
1852 			pOSSLogServer->TrackAddExp(playerNode.dwPlayerID, 0, dwShareExp, OssResAdd_CountryWar, 0, "跨服国战占领第一个封印分享奖励");
1854 			sprintf_s(szMsg, sizeof(szMsg), "跨服国战中占领敌国封印时分享所得经验：%d", dwShareExp);
1855 			SendSystemTips(TipType_PVP, playerNode.dwPlayerID, InfoPos_ActorUnder|InfoPos_ChatWindow,szMsg);
1856 		}
1936 		// 增加经验
1937 		pPerson->SetNumProp(CREATURE_PROP_EXP, dwAddExp, true);
1938 		pOSSLogServer->TrackAddExp(playerNode.dwPlayerID, 0, dwAddExp, OssResAdd_CountryWar, 0, "跨服国战击杀天师经验奖励");
1940 		// 广播提示
1940 		// 广播提示
1941 		sprintf_s(szMsg, sizeof(szMsg), "跨服国战击杀天师奖励，增加经验：%d", dwAddExp);
1942 		SendSystemTips(TipType_PVP, playerNode.dwPlayerID, InfoPos_ActorUnder|InfoPos_ChatWindow,szMsg);
1943 	}
1973 	DWORD dwScore = (DWORD)(g_pMatchServer->GetWarConfigNumber(WarCfgNum_Coutry_GunAddScore));		// 一个大炮，多少积分（攻方）
1975 	// 发送消息信息
1976 	sprintf_s(szBuf, sizeof(szBuf), "跨服国战击杀神武大炮，获得积分%d点", dwScore);	
1978 	// 守方阵营增加积分
1979 	AddCampPlayersScore(CountryWarCamp_Attack,WarScore_KillPerson,dwScore,szBuf);
2021 	if (bAdded)
2022 	{
2023 		sprintf_s(szMsg, sizeof(szMsg), "跨服国战采集晶石，获得积分%d点", dwStnAddScore);	
2024 		SendSystemTips(TipType_PVP, pPlayerNode->dwPlayerID, InfoPos_ActorUnder|InfoPos_ChatWindow,szMsg);
2025 	}
2051 	{
2052 		// 天师血量提示
2053 		sprintf_s(szMsg, sizeof(szMsg), "跨服国战采集晶石，扣除【天师】血量%d点", dwAddHP);	
2055 		// 产生一个伤害效果
2056 		DamageCalcContext damageccontext;
2066 	{
2067 		// 天师血量提示
2068 		sprintf_s(szMsg, sizeof(szMsg), "跨服国战采集晶石，增加【天师】血量%d点", dwAddHP);	
2070 		// 天师固有的免疫BUFF会挡住手动加血，所以要先移除天师身上的BUFF，手工加血后再附上固有的BUFF
2072 		//// 取得BUFF信息
2145 		if (bAdded)
2146 		{
2147 			sprintf_s(szMsg, sizeof(szMsg), "跨服国战击杀补给车，获得积分%d点", dwKillTankScore);	
2148 			SendSystemTips(TipType_PVP, pPlayerNode->dwPlayerID, InfoPos_ActorUnder|InfoPos_ChatWindow,szMsg);
2149 		}
2220 			if (AddPersonSore((*pNode) ,WarScore_KillTank, dwAddScore))
2221 			{
2222 				sprintf_s(szMsg, sizeof(szMsg), "跨服国战击杀补给车，获得积分%d点", dwAddScore);	
2223 				SendSystemTips(TipType_PVP, pNode->dwPlayerID, InfoPos_ActorUnder|InfoPos_ChatWindow,szMsg);
2224 			}
2269 	char szMsg[512] = {0};
2270 	// 发送消息信息
2271 	sprintf_s(szMsg, sizeof(szMsg), "跨服国战击杀攻方战车，获得积分%d点", dwScore);	
2273 	// 守方阵营增加积分
2274 	AddCampPlayersScore(CountryWarCamp_Defend,WarScore_KillPerson,dwScore,szMsg);
2821 /** 资源事件执行接口
2822 @param   WORD wEventID		:事件ID
2823 @param   WORD dwPVPClassType:跨服PVP类型 EMPVPClassType
2824 @param   WORD dwWarID		:相关战场ID
2825 @param   WORD dwResID		:相关战争资源配置ID
2836 		return;
2837 	}
2839 	// 跨服PVP类型不一致
2840 	if (dwPVPClassType != GetPVPClass()->GetClass())
2841 	{
2840 	if (dwPVPClassType != GetPVPClass()->GetClass())
2841 	{
2842 		ErrorLn("CCountryWar::OnWarResEvent() 跨服PVP类型不一致 dwPVPClassType("<< dwPVPClassType << ") != GetClass("<< GetPVPClass()->GetClass() <<")");
2843 		return;
2844 	}
3023 /** 资源投票事件
3024 @param   WORD wEventID		:事件ID
3025 @param   WORD dwPVPClassType:跨服PVP类型 EMPVPClassType
3026 @param   WORD dwWarID		:相关战场ID
3027 @param   WORD dwResID		:相关战争资源配置ID
3038 		return false;
3039 	}
3041 	// 跨服PVP类型不一致
3042 	if (dwPVPClassType != GetPVPClass()->GetClass())
3043 	{
3042 	if (dwPVPClassType != GetPVPClass()->GetClass())
3043 	{
3044 		ErrorLn("CCountryWar::OnWarResVote() 跨服PVP类型不一致 dwPVPClassType("<< dwPVPClassType << ") != GetClass("<< GetPVPClass()->GetClass() <<")");
3045 		return false;
3046 	}
3144 			if (dwNowTicks>=GetWarTimeData(CountryWarTime_Broadcast)+dwTimeArray[i][1])
3145 			{
3146 				sprintf_s(szAttMsg, sizeof(szAttMsg), "<rich color=#FFFF0000>跨服国战[进攻%s]将于%s后开始<rich color=default>", m_WarCamp[CountryWarCamp_Defend].szName,g_ExternalFacade.GetRemainTimeString(dwDiffTime));
3147 				sprintf_s(szDefMsg, sizeof(szDefMsg), "<rich color=#FFFF0000>跨服国战[抵御%s]将于%s后开始<rich color=default>", m_WarCamp[CountryWarCamp_Attack].szName,g_ExternalFacade.GetRemainTimeString(dwDiffTime));
3149 				// 广播开战信息到参战国
3150 				WorldBroadcastWarTips(TipType_PVP,ChatChannel_Nation, InfoPos_ActorUnder, szAttMsg, szDefMsg);
3156 		}
3157 	}
3159 	// 创建及开战5分钟前发送一次跨服国战传送连接信息
3160 	if (GetRunStepData(CountryWarRunStep_Ready)== 0 || (dwDiffTime==300 && GetWarTimeData(CountryWarTime_LinkBroad)==0))
3161 	{	
3166 		else
3167 		{
3168 			// 设定发送跨服国战信息时间
3169 			SetWarTimeData(CountryWarTime_LinkBroad,1);
3170 		}
3174 		ostrbuf link;
3176 		link << "<a color='#FF00FF00' href=\"Z?19&2"<<GetRoomID()<<","<<dwNowTicks<<"&\">点击参加";
3177 		osbAttack << "<rich color='#FFFF0000'>跨服国战[进攻"<<m_WarCamp[CountryWarCamp_Defend].szName<<"]即将开始,<img src=\"set:MatchStrike image:StrikeKill\">"<<link<<"<rich color='default'>";
3178 		osbDefend << "<rich color='#FFFF0000'>跨服国战[抵御"<<m_WarCamp[CountryWarCamp_Attack].szName<<"]即将开始,<img src=\"set:MatchStrike image:StrikeKill\">"<<link<<"<rich color='default'>";
3180 		WorldBroadcastWarTips(TipType_PVP,ChatChannel_Nation, InfoPos_ChatWindow, osbAttack.c_str(), osbDefend.c_str());
3181 	}
3237 			{
3238 				// 发送提示
3239 				sprintf_s(szMsg, sizeof(szMsg), "跨服国战已结束请尽快离开，还剩%s将关闭战场",g_ExternalFacade.GetRemainTimeString(dwDiffTime));
3240 				SendSystemTips(TipType_PVP, 0, InfoPos_ActorRight,szMsg);
3242 				// 重设发送时间
3420 		{
3421 			m_nBossInitMaxHP = 0;
3422 			ErrorLn("跨服国战中竟然找不到主力天师？？？？");
3423 		}
3424 		else
3520 	// 全区广播国战结果
3521 	ostrbuf osbTips;
3522 	osbTips << "<rich color='#FFFF0000'>跨服国战开始了["<<m_WarCamp[CountryWarCamp_Attack].szName<<"进攻"<<m_WarCamp[CountryWarCamp_Defend].szName<<"]<rich color='default'>";
3523 	g_ExternalFacade.BroadcastWorldSystemTips(0,TipType_PVP, 0, ChatChannel_System, InfoPos_ChatWindow|InfoPos_ScreenTopLarge,osbTips.c_str());
3523 	g_ExternalFacade.BroadcastWorldSystemTips(0,TipType_PVP, 0, ChatChannel_System, InfoPos_ChatWindow|InfoPos_ScreenTopLarge,osbTips.c_str());
3525 	// 跨服发送消息
3526 	ostrbuf osbAttack;
3527 	ostrbuf osbDefend;
3529 	// 发送已开战消息到开战国
3530 	link << "<a color='#FF00FF00' href=\"Z?19&2"<<GetRoomID()<<","<<dwNowTicks<<"&\">点击参加";
3531 	osbAttack << "<rich color='#FFFF0000'>跨服国战[进攻"<<m_WarCamp[CountryWarCamp_Defend].szName<<"]开始了<img src=\"set:MatchStrike image:StrikeKill\">"<<link<<"<rich color='default'>";
3532 	osbDefend << "<rich color='#FFFF0000'>跨服国战[抵御"<<m_WarCamp[CountryWarCamp_Attack].szName<<"]开始了<img src=\"set:MatchStrike image:StrikeKill\">"<<link<<"<rich color='default'>";
3533 	WorldBroadcastWarTips(TipType_PVP,ChatChannel_Nation,InfoPos_ChatWindow,osbAttack.c_str(), osbDefend.c_str());
3534 }
3564 	if (dwBaseCount==0 || dwLBoundCount==0 || dwHBoundCount==0 || dwLBoundRate==0 || dwHBoundRate==0 || dwRecalcRate==0 || dwCountPowRate==0 || dwRatePowRate==0 || dwBaseCount<=dwLBoundCount || dwBaseCount>=dwHBoundCount)
3565 	{
3566 		ErrorLn("跨服国战重新设置天师数值没有正常配置");
3567 		return;
3568 	}
3663 	if (m_fLastChangeRate<0.000001 || ( fLCRate > 0.95 && fLCRate<1.05 ) )
3664 	{
3665 		sprintf_s(szMsgBuf, sizeof(szMsgBuf), "跨服国战变化小百分之五忽略调天师血量，当前要调节系数=%.2f，最后调节系数=%.2f", fChangeRate, m_fLastChangeRate);
3666 		ErrorLn(szMsgBuf);
3667 		return;
3699 	int nNewMaxHp = pMonster->GetNumProp(CREATURE_PROP_MAX_HP);		// 最大血量
3700 	int nNewCurHp = pMonster->GetNumProp(CREATURE_PROP_CUR_HP);		// 当前血量
3702 	sprintf_s(szMsgBuf, sizeof(szMsgBuf), "跨服国战动态天师血量设置 旧（CurHP=%d, MaxHP=%d）， 新（AddHP=%d, AddMaxHP=%d, CurHP=%d, MaxHP=%d）,攻（%s, 人数=%d）,守（%s, 人数=%d）,人数指数（val=%.2f,newVal=%.2f）,比例指数（val=%.2f,newVal=%.2f）",
3703 		nCurHp,nMaxHp, nSetCurHP,nSetMaxHP,nNewCurHp,nNewMaxHp,
3704 		m_WarCamp[CountryWarCamp_Attack].szName,dwAttackMemberCount,m_WarCamp[CountryWarCamp_Defend].szName,dwDefendMemberCount,
3742 	// 参战国积分列表,游戏世界ID做索引
3743 	TMAP_CountryWarCountryScoreList mapCountryScoreList;
3746 	// 跨服国战个人获取奖励信息,以角色ID为键值
3747 	map<DWORD, SWorldCountryWarPrizeInfo>	mapWarPrizeInfo;
3748 	for(DWORD i=0; i<m_WarCamp.size(); i++)
3759 		}
3760 	}
3762 	SWorldCountryWarLogInfo addNode;			// 跨服国战日志
3763 	SWorldCountryWarResultInfo warResultInfo;	// 发送到客户端的跨服国战日志信息
3765 	// 取得获胜阵营
3766 	for (DWORD i=0; i<m_WarCamp.size(); i++)
3976 		if (clanSortNode.dwScoreTotal > 0 && clanSortNode.dwCampIndex<CountryWarCamp_MaxID)
3977 		{
3978 			// 跨服国战信息日志排名节点信息
3979 			if (dwClanCounts < COUNTRY_WARORDERLOG_MAXCOUNT)
3980 			{
4019 					if (dwAddClanMoney > 0)
4020 					{
4021 						sprintf_s(szMsg, sizeof(szMsg), "<rich color='#FFFF80FF'>跨服国战本帮会增加奖励资金：%s<rich color='default'>", MoneyToString(dwAddClanMoney));
4022 						SendSystemTips(TipType_PVP, playerNode.dwPlayerID, InfoPos_ActorUnder|InfoPos_ChatWindow,szMsg);
4023 					}
4034 					if (nCreditNum > 0)
4035 					{
4036 						pCreditPart->InCreditValue(ECreditSubID_Bhsw, nCreditNum, "跨服国战帮会前10名", OssResAdd_CountryWar);
4037 						// 提示下
4038                         // 梦想版, 帮会声望名称显示为军饷
4039                         if (getGameUserData(GameUserDataType_Ver) == 1)
4040                         {
4041 						    sprintf_s(szMsg, sizeof(szMsg), "<rich color='#FFFF80FF'>跨服国战本帮会排名第%d,你获得军饷奖励：%s<rich color='default'>", dwClanCounts+1, CreditToString(nCreditNum));
4042                         }
4043                         else
4043                         else
4044                         {
4045                             sprintf_s(szMsg, sizeof(szMsg), "<rich color='#FFFF80FF'>跨服国战本帮会排名第%d,你获得声望奖励：%d<rich color='default'>", dwClanCounts+1, nCreditNum);
4046                         }
4047                         // 发送消息给客户端
4074 				sstrcpyn( nodeInfo.szObjectName,szClanName ,sizeof(nodeInfo.szObjectName) );	// 帮会名称
4076 				addNode.clanInfo[dwClanCounts] = nodeInfo;
4078 				// 发送到客户端的跨服国战日志信息
4079 				warResultInfo.clanInfo[dwClanCounts] = nodeInfo;	
4081 				// 排名前10的帮会个数
4132 	if (pPlaza == NULL)
4133 	{
4134 		ErrorLn("跨服国战（"<< m_WarCamp[CountryWarCamp_Attack].szName << " vs "<< m_WarCamp[CountryWarCamp_Defend].szName <<"）：商城服务器pPlaza==NULL！");
4135 	}
4137 	for (TLIST_CountryWarScoreSortList::iterator it=personNodeList.begin(); it!=personNodeList.end();it++)
4239 			if (pPlaza!=NULL)
4240 			{
4241 				bool bFlag = pPlaza->AddBindTickets(pPerson,dwAddMoney,OssResAdd_CountryWar,"跨服国战获得绑定金币奖励",0,0);
4242 				// 增加绑金成功
4243 				if (bFlag)
4244 				{
4245 					// 广播提示
4246 					sprintf_s(szMsg, sizeof(szMsg), "<rich color='#FFFF80FF'>跨服国战增加绑定金币奖励：%d<rich color='default'>", dwAddMoney);
4247 					// 发送消息给客户端
4248 					SendSystemTips(TipType_PVP, dwPlayerID, InfoPos_ActorUnder|InfoPos_ChatWindow,szMsg);
4250 				else	// 增加绑金失败
4251 				{
4252 					sprintf_s(szMsg, sizeof(szMsg), "跨服国战(%s vs %s)给%s[%d]增加绑定金币%d失败", m_WarCamp[CountryWarCamp_Attack].szName,m_WarCamp[CountryWarCamp_Defend].szName, pPerson->GetName(), pPerson->GetNumProp(CREATURE_PROP_PDBID), dwAddMoney);
4253 					ErrorLn(szMsg);
4254 				}
4268 			// 经验奖励异常个数
4269 			dwWarningExp++;
4270 			sprintf_s(szBuf, sizeof(szBuf), "跨服国战奖励,添加经验值数值异常!:奖励经验=%.2f,角色等级=%.2f,等级调节基数=%.2f,经验调节基数1=%.2f,经验调节基数2=%.2f,个人总积分=%.2f,积分系数=%.2f,个人积分榜系数=%.2f",
4271 				fAddExp,fMaxHunLevel,fExpLevelAdjBase,fExpBaseNum1,fExpBaseNum2,fScoreTotal,fExpScoreRate,fPersonScoreRate);
4272 			//报给场景服
4277 		{
4278 			pPerson->SetNumProp(CREATURE_PROP_EXP, dwAddExp, true);
4279 			pOSSLogServer->TrackAddExp(dwPlayerID, 0, dwAddExp, OssResAdd_CountryWar, 0, "跨服国战排名经验奖励");
4280 			// 广播提示
4281 			sprintf_s(szMsg, sizeof(szMsg), "<rich color='#FFFF80FF'>国战排名奖励，增加经验：%d<rich color='default'>", dwAddExp);
4302 		if (personNode.dwScoreTotal > 0)
4303 		{
4304 			// 跨服国战信息日志排名节点信息
4305 			if (dwActorCounts < COUNTRY_WARORDERLOG_MAXCOUNT)
4306 			{
4316 				sstrcpyn( nodeInfo.szObjectName,pPerson->GetName() ,sizeof(nodeInfo.szObjectName) );	// 玩家名称
4318 				addNode.actorInfo[dwActorCounts] = nodeInfo;
4320 				// 发送到客户端的跨服国战日志信息
4321 				warResultInfo.actorInfo[dwActorCounts] = nodeInfo;
4323 				// 排名前10的玩家个数
4343 	DWORD dwAttackDBID = 0;
4344 	DWORD dwDefendDBID = 0;
4346 	// 发送到客户端的跨服国战日志信息
4347 	warResultInfo.dwPlayTime		= dwRunTotalTime;									// 战斗时长(秒)
4347 	warResultInfo.dwPlayTime		= dwRunTotalTime;									// 战斗时长(秒)
4348 	warResultInfo.dwType			= (DWORD)m_WarSchemeInfo.nID;						// 跨服国战类型
4349 	warResultInfo.dwAttackWorldID	= m_countryWarInfo.dwAttWorldID;					// 进攻国家所在游戏世界ID
4350 	warResultInfo.dwAttackCountryID	= m_countryWarInfo.dwAttCountryID;					// 进攻国家ID
4359 	sstrcpyn( warResultInfo.szAttackWorldName, strAttWorldName.c_str(), sizeof(warResultInfo.szAttackWorldName));
4360 	sstrcpyn( warResultInfo.szDefendWorldName, strDefWorldName.c_str(), sizeof(warResultInfo.szDefendWorldName));
4362 	// 新增跨服国战日志数据信息
4363 	addNode.dwID				= GetRoomID()*1000+ getThisGameWorldID() ;			// 跨服国战日志信息ID
4364 	addNode.dwAddTime			= dwNowTime ;										// 跨服国战日志写入时间
4365 	addNode.dwPublicWorldID		= getThisGameWorldID() ;							// 所属公共区世界ID
4366 	addNode.dwStartTime			= m_dwStartTime;									// 开始时间
4366 	addNode.dwStartTime			= m_dwStartTime;									// 开始时间
4367 	addNode.dwPlayTime			= dwRunTotalTime;									// 战斗时长(秒)
4368 	addNode.dwType				= (DWORD)m_WarSchemeInfo.nID;						// 跨服国战类型
4369 	addNode.dwAttackWorldID		= m_countryWarInfo.dwAttWorldID;					// 进攻国家所在游戏世界ID
4370 	addNode.dwAttackCountryID	= m_countryWarInfo.dwAttCountryID;					// 进攻国家ID
4382 	//SWorldCountryWarOrderNodeInfo actorInfo[COUNTRY_WARORDERLOG_MAXCOUNT];	// 排名前10的玩家
4383 	//SWorldCountryWarOrderNodeInfo clanInfo[COUNTRY_WARORDERLOG_MAXCOUNT];		// 排名前10的帮会
4385 	// 进攻方新增跨服国战日志
4386 	addNode.dwResultFlag = ((dwWinCampIndex == CountryWarCamp_Attack) ? 1 : 0);
4387 	pCountryServer->AddWorldCountryWarLog(addNode,addNode.dwAttackWorldID);
4387 	pCountryServer->AddWorldCountryWarLog(addNode,addNode.dwAttackWorldID);
4388 	dwAttackDBID = addNode.dwID;
4390 	// 防守方新增跨服国战日志
4391 	addNode.dwResultFlag = ((dwWinCampIndex == CountryWarCamp_Defend) ? 1 : 0);
4392 	pCountryServer->AddWorldCountryWarLog(addNode,addNode.dwDefendWorldID);
4397 	// 更新国战场战斗结果信息到本区社会服
4398 	SendWorldWarResultToSocial(m_countryWarInfo.dwDefWorldID,m_countryWarInfo.dwDefCountryID, (dwWinCampIndex == CountryWarCamp_Defend),m_WarCamp[CountryWarCamp_Defend].dwMaxOnline);
4400 	// 本次跨服国战写入国家历史信息
4401 	ostrbuf strTitle,strHtml;
4402 	// 国王名称 m_WarCamp[CountryWarCamp_Attack].szName
4558 			// 国战战场玩家获取奖励
4559 			SEventMatchCountryWarAddPrize_S eventData;
4560 			eventData.dwPVPClassType	= GetPVPClass()->GetClass();					// 跨服PVP类型 EMPVPClassType
4561 			eventData.dwWarID			= GetID();										// 相关战场ID
4562 			eventData.uidPlayer			= playerNode.uidPlayer;							// 玩家UID
4639 	// 全区广播国战结果
4640 	ostrbuf osbTips;
4641 	osbTips << "<rich color='#FFFF0000'>跨服国战:"<<m_WarCamp[CountryWarCamp_Attack].szName<<"进攻"<<m_WarCamp[CountryWarCamp_Defend].szName<< (dwWinCampIndex==CountryWarCamp_Attack?"胜利":"失败")<<"<rich color='default'>";
4642 	g_ExternalFacade.BroadcastWorldSystemTips(0,TipType_PVP, 0, ChatChannel_System, InfoPos_ChatWindow|InfoPos_ScreenTopLarge,osbTips.c_str());
4644 	// 全区广播国战结果
4655 		sprintf_s(szTimestr,sizeof(szTimestr),"[%.2d:%.2d分]",local_time.tm_hour,local_time.tm_min);
4656 		osbTips.clear();
4657 		osbTips << "<rich color='#FF80FF'>跨服国战:复仇的天师将会在"<<szTimestr<<"到达"<<pWinName<<"的青龙城,将其击杀将有丰厚奖励<rich color='default'>";
4658 		if( isPublicGameWorld() == true)
4659 		{
4666 	// 国战战场结束结果
4667 	SEventMatchCountryWarResult_S eventData;
4668 	eventData.dwPVPClassType		= GetPVPClass()->GetClass();	// 跨服PVP类型 EMPVPClassType
4669 	eventData.dwWarID				= GetID();						// 相关战场ID
4670 	eventData.nWinCampID			= (BYTE)dwWinCampIndex+1;		// 获胜方阵营ID
4684 	{
4685 		ostrbuf buffer;
4686 		buffer << "跨服国战奖励,添加经验值数值异常报警!  经验异常玩家数量 ="<<dwWarningExp << ", 请查看场景服信息";
4687 		//  玩家举报信息给GM消息数据结构
4688 		SMsgReportToGMInfo sendData;
4690 		sendData.dwReasonFlag		= Chat_ReportToGMReason_Other;							// 原因标识  ChatReportToGMReasonFlag
4691 		sendData.strTitle			= buffer.str();											// 举报证据（最大长度和聊天内容长短一致）
4692 		sendData.strMsg				= "跨服国战场景服自动举报";								// 附加说明
4693 		pChatServer->SendReportToGMClient(0,sendData);
4695 		//报给维护!
4798 	{
4799 		CLuaParam param[5];
4800 		param[0] = GetPVPClass()->GetClass();					//	跨服PVP类型 EMPVPClassType
4801 		param[1] = GetID();										//	相关战场ID
4803 		DWORD dwTotalScore = 0;
5021 			sendData.strCheaterName		= pSrcPerson->GetName();									// 举报对象角色名
5022 			sendData.strTitle			= buffer.str();												// 举报证据（最大长度和聊天内容长短一致）
5023 			sendData.strMsg				= "跨服国战场景服自动举报";										// 附加说明
5024 			
5025 			pChatServer->SendReportToGMClient(0,sendData);
5047 			return false;
5048 		}
5049 		// 发跨服取得攻方国王信息 dwServerID:服务器ID ,跨服信息专用
5050 		g_pMatchServer->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_RequestKingInfo,GetID(),m_countryWarInfo.dwAttWorldID,m_countryWarInfo.dwAttCountryID);
5052 		// 取得守方游戏世界的社会服
5056 			return false;
5057 		}
5058 		// 发跨服取得守方国王信息 dwServerID:服务器ID ,跨服信息专用
5059 		return g_pMatchServer->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_RequestKingInfo,GetID(),m_countryWarInfo.dwDefWorldID,m_countryWarInfo.dwDefCountryID);
5060 	}
5269 			// 调用LUA，处理玩家杀人
5270 			CLuaParam param[6];
5271 			param[0] = GetPVPClass()->GetClass();					// 跨服PVP类型 EMPVPClassType
5272 			param[1] = GetID();										// 相关战场ID
5273 			param[2] = ANALYZEUID_SERIALNO(uidPlayer);				// 凶手
5284 		// 调用LUA，处理玩家杀人
5285 		CLuaParam param[6];
5286 		param[0] = GetPVPClass()->GetClass();					// 跨服PVP类型 EMPVPClassType
5287 		param[1] = GetID();										// 相关战场ID
5288 		param[2] = ANALYZEUID_SERIALNO(killerNode.uidPlayer);	// 凶手
5352 DWORD CCountryWar::GetKickOutTime(void)
5353 {
5354 	return (DWORD)m_WarSchemeInfo.nSpare1;		// 跨服国战被踢玩家场内滞留时间（秒）
5355 }
5357 // 发送国战战场创建信息到参战游戏区的所有场景服
5488 	return true;
5489 }
5491 // 跨服发送消息
5492 void CCountryWar::WorldBroadcastWarTips(DWORD nTipType, DWORD nChannelType, DWORD nInfoPos,const char * pAttackTips, const char * pDefendTips)
5493 {
5572 		return false;
5573 	}
5575 	// 发跨服撮合信息消息 dwServerID:服务器ID ,跨服信息专用
5576 	return g_pMatchServer->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_SendWorldWarResult,dwCountryID,(bIsWin?1:0),dwWarOnline);
5577 }
5598 		return false;
5599 	}
5601 	// 发跨服撮合信息消息 dwServerID:服务器ID ,跨服信息专用
5602 	return g_pMatchServer->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_RequestAddClanGold,dwWorldID,dwClanID,dwMoney);
5603 }
5624 		return false;
5625 	}
5627 	// 发跨服撮合信息消息 dwServerID:服务器ID ,跨服信息专用
5628 	return g_pMatchServer->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_SendCountryWarScore,dwWorldID,dwCountryID,dwWarScore);
5629 }
6041 		return;
6042 	}
6044 	// 取得跨服组队撮合服务器
6045 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
6046 	if (pMatchServer == NULL)

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcClient\Client\MatchClient\CountryWar.cpp 13 KB CPP 文件 2014/2/25 8:34:41 2018/10/23 19:52:17 2018/10/23 19:52:17 9
242 	return true;
243 }
245 /** 取得跨服国战信息结果日志信息
246 @return  跨服国战信息结果日志信息
247 */
248 SWorldCountryWarResultInfo*  CCountryWar::GetWorldCountryWarResultInfo(void)
250 	return &m_warResultInfo;
251 }
253 /** 取得跨服国战信息日志信息的排名节点信息
254 @param  DWORD dwIndex : 序号
255 @param   BYTE dwType: 对象类型	1表示玩家，2表示帮会
254 @param  DWORD dwIndex : 序号
255 @param   BYTE dwType: 对象类型	1表示玩家，2表示帮会
256 @return  查询到的跨服国战信息日志信息排名节点信息
257 */
258 const SWorldCountryWarOrderNodeInfo*  CCountryWar::GetWorldCountryWarLogOrderNodeInfo(DWORD dwIndex,BYTE dwType)
269 }
271 /** 获取本帮帮会积分数据
272 @param DWORD dwScoreID : 跨服国战积分类型ID EMWarScoreFlag  
273 @return
274 */
465 		}
466 		break;
467 	case Match_WarMsg_SendCountryWarResult:		// 更新跨服国战信息结果日志信息到客户端
468 		{
469 			bHasDone = true;
471 			if (nNewlen!=sizeof(SWorldCountryWarResultInfo)+sizeof(SWorldCountryWarPrizeInfo))
472 			{
473 				ErrorLn("收到更新跨服国战信息结果日志信息到客户端数据大小不符，nLen = "<<nNewlen);
474 				break;
475 			}
479 			DWORD dwPlayerID	= dwUserData2;		// 玩家角色ID
480 			DWORD dwCamp		= dwUserData3;		// 玩家阵营序号
482 			// 跨服国战信息结果日志信息
483 			SWorldCountryWarResultInfo	* pInfo			= (SWorldCountryWarResultInfo *)pMsgData;
483 			SWorldCountryWarResultInfo	* pInfo			= (SWorldCountryWarResultInfo *)pMsgData;
484 			// 跨服国战个人获取奖励信息
485 			SWorldCountryWarPrizeInfo	* pPrizeInfo	= (SWorldCountryWarPrizeInfo*)(pMsgData+sizeof(SWorldCountryWarResultInfo));
487 			m_warResultInfo = (* pInfo);

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MatchServer\CountryWar.cpp 208 KB CPP 文件 2014/2/25 14:27:00 2018/10/23 19:45:09 2018/10/23 19:45:09 109
5 ** 日  期:	2011-2-11
6 ** 版  本:	1.0
7 ** 描  述:	跨服竞技系统
8 ** 应  用:  	
9 	
135 	memset(m_kingInfoList, 0, sizeof(m_kingInfoList));
137 	m_nStoneBrushID			= 0;		// 采集晶石 活动实例ID  创建后 需要保存起来 关闭时需要.
138 	m_dwTaskWorldWarID		= 0;		// 跨服国战信息ID，0为无效ID
139 	m_dwTaskPublicWorldID	= 0;		// 所属公共区世界ID
140 	m_dwBalanceKey			= CoutryWarBalanceDefaultKey;		// 平衡BUFF键值
237 	if (pSiegeWarServer != NULL)
238 	{
239 		// 设置跨服国战奖励倍率，因为跨服国战是开始时创建类，如果要设置倍率需在跨服开始后设置倍率
240 		// 太麻烦，而且还要人工操作。所以和国战绑定倍率
241 		pSiegeWarServer->GetSiegeWarActivityBase(m_fTicketBase, m_fExpOrCreditBase, m_nGoodsGiftBase);
308 	if (bRet)
309 	{
310 		// 强制性设置 跨服进入PVP类型
311 		pStrikeInfo->nEnterType = PVPClassType_War;
313 		// 重置玩家在踢人队列中的标识
502 	DWORD dwMaxOnline = 0;
503 	memcpy(&dwMaxOnline, nCampMaxOnline, sizeof(DWORD));
505 	// 跨服国战进行状态变化
506 	g_pMatchServer->GetWarServerInstance().OnCountryWarRunStepChanged(this,m_dwWarRunStep,dwUserData,dwMaxOnline,dwBossHP);
508 	// 同步回本区更新状态备本区玩家知晓国战状态 国战执行状态子类型变化
828 			if (AddPersonSore((*pNode) ,WarScore_KillPerson, dwAddScore))
829 			{
830 				sprintf_s(szMsgBuf, sizeof(szMsgBuf), "跨服国战击败玩家[%s]，获得积分%d点",pDeadPerson->GetName(), dwAddScore);
831 				SendSystemTips(TipType_PVP, dwPlayerID, InfoPos_ActorRight|InfoPos_ChatWindow,szMsgBuf);
832 			}
859 			if (nExploit>0)
860 			{
861 				pCountryEntityPart->AddCountryExploit(COUNTRY_EXPLOIT_TYPE_KILL,nExploit,OssResAdd_CountryWar,"跨服国战获取杀人功勋",false);
862 			}
863 			//  增加政绩
864 			if (nCbsScore > 0)
865 			{
866 				pCountryEntityPart->AddCountryContribute(COUNTRY_CONTRIBUTE_TYPE_KILL,nCbsScore,OssResAdd_CountryWar,"跨服国战获取杀人政绩",false);
867 			}
868 			//  增加本周政绩
869 			if (nCbsScore > 0)
870 			{
871 				pCountryEntityPart->AddCountryHonour(COUNTRY_HONOUR_TYPE_KILL,nCbsScore,OssResAdd_CountryWar,"跨服国战获取杀人本周政绩",false);
872 			}
873 		}
1002 			// 处理玩家补偿
1003 			DWORD dwAddMoney	= 0;				// 给绑金补偿数量
1004 			bool bFinishTask	= false;			// 是否自动替玩家完成跨服国战任务
1005 			char szMsg[512] = {0};
1006 			DWORD dwSystemMoney = (DWORD)m_WarSchemeInfo.nSpare6;		// 战场补偿数量 绑金，0.不处理
1012 				if (pPlaza!=NULL)
1013 				{
1014 					bool bFlag = pPlaza->AddBindTickets(pPerson,dwSystemMoney,OssResAdd_CountryWar,"跨服国战被传出获得绑定金币补偿",0,0);
1015 					// 增加绑金成功
1016 					if (bFlag)
1020 						dwAddMoney = dwSystemMoney;
1022 						// 发送消息给客户端
1023 						sprintf_s(szMsg, sizeof(szMsg), "<rich color='#FFFF80FF'>跨服国战被传出获得绑定金币补偿：%d<rich color='default'>", dwSystemMoney);
1024 						SendSystemTips(TipType_PVP, pPerson->GetNumProp(CREATURE_PROP_PDBID), InfoPos_ActorUnder|InfoPos_ChatWindow,szMsg);
1025 					}
1026 				}
1027 			}
1029 			// 没有完成任务，系统自动设置玩家任务完成，由于玩家可延迟接跨服国战任务
1030 			ILuaEngine * pLuaEngine = gZoneServiceProvider->GetLuaEngine();
1031 			if(NULL != pLuaEngine)
1050 				if (1==nOutVal1 || 1==nOutVal2)
1051 				{
1052 					// 设置自动替玩家完成跨服国战任务
1053 					bFinishTask = true;
1053 					bFinishTask = true;
1055 					sprintf_s(szMsg, sizeof(szMsg), "<rich color='#FFFF80FF'>跨服国战被传出补偿：本次所接的跨服国战任务将自动完成<rich color='default'>");
1056 					// 发送消息给客户端
1057 					SendSystemTips(TipType_PVP, pPerson->GetNumProp(CREATURE_PROP_PDBID), InfoPos_ActorUnder|InfoPos_ChatWindow,szMsg);
1069 				{
1070 					char szBuf[256] = {0};
1071 					sprintf_s(szBuf, sizeof(szBuf), "跨服国战被传出获得绑定金币补偿：%d", dwAddMoney);
1072 					strMoney = szBuf;
1073 				}
1074 				if (bFinishTask)
1075 				{
1076 					strTask = "跨服国战被传出补偿：本次所接的跨服国战任务自动完成";
1077 				}
1078 				// 发送到客户端
1361 	// 发送玩家获取积分事件
1362 	SEventMatchCountryWarGetScore_S eventData;
1363 	eventData.dwPVPClassType	= GetPVPClass()->GetClass();					// 跨服PVP类型 EMPVPClassType
1364 	eventData.dwWarID			= GetID();										// 相关战场ID
1365 	eventData.uidPlayer			= playerNode.uidPlayer;							// 玩家UID
1386 		{
1387 			CLuaParam param[5];
1388 			param[0] = eventData.dwPVPClassType;						//	跨服PVP类型 EMPVPClassType
1389 			param[1] = eventData.dwWarID;								//	相关战场ID
1390 			param[2] = ANALYZEUID_SERIALNO(eventData.uidPlayer);		//	玩家序列号
1609 	sendData.dwDefWorldID	= m_countryWarInfo.dwDefWorldID;		// 防守方世界ID
1610 	sendData.dwDefCountryID	= m_countryWarInfo.dwDefCountryID;		// 防守方国家ID
1613 	// 发跨服撮合信息消息 dwServerID:服务器ID ,跨服信息专用
1614 	return g_pMatchServer->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_RequestKqWarCall,dwCountryID,0,0,(const char *)&sendData,sizeof(sendData));
1615 }
1674 	}
1676 	char szMsg[512] = {0};
1677 	sprintf_s(szMsg, sizeof(szMsg), "跨服国战攻破城门，获得积分%d点", dwGateScore);	
1679 	// 攻方阵营添加积分
1680 	AddCampPlayersScore(CountryWarCamp_Attack, WarScore_KillPerson, dwGateScore, szMsg);
1799 		// 增加经验
1800 		pPerson->SetNumProp(CREATURE_PROP_EXP, dwAddExp, true);
1801 		pOSSLogServer->TrackAddExp(dwPlayerID, 0, dwAddExp, OssResAdd_CountryWar, 0, "跨服国战第一个占领敌国封印经验奖励");
1803 		sprintf_s(szMsg, sizeof(szMsg), "跨服国战占领敌国封印，增加经验：%d", dwAddExp);
1804 		SendSystemTips(TipType_PVP, dwPlayerID, InfoPos_ActorUnder|InfoPos_ChatWindow,szMsg);
1805 	}
1850 			// 设置玩家所得共享经验
1851 			pCampPerson->SetNumProp(CREATURE_PROP_EXP, dwShareExp, true);
1852 			pOSSLogServer->TrackAddExp(playerNode.dwPlayerID, 0, dwShareExp, OssResAdd_CountryWar, 0, "跨服国战占领第一个封印分享奖励");
1854 			sprintf_s(szMsg, sizeof(szMsg), "跨服国战中占领敌国封印时分享所得经验：%d", dwShareExp);
1855 			SendSystemTips(TipType_PVP, playerNode.dwPlayerID, InfoPos_ActorUnder|InfoPos_ChatWindow,szMsg);
1856 		}
1936 		// 增加经验
1937 		pPerson->SetNumProp(CREATURE_PROP_EXP, dwAddExp, true);
1938 		pOSSLogServer->TrackAddExp(playerNode.dwPlayerID, 0, dwAddExp, OssResAdd_CountryWar, 0, "跨服国战击杀天师经验奖励");
1940 		// 广播提示
1940 		// 广播提示
1941 		sprintf_s(szMsg, sizeof(szMsg), "跨服国战击杀天师奖励，增加经验：%d", dwAddExp);
1942 		SendSystemTips(TipType_PVP, playerNode.dwPlayerID, InfoPos_ActorUnder|InfoPos_ChatWindow,szMsg);
1943 	}
1973 	DWORD dwScore = (DWORD)(g_pMatchServer->GetWarConfigNumber(WarCfgNum_Coutry_GunAddScore));		// 一个大炮，多少积分（攻方）
1975 	// 发送消息信息
1976 	sprintf_s(szBuf, sizeof(szBuf), "跨服国战击杀神武大炮，获得积分%d点", dwScore);	
1978 	// 守方阵营增加积分
1979 	AddCampPlayersScore(CountryWarCamp_Attack,WarScore_KillPerson,dwScore,szBuf);
2021 	if (bAdded)
2022 	{
2023 		sprintf_s(szMsg, sizeof(szMsg), "跨服国战采集晶石，获得积分%d点", dwStnAddScore);	
2024 		SendSystemTips(TipType_PVP, pPlayerNode->dwPlayerID, InfoPos_ActorUnder|InfoPos_ChatWindow,szMsg);
2025 	}
2051 	{
2052 		// 天师血量提示
2053 		sprintf_s(szMsg, sizeof(szMsg), "跨服国战采集晶石，扣除【天师】血量%d点", dwAddHP);	
2055 		// 产生一个伤害效果
2056 		DamageCalcContext damageccontext;
2066 	{
2067 		// 天师血量提示
2068 		sprintf_s(szMsg, sizeof(szMsg), "跨服国战采集晶石，增加【天师】血量%d点", dwAddHP);	
2070 		// 天师固有的免疫BUFF会挡住手动加血，所以要先移除天师身上的BUFF，手工加血后再附上固有的BUFF
2072 		//// 取得BUFF信息
2145 		if (bAdded)
2146 		{
2147 			sprintf_s(szMsg, sizeof(szMsg), "跨服国战击杀补给车，获得积分%d点", dwKillTankScore);	
2148 			SendSystemTips(TipType_PVP, pPlayerNode->dwPlayerID, InfoPos_ActorUnder|InfoPos_ChatWindow,szMsg);
2149 		}
2220 			if (AddPersonSore((*pNode) ,WarScore_KillTank, dwAddScore))
2221 			{
2222 				sprintf_s(szMsg, sizeof(szMsg), "跨服国战击杀补给车，获得积分%d点", dwAddScore);	
2223 				SendSystemTips(TipType_PVP, pNode->dwPlayerID, InfoPos_ActorUnder|InfoPos_ChatWindow,szMsg);
2224 			}
2269 	char szMsg[512] = {0};
2270 	// 发送消息信息
2271 	sprintf_s(szMsg, sizeof(szMsg), "跨服国战击杀攻方战车，获得积分%d点", dwScore);	
2273 	// 守方阵营增加积分
2274 	AddCampPlayersScore(CountryWarCamp_Defend,WarScore_KillPerson,dwScore,szMsg);
2821 /** 资源事件执行接口
2822 @param   WORD wEventID		:事件ID
2823 @param   WORD dwPVPClassType:跨服PVP类型 EMPVPClassType
2824 @param   WORD dwWarID		:相关战场ID
2825 @param   WORD dwResID		:相关战争资源配置ID
2836 		return;
2837 	}
2839 	// 跨服PVP类型不一致
2840 	if (dwPVPClassType != GetPVPClass()->GetClass())
2841 	{
2840 	if (dwPVPClassType != GetPVPClass()->GetClass())
2841 	{
2842 		ErrorLn("CCountryWar::OnWarResEvent() 跨服PVP类型不一致 dwPVPClassType("<< dwPVPClassType << ") != GetClass("<< GetPVPClass()->GetClass() <<")");
2843 		return;
2844 	}
3023 /** 资源投票事件
3024 @param   WORD wEventID		:事件ID
3025 @param   WORD dwPVPClassType:跨服PVP类型 EMPVPClassType
3026 @param   WORD dwWarID		:相关战场ID
3027 @param   WORD dwResID		:相关战争资源配置ID
3038 		return false;
3039 	}
3041 	// 跨服PVP类型不一致
3042 	if (dwPVPClassType != GetPVPClass()->GetClass())
3043 	{
3042 	if (dwPVPClassType != GetPVPClass()->GetClass())
3043 	{
3044 		ErrorLn("CCountryWar::OnWarResVote() 跨服PVP类型不一致 dwPVPClassType("<< dwPVPClassType << ") != GetClass("<< GetPVPClass()->GetClass() <<")");
3045 		return false;
3046 	}
3144 			if (dwNowTicks>=GetWarTimeData(CountryWarTime_Broadcast)+dwTimeArray[i][1])
3145 			{
3146 				sprintf_s(szAttMsg, sizeof(szAttMsg), "<rich color=#FFFF0000>跨服国战[进攻%s]将于%s后开始<rich color=default>", m_WarCamp[CountryWarCamp_Defend].szName,g_ExternalFacade.GetRemainTimeString(dwDiffTime));
3147 				sprintf_s(szDefMsg, sizeof(szDefMsg), "<rich color=#FFFF0000>跨服国战[抵御%s]将于%s后开始<rich color=default>", m_WarCamp[CountryWarCamp_Attack].szName,g_ExternalFacade.GetRemainTimeString(dwDiffTime));
3149 				// 广播开战信息到参战国
3150 				WorldBroadcastWarTips(TipType_PVP,ChatChannel_Nation, InfoPos_ActorUnder, szAttMsg, szDefMsg);
3156 		}
3157 	}
3159 	// 创建及开战5分钟前发送一次跨服国战传送连接信息
3160 	if (GetRunStepData(CountryWarRunStep_Ready)== 0 || (dwDiffTime==300 && GetWarTimeData(CountryWarTime_LinkBroad)==0))
3161 	{	
3166 		else
3167 		{
3168 			// 设定发送跨服国战信息时间
3169 			SetWarTimeData(CountryWarTime_LinkBroad,1);
3170 		}
3174 		ostrbuf link;
3176 		link << "<a color='#FF00FF00' href=\"Z?19&2"<<GetRoomID()<<","<<dwNowTicks<<"&\">点击参加";
3177 		osbAttack << "<rich color='#FFFF0000'>跨服国战[进攻"<<m_WarCamp[CountryWarCamp_Defend].szName<<"]即将开始,<img src=\"set:MatchStrike image:StrikeKill\">"<<link<<"<rich color='default'>";
3178 		osbDefend << "<rich color='#FFFF0000'>跨服国战[抵御"<<m_WarCamp[CountryWarCamp_Attack].szName<<"]即将开始,<img src=\"set:MatchStrike image:StrikeKill\">"<<link<<"<rich color='default'>";
3180 		WorldBroadcastWarTips(TipType_PVP,ChatChannel_Nation, InfoPos_ChatWindow, osbAttack.c_str(), osbDefend.c_str());
3181 	}
3237 			{
3238 				// 发送提示
3239 				sprintf_s(szMsg, sizeof(szMsg), "跨服国战已结束请尽快离开，还剩%s将关闭战场",g_ExternalFacade.GetRemainTimeString(dwDiffTime));
3240 				SendSystemTips(TipType_PVP, 0, InfoPos_ActorRight,szMsg);
3242 				// 重设发送时间
3420 		{
3421 			m_nBossInitMaxHP = 0;
3422 			ErrorLn("跨服国战中竟然找不到主力天师？？？？");
3423 		}
3424 		else
3520 	// 全区广播国战结果
3521 	ostrbuf osbTips;
3522 	osbTips << "<rich color='#FFFF0000'>跨服国战开始了["<<m_WarCamp[CountryWarCamp_Attack].szName<<"进攻"<<m_WarCamp[CountryWarCamp_Defend].szName<<"]<rich color='default'>";
3523 	g_ExternalFacade.BroadcastWorldSystemTips(0,TipType_PVP, 0, ChatChannel_System, InfoPos_ChatWindow|InfoPos_ScreenTopLarge,osbTips.c_str());
3523 	g_ExternalFacade.BroadcastWorldSystemTips(0,TipType_PVP, 0, ChatChannel_System, InfoPos_ChatWindow|InfoPos_ScreenTopLarge,osbTips.c_str());
3525 	// 跨服发送消息
3526 	ostrbuf osbAttack;
3527 	ostrbuf osbDefend;
3529 	// 发送已开战消息到开战国
3530 	link << "<a color='#FF00FF00' href=\"Z?19&2"<<GetRoomID()<<","<<dwNowTicks<<"&\">点击参加";
3531 	osbAttack << "<rich color='#FFFF0000'>跨服国战[进攻"<<m_WarCamp[CountryWarCamp_Defend].szName<<"]开始了<img src=\"set:MatchStrike image:StrikeKill\">"<<link<<"<rich color='default'>";
3532 	osbDefend << "<rich color='#FFFF0000'>跨服国战[抵御"<<m_WarCamp[CountryWarCamp_Attack].szName<<"]开始了<img src=\"set:MatchStrike image:StrikeKill\">"<<link<<"<rich color='default'>";
3533 	WorldBroadcastWarTips(TipType_PVP,ChatChannel_Nation,InfoPos_ChatWindow,osbAttack.c_str(), osbDefend.c_str());
3534 }
3564 	if (dwBaseCount==0 || dwLBoundCount==0 || dwHBoundCount==0 || dwLBoundRate==0 || dwHBoundRate==0 || dwRecalcRate==0 || dwCountPowRate==0 || dwRatePowRate==0 || dwBaseCount<=dwLBoundCount || dwBaseCount>=dwHBoundCount)
3565 	{
3566 		ErrorLn("跨服国战重新设置天师数值没有正常配置");
3567 		return;
3568 	}
3663 	if (m_fLastChangeRate<0.000001 || ( fLCRate > 0.95 && fLCRate<1.05 ) )
3664 	{
3665 		sprintf_s(szMsgBuf, sizeof(szMsgBuf), "跨服国战变化小百分之五忽略调天师血量，当前要调节系数=%.2f，最后调节系数=%.2f", fChangeRate, m_fLastChangeRate);
3666 		ErrorLn(szMsgBuf);
3667 		return;
3699 	int nNewMaxHp = pMonster->GetNumProp(CREATURE_PROP_MAX_HP);		// 最大血量
3700 	int nNewCurHp = pMonster->GetNumProp(CREATURE_PROP_CUR_HP);		// 当前血量
3702 	sprintf_s(szMsgBuf, sizeof(szMsgBuf), "跨服国战动态天师血量设置 旧（CurHP=%d, MaxHP=%d）， 新（AddHP=%d, AddMaxHP=%d, CurHP=%d, MaxHP=%d）,攻（%s, 人数=%d）,守（%s, 人数=%d）,人数指数（val=%.2f,newVal=%.2f）,比例指数（val=%.2f,newVal=%.2f）",
3703 		nCurHp,nMaxHp, nSetCurHP,nSetMaxHP,nNewCurHp,nNewMaxHp,
3704 		m_WarCamp[CountryWarCamp_Attack].szName,dwAttackMemberCount,m_WarCamp[CountryWarCamp_Defend].szName,dwDefendMemberCount,
3742 	// 参战国积分列表,游戏世界ID做索引
3743 	TMAP_CountryWarCountryScoreList mapCountryScoreList;
3746 	// 跨服国战个人获取奖励信息,以角色ID为键值
3747 	map<DWORD, SWorldCountryWarPrizeInfo>	mapWarPrizeInfo;
3748 	for(DWORD i=0; i<m_WarCamp.size(); i++)
3759 		}
3760 	}
3762 	SWorldCountryWarLogInfo addNode;			// 跨服国战日志
3763 	SWorldCountryWarResultInfo warResultInfo;	// 发送到客户端的跨服国战日志信息
3765 	// 取得获胜阵营
3766 	for (DWORD i=0; i<m_WarCamp.size(); i++)
3976 		if (clanSortNode.dwScoreTotal > 0 && clanSortNode.dwCampIndex<CountryWarCamp_MaxID)
3977 		{
3978 			// 跨服国战信息日志排名节点信息
3979 			if (dwClanCounts < COUNTRY_WARORDERLOG_MAXCOUNT)
3980 			{
4019 					if (dwAddClanMoney > 0)
4020 					{
4021 						sprintf_s(szMsg, sizeof(szMsg), "<rich color='#FFFF80FF'>跨服国战本帮会增加奖励资金：%s<rich color='default'>", MoneyToString(dwAddClanMoney));
4022 						SendSystemTips(TipType_PVP, playerNode.dwPlayerID, InfoPos_ActorUnder|InfoPos_ChatWindow,szMsg);
4023 					}
4034 					if (nCreditNum > 0)
4035 					{
4036 						pCreditPart->InCreditValue(ECreditSubID_Bhsw, nCreditNum, "跨服国战帮会前10名", OssResAdd_CountryWar);
4037 						// 提示下
4038                         // 梦想版, 帮会声望名称显示为军饷
4039                         if (getGameUserData(GameUserDataType_Ver) == 1)
4040                         {
4041 						    sprintf_s(szMsg, sizeof(szMsg), "<rich color='#FFFF80FF'>跨服国战本帮会排名第%d,你获得军饷奖励：%s<rich color='default'>", dwClanCounts+1, CreditToString(nCreditNum));
4042                         }
4043                         else
4043                         else
4044                         {
4045                             sprintf_s(szMsg, sizeof(szMsg), "<rich color='#FFFF80FF'>跨服国战本帮会排名第%d,你获得声望奖励：%d<rich color='default'>", dwClanCounts+1, nCreditNum);
4046                         }
4047                         // 发送消息给客户端
4074 				sstrcpyn( nodeInfo.szObjectName,szClanName ,sizeof(nodeInfo.szObjectName) );	// 帮会名称
4076 				addNode.clanInfo[dwClanCounts] = nodeInfo;
4078 				// 发送到客户端的跨服国战日志信息
4079 				warResultInfo.clanInfo[dwClanCounts] = nodeInfo;	
4081 				// 排名前10的帮会个数
4132 	if (pPlaza == NULL)
4133 	{
4134 		ErrorLn("跨服国战（"<< m_WarCamp[CountryWarCamp_Attack].szName << " vs "<< m_WarCamp[CountryWarCamp_Defend].szName <<"）：商城服务器pPlaza==NULL！");
4135 	}
4137 	for (TLIST_CountryWarScoreSortList::iterator it=personNodeList.begin(); it!=personNodeList.end();it++)
4239 			if (pPlaza!=NULL)
4240 			{
4241 				bool bFlag = pPlaza->AddBindTickets(pPerson,dwAddMoney,OssResAdd_CountryWar,"跨服国战获得绑定金币奖励",0,0);
4242 				// 增加绑金成功
4243 				if (bFlag)
4244 				{
4245 					// 广播提示
4246 					sprintf_s(szMsg, sizeof(szMsg), "<rich color='#FFFF80FF'>跨服国战增加绑定金币奖励：%d<rich color='default'>", dwAddMoney);
4247 					// 发送消息给客户端
4248 					SendSystemTips(TipType_PVP, dwPlayerID, InfoPos_ActorUnder|InfoPos_ChatWindow,szMsg);
4250 				else	// 增加绑金失败
4251 				{
4252 					sprintf_s(szMsg, sizeof(szMsg), "跨服国战(%s vs %s)给%s[%d]增加绑定金币%d失败", m_WarCamp[CountryWarCamp_Attack].szName,m_WarCamp[CountryWarCamp_Defend].szName, pPerson->GetName(), pPerson->GetNumProp(CREATURE_PROP_PDBID), dwAddMoney);
4253 					ErrorLn(szMsg);
4254 				}
4268 			// 经验奖励异常个数
4269 			dwWarningExp++;
4270 			sprintf_s(szBuf, sizeof(szBuf), "跨服国战奖励,添加经验值数值异常!:奖励经验=%.2f,角色等级=%.2f,等级调节基数=%.2f,经验调节基数1=%.2f,经验调节基数2=%.2f,个人总积分=%.2f,积分系数=%.2f,个人积分榜系数=%.2f",
4271 				fAddExp,fMaxHunLevel,fExpLevelAdjBase,fExpBaseNum1,fExpBaseNum2,fScoreTotal,fExpScoreRate,fPersonScoreRate);
4272 			//报给场景服
4277 		{
4278 			pPerson->SetNumProp(CREATURE_PROP_EXP, dwAddExp, true);
4279 			pOSSLogServer->TrackAddExp(dwPlayerID, 0, dwAddExp, OssResAdd_CountryWar, 0, "跨服国战排名经验奖励");
4280 			// 广播提示
4281 			sprintf_s(szMsg, sizeof(szMsg), "<rich color='#FFFF80FF'>国战排名奖励，增加经验：%d<rich color='default'>", dwAddExp);
4302 		if (personNode.dwScoreTotal > 0)
4303 		{
4304 			// 跨服国战信息日志排名节点信息
4305 			if (dwActorCounts < COUNTRY_WARORDERLOG_MAXCOUNT)
4306 			{
4316 				sstrcpyn( nodeInfo.szObjectName,pPerson->GetName() ,sizeof(nodeInfo.szObjectName) );	// 玩家名称
4318 				addNode.actorInfo[dwActorCounts] = nodeInfo;
4320 				// 发送到客户端的跨服国战日志信息
4321 				warResultInfo.actorInfo[dwActorCounts] = nodeInfo;
4323 				// 排名前10的玩家个数
4343 	DWORD dwAttackDBID = 0;
4344 	DWORD dwDefendDBID = 0;
4346 	// 发送到客户端的跨服国战日志信息
4347 	warResultInfo.dwPlayTime		= dwRunTotalTime;									// 战斗时长(秒)
4347 	warResultInfo.dwPlayTime		= dwRunTotalTime;									// 战斗时长(秒)
4348 	warResultInfo.dwType			= (DWORD)m_WarSchemeInfo.nID;						// 跨服国战类型
4349 	warResultInfo.dwAttackWorldID	= m_countryWarInfo.dwAttWorldID;					// 进攻国家所在游戏世界ID
4350 	warResultInfo.dwAttackCountryID	= m_countryWarInfo.dwAttCountryID;					// 进攻国家ID
4359 	sstrcpyn( warResultInfo.szAttackWorldName, strAttWorldName.c_str(), sizeof(warResultInfo.szAttackWorldName));
4360 	sstrcpyn( warResultInfo.szDefendWorldName, strDefWorldName.c_str(), sizeof(warResultInfo.szDefendWorldName));
4362 	// 新增跨服国战日志数据信息
4363 	addNode.dwID				= GetRoomID()*1000+ getThisGameWorldID() ;			// 跨服国战日志信息ID
4364 	addNode.dwAddTime			= dwNowTime ;										// 跨服国战日志写入时间
4365 	addNode.dwPublicWorldID		= getThisGameWorldID() ;							// 所属公共区世界ID
4366 	addNode.dwStartTime			= m_dwStartTime;									// 开始时间
4366 	addNode.dwStartTime			= m_dwStartTime;									// 开始时间
4367 	addNode.dwPlayTime			= dwRunTotalTime;									// 战斗时长(秒)
4368 	addNode.dwType				= (DWORD)m_WarSchemeInfo.nID;						// 跨服国战类型
4369 	addNode.dwAttackWorldID		= m_countryWarInfo.dwAttWorldID;					// 进攻国家所在游戏世界ID
4370 	addNode.dwAttackCountryID	= m_countryWarInfo.dwAttCountryID;					// 进攻国家ID
4382 	//SWorldCountryWarOrderNodeInfo actorInfo[COUNTRY_WARORDERLOG_MAXCOUNT];	// 排名前10的玩家
4383 	//SWorldCountryWarOrderNodeInfo clanInfo[COUNTRY_WARORDERLOG_MAXCOUNT];		// 排名前10的帮会
4385 	// 进攻方新增跨服国战日志
4386 	addNode.dwResultFlag = ((dwWinCampIndex == CountryWarCamp_Attack) ? 1 : 0);
4387 	pCountryServer->AddWorldCountryWarLog(addNode,addNode.dwAttackWorldID);
4387 	pCountryServer->AddWorldCountryWarLog(addNode,addNode.dwAttackWorldID);
4388 	dwAttackDBID = addNode.dwID;
4390 	// 防守方新增跨服国战日志
4391 	addNode.dwResultFlag = ((dwWinCampIndex == CountryWarCamp_Defend) ? 1 : 0);
4392 	pCountryServer->AddWorldCountryWarLog(addNode,addNode.dwDefendWorldID);
4397 	// 更新国战场战斗结果信息到本区社会服
4398 	SendWorldWarResultToSocial(m_countryWarInfo.dwDefWorldID,m_countryWarInfo.dwDefCountryID, (dwWinCampIndex == CountryWarCamp_Defend),m_WarCamp[CountryWarCamp_Defend].dwMaxOnline);
4400 	// 本次跨服国战写入国家历史信息
4401 	ostrbuf strTitle,strHtml;
4402 	// 国王名称 m_WarCamp[CountryWarCamp_Attack].szName
4558 			// 国战战场玩家获取奖励
4559 			SEventMatchCountryWarAddPrize_S eventData;
4560 			eventData.dwPVPClassType	= GetPVPClass()->GetClass();					// 跨服PVP类型 EMPVPClassType
4561 			eventData.dwWarID			= GetID();										// 相关战场ID
4562 			eventData.uidPlayer			= playerNode.uidPlayer;							// 玩家UID
4639 	// 全区广播国战结果
4640 	ostrbuf osbTips;
4641 	osbTips << "<rich color='#FFFF0000'>跨服国战:"<<m_WarCamp[CountryWarCamp_Attack].szName<<"进攻"<<m_WarCamp[CountryWarCamp_Defend].szName<< (dwWinCampIndex==CountryWarCamp_Attack?"胜利":"失败")<<"<rich color='default'>";
4642 	g_ExternalFacade.BroadcastWorldSystemTips(0,TipType_PVP, 0, ChatChannel_System, InfoPos_ChatWindow|InfoPos_ScreenTopLarge,osbTips.c_str());
4644 	// 全区广播国战结果
4655 		sprintf_s(szTimestr,sizeof(szTimestr),"[%.2d:%.2d分]",local_time.tm_hour,local_time.tm_min);
4656 		osbTips.clear();
4657 		osbTips << "<rich color='#FF80FF'>跨服国战:复仇的天师将会在"<<szTimestr<<"到达"<<pWinName<<"的青龙城,将其击杀将有丰厚奖励<rich color='default'>";
4658 		if( isPublicGameWorld() == true)
4659 		{
4666 	// 国战战场结束结果
4667 	SEventMatchCountryWarResult_S eventData;
4668 	eventData.dwPVPClassType		= GetPVPClass()->GetClass();	// 跨服PVP类型 EMPVPClassType
4669 	eventData.dwWarID				= GetID();						// 相关战场ID
4670 	eventData.nWinCampID			= (BYTE)dwWinCampIndex+1;		// 获胜方阵营ID
4684 	{
4685 		ostrbuf buffer;
4686 		buffer << "跨服国战奖励,添加经验值数值异常报警!  经验异常玩家数量 ="<<dwWarningExp << ", 请查看场景服信息";
4687 		//  玩家举报信息给GM消息数据结构
4688 		SMsgReportToGMInfo sendData;
4690 		sendData.dwReasonFlag		= Chat_ReportToGMReason_Other;							// 原因标识  ChatReportToGMReasonFlag
4691 		sendData.strTitle			= buffer.str();											// 举报证据（最大长度和聊天内容长短一致）
4692 		sendData.strMsg				= "跨服国战场景服自动举报";								// 附加说明
4693 		pChatServer->SendReportToGMClient(0,sendData);
4695 		//报给维护!
4798 	{
4799 		CLuaParam param[5];
4800 		param[0] = GetPVPClass()->GetClass();					//	跨服PVP类型 EMPVPClassType
4801 		param[1] = GetID();										//	相关战场ID
4803 		DWORD dwTotalScore = 0;
5021 			sendData.strCheaterName		= pSrcPerson->GetName();									// 举报对象角色名
5022 			sendData.strTitle			= buffer.str();												// 举报证据（最大长度和聊天内容长短一致）
5023 			sendData.strMsg				= "跨服国战场景服自动举报";										// 附加说明
5024 			
5025 			pChatServer->SendReportToGMClient(0,sendData);
5047 			return false;
5048 		}
5049 		// 发跨服取得攻方国王信息 dwServerID:服务器ID ,跨服信息专用
5050 		g_pMatchServer->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_RequestKingInfo,GetID(),m_countryWarInfo.dwAttWorldID,m_countryWarInfo.dwAttCountryID);
5052 		// 取得守方游戏世界的社会服
5056 			return false;
5057 		}
5058 		// 发跨服取得守方国王信息 dwServerID:服务器ID ,跨服信息专用
5059 		return g_pMatchServer->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_RequestKingInfo,GetID(),m_countryWarInfo.dwDefWorldID,m_countryWarInfo.dwDefCountryID);
5060 	}
5269 			// 调用LUA，处理玩家杀人
5270 			CLuaParam param[6];
5271 			param[0] = GetPVPClass()->GetClass();					// 跨服PVP类型 EMPVPClassType
5272 			param[1] = GetID();										// 相关战场ID
5273 			param[2] = ANALYZEUID_SERIALNO(uidPlayer);				// 凶手
5284 		// 调用LUA，处理玩家杀人
5285 		CLuaParam param[6];
5286 		param[0] = GetPVPClass()->GetClass();					// 跨服PVP类型 EMPVPClassType
5287 		param[1] = GetID();										// 相关战场ID
5288 		param[2] = ANALYZEUID_SERIALNO(killerNode.uidPlayer);	// 凶手
5352 DWORD CCountryWar::GetKickOutTime(void)
5353 {
5354 	return (DWORD)m_WarSchemeInfo.nSpare1;		// 跨服国战被踢玩家场内滞留时间（秒）
5355 }
5357 // 发送国战战场创建信息到参战游戏区的所有场景服
5488 	return true;
5489 }
5491 // 跨服发送消息
5492 void CCountryWar::WorldBroadcastWarTips(DWORD nTipType, DWORD nChannelType, DWORD nInfoPos,const char * pAttackTips, const char * pDefendTips)
5493 {
5572 		return false;
5573 	}
5575 	// 发跨服撮合信息消息 dwServerID:服务器ID ,跨服信息专用
5576 	return g_pMatchServer->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_SendWorldWarResult,dwCountryID,(bIsWin?1:0),dwWarOnline);
5577 }
5598 		return false;
5599 	}
5601 	// 发跨服撮合信息消息 dwServerID:服务器ID ,跨服信息专用
5602 	return g_pMatchServer->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_RequestAddClanGold,dwWorldID,dwClanID,dwMoney);
5603 }
5624 		return false;
5625 	}
5627 	// 发跨服撮合信息消息 dwServerID:服务器ID ,跨服信息专用
5628 	return g_pMatchServer->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_SendCountryWarScore,dwWorldID,dwCountryID,dwWarScore);
5629 }
6041 		return;
6042 	}
6044 	// 取得跨服组队撮合服务器
6045 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
6046 	if (pMatchServer == NULL)

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcClient\Client\MatchClient\CountryWar.cpp 13 KB CPP 文件 2014/2/25 13:44:48 2018/10/23 19:34:25 2018/10/23 19:34:25 9
242 	return true;
243 }
245 /** 取得跨服国战信息结果日志信息
246 @return  跨服国战信息结果日志信息
247 */
248 SWorldCountryWarResultInfo*  CCountryWar::GetWorldCountryWarResultInfo(void)
250 	return &m_warResultInfo;
251 }
253 /** 取得跨服国战信息日志信息的排名节点信息
254 @param  DWORD dwIndex : 序号
255 @param   BYTE dwType: 对象类型	1表示玩家，2表示帮会
254 @param  DWORD dwIndex : 序号
255 @param   BYTE dwType: 对象类型	1表示玩家，2表示帮会
256 @return  查询到的跨服国战信息日志信息排名节点信息
257 */
258 const SWorldCountryWarOrderNodeInfo*  CCountryWar::GetWorldCountryWarLogOrderNodeInfo(DWORD dwIndex,BYTE dwType)
269 }
271 /** 获取本帮帮会积分数据
272 @param DWORD dwScoreID : 跨服国战积分类型ID EMWarScoreFlag  
273 @return
274 */
465 		}
466 		break;
467 	case Match_WarMsg_SendCountryWarResult:		// 更新跨服国战信息结果日志信息到客户端
468 		{
469 			bHasDone = true;
471 			if (nNewlen!=sizeof(SWorldCountryWarResultInfo)+sizeof(SWorldCountryWarPrizeInfo))
472 			{
473 				ErrorLn("收到更新跨服国战信息结果日志信息到客户端数据大小不符，nLen = "<<nNewlen);
474 				break;
475 			}
479 			DWORD dwPlayerID	= dwUserData2;		// 玩家角色ID
480 			DWORD dwCamp		= dwUserData3;		// 玩家阵营序号
482 			// 跨服国战信息结果日志信息
483 			SWorldCountryWarResultInfo	* pInfo			= (SWorldCountryWarResultInfo *)pMsgData;
483 			SWorldCountryWarResultInfo	* pInfo			= (SWorldCountryWarResultInfo *)pMsgData;
484 			// 跨服国战个人获取奖励信息
485 			SWorldCountryWarPrizeInfo	* pPrizeInfo	= (SWorldCountryWarPrizeInfo*)(pMsgData+sizeof(SWorldCountryWarResultInfo));
487 			m_warResultInfo = (* pInfo);

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\CountryService\CountryService.cpp 199 KB CPP 文件 2014/2/25 0:21:25 2018/10/23 20:08:52 2018/10/23 20:08:52 10
927 		}
928 		break;
929 	case MSG_COUNTRY_WORLDWAR_REQUEST:		// 国家客户端  发送给 国家社会服 请求跨服国战信息消息
930 		{
931 			OnRequestWorldWarInfo(endpointId,actionId,head,data, len);
1059 	return true;
1061 }
1064 /** 本区是否能开跨服国战
1065 @return  成功否
1066 */
1540 	AddPlayerInfo( pMsg->playerInfo );
1543 }
1545 // 请求跨服国战信息消息
1546 void CCountryService::OnRequestWorldWarInfo(ulong endpointId, ulong actionId, SGameMsgHead* head,void* data, size_t len)
1547 {
2049 	m_MapRecoverInfo.Create();
2050 	
2051 	// 跨服国战系统加载数据
2052 	m_WorldWar.Create();
2054 }
2139 	// 检查过期的查询过的玩家信息缓存数据
2140 	OnCheckNoNeedBufferPlayerInfo();
2142 	// 定时同步一下跨服国家信息,3*10分钟一次
2143 	static DWORD dwLastUpdateWorldCountryTimes = 0;
2144 	if (dwLastUpdateWorldCountryTimes>=3)
2145 	{
2146 		dwLastUpdateWorldCountryTimes = 1;
2147 		// 跨服更新共享国家信息列表到
2148 		SendWorldCountryToBridgeServer(0,0);
2148 		SendWorldCountryToBridgeServer(0,0);
2149 		// 同步所有跨服国战记录
2150 		m_WorldWar.SendWorldWarToServer(0,0);
2151 	}
3576 	return (IMapRecover* )&m_MapRecoverInfo;
3577 }
3579 /** 取地跨服国战系统接口
3580 @param   
3581 @return  
4055 	// 请求广播全局数据
4056 	BroadcastGlobalData();
4057 	// 跨服更新共享国家信息列表到
4058 	SendWorldCountryToBridgeServer(0,0);
4060 	return true;
4415 	}
4416 }
4418 // 跨服更新共享国家信息列表到
4419 void CCountryService::SendWorldCountryToBridgeServer(DWORD dwServerID,DWORD dwCountryID)
4420 {

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\CountryService\CountryService.cpp 199 KB CPP 文件 2014/2/25 14:30:51 2018/10/23 19:46:33 2018/10/23 19:46:33 10
927 		}
928 		break;
929 	case MSG_COUNTRY_WORLDWAR_REQUEST:		// 国家客户端  发送给 国家社会服 请求跨服国战信息消息
930 		{
931 			OnRequestWorldWarInfo(endpointId,actionId,head,data, len);
1059 	return true;
1061 }
1064 /** 本区是否能开跨服国战
1065 @return  成功否
1066 */
1540 	AddPlayerInfo( pMsg->playerInfo );
1543 }
1545 // 请求跨服国战信息消息
1546 void CCountryService::OnRequestWorldWarInfo(ulong endpointId, ulong actionId, SGameMsgHead* head,void* data, size_t len)
1547 {
2049 	m_MapRecoverInfo.Create();
2050 	
2051 	// 跨服国战系统加载数据
2052 	m_WorldWar.Create();
2054 }
2139 	// 检查过期的查询过的玩家信息缓存数据
2140 	OnCheckNoNeedBufferPlayerInfo();
2142 	// 定时同步一下跨服国家信息,3*10分钟一次
2143 	static DWORD dwLastUpdateWorldCountryTimes = 0;
2144 	if (dwLastUpdateWorldCountryTimes>=3)
2145 	{
2146 		dwLastUpdateWorldCountryTimes = 1;
2147 		// 跨服更新共享国家信息列表到
2148 		SendWorldCountryToBridgeServer(0,0);
2148 		SendWorldCountryToBridgeServer(0,0);
2149 		// 同步所有跨服国战记录
2150 		m_WorldWar.SendWorldWarToServer(0,0);
2151 	}
3576 	return (IMapRecover* )&m_MapRecoverInfo;
3577 }
3579 /** 取地跨服国战系统接口
3580 @param   
3581 @return  
4055 	// 请求广播全局数据
4056 	BroadcastGlobalData();
4057 	// 跨服更新共享国家信息列表到
4058 	SendWorldCountryToBridgeServer(0,0);
4060 	return true;
4415 	}
4416 }
4418 // 跨服更新共享国家信息列表到
4419 void CCountryService::SendWorldCountryToBridgeServer(DWORD dwServerID,DWORD dwCountryID)
4420 {

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\CountryServer\CountryServer.cpp 151 KB CPP 文件 2014/2/25 0:05:38 2018/10/23 20:04:03 2018/10/23 20:04:03 20
1176 	switch(nCmdID)
1177 	{
1178 	case GAMEDB_REQUEST_WORLDCOUNTRY_WARLOG_ADD:		// 添加跨服国战结果信息
1179 		{
1180 			OnDBReturn_AddWarLog(nCmdID, nDBRetCode,pszDBRetDesc,nQueueIndex,pOutData,nOutLen);
1181 		}
1182 		break;
1183 	case GAMEDB_REQUEST_WORLDCOUNTRY_WARLOG_READ:		// 查询跨服国战结果信息
1184 		{
1185 			OnDBReturn_ReadWarLog(nCmdID, nDBRetCode,pszDBRetDesc,nQueueIndex,pOutData,nOutLen);
2207 		}
2208 		break;
2209 	case MSG_COUNTRY_HISTORY_GET_WARLOG:		// 请求取得跨服国战信息日志信息
2210 		{
2211 			if(data==NULL|| len != sizeof(SMsgCountryHistoryGetWarLog_CS))
2221 				break;
2222 			}
2223 			/// GAMEDB_REQUEST_WORLDCOUNTRY_WAR_READ 查询跨服国战日志信息 : 传入参数结构
2224 			DB_Param_Read_WorldCountryWarLog dbparm;
2224 			DB_Param_Read_WorldCountryWarLog dbparm;
2225 			dbparm.dwID			= pMsg->dwID;									// 跨服国战日志信息ID
2226 			dbparm.dwAddTime	= pMsg->dwAddTime;								// 跨服国战日志写入时间
2227 			dbparm.dwPlayerID	= pPerson->GetNumProp(CREATURE_PROP_PDBID);		// 查询的角色ID,用来返回找到角色并发给他
2229 			if(!pDBEngine->ExecuteSP(GAMEDB_REQUEST_WORLDCOUNTRY_WARLOG_READ, dbparm.dwPlayerID, (LPCSTR)&dbparm,sizeof(dbparm), static_cast<IDBRetSink *>(this),pPerson->GetFromGameWorldID() ))
2229 			if(!pDBEngine->ExecuteSP(GAMEDB_REQUEST_WORLDCOUNTRY_WARLOG_READ, dbparm.dwPlayerID, (LPCSTR)&dbparm,sizeof(dbparm), static_cast<IDBRetSink *>(this),pPerson->GetFromGameWorldID() ))
2230 			{
2231 				WarningLn("请求取得跨服国战信息日志信息失败！"<<pPerson->GetName()<<endl);
2232 				break;
2233 			}
3370 	}
3373 }
3376 /** 新增跨服国战日志
3377 @param   SWorldCountryWarLogInfo &addNode	: 日志信息
3378 @param   DWORD dwSaveToWorldID				: 要保存到的游戏区ID
3383 	if (sizeof(SWorldCountryWarLogInfo)>sizeof(DB_Table_WorldCountryWarLog))
3384 	{
3385 		ErrorLn("CCountryServer::AddWorldCountryWarLog() 新增跨服国战日志失败！原因：sizeof(SWorldCountryWarLogInfo)="<<sizeof(SWorldCountryWarLogInfo)<<">sizeof(DB_Table_WorldCountryWarLog)="<<sizeof(DB_Table_WorldCountryWarLog) );
3386 		return false;
3387 	}
3398 	if(!pDBEngine->ExecuteSP(GAMEDB_REQUEST_WORLDCOUNTRY_WARLOG_ADD, dbparm.data.dwID, (LPCSTR)&dbparm,sizeof(dbparm), static_cast<IDBRetSink *>(this),dwSaveToWorldID))
3399 	{
3400 		WarningLn("新增跨服国战日志失败！"<<dbparm.data.dwID<<endl);
3401 		return false;
3402 	}
3964 	pPKModePart->SwitchPKMode(pZoneMatronInfo->nPkMode);
3965 }
3967 /** 数据库请求返回回调方法 添加跨服国战结果信息
3968 @param   nCmdID ：命令ＩＤ
3969 @param   nDBRetCode：数据库请求返回值，参考上面定义
3983 	// 调式代码
3984 	char szBuf[512]={0};
3985 	sprintf_s(szBuf, sizeof(szBuf), "CCountryServer::OnDBReturn_AddWarLog() 添加跨服国战结果信息 nCmdID=%d,nDBRetCode=%d,nQueueIndex=%d,nOutLen=%d",
3986 		nCmdID,nDBRetCode,nQueueIndex,nOutLen);
3987 	TraceLn(szBuf);
4000 	if (pResult->nResult==0)
4001 	{
4002 		ErrorLn("添加跨服国战信息失败！nResult="<<pResult->nResult);
4003 	}
4005 }
4003 	}
4005 }
4007 /** 数据库请求返回回调方法 查询跨服国战结果信息
4008 @param   nCmdID ：命令ＩＤ
4009 @param   nDBRetCode：数据库请求返回值，参考上面定义
4021 	if (sizeof(SWorldCountryWarLogInfo)>sizeof(DB_Table_WorldCountryWarLog))
4022 	{
4023 		ErrorLn("CCountryServer::OnDBReturn_ReadWarLog() 查询跨服国战结果信息失败！原因：sizeof(SWorldCountryWarLogInfo)="<<sizeof(SWorldCountryWarLogInfo)<<">sizeof(DB_Table_WorldCountryWarLog)="<<sizeof(DB_Table_WorldCountryWarLog) );
4024 		return;
4025 	}
4027 	// 调式代码
4028 	char szBuf[512]={0};
4029 	sprintf_s(szBuf, sizeof(szBuf), "CCountryServer::OnDBReturn_ReadWarLog() 查询跨服国战结果信息 nCmdID=%d,nDBRetCode=%d,nQueueIndex=%d,nOutLen=%d",
4030 		nCmdID,nDBRetCode,nQueueIndex,nOutLen);
4031 	TraceLn(szBuf);
4037 	if(pOutData == NULL || nOutLen < sizeof(DB_Result_Read_WorldCountryWarLog))
4038 	{
4039 		ErrorLn("查询跨服国战结果信息数据大小非法，nOutLen = "<<nOutLen);	
4040 	}
4041 	else
4054 		if( nOutLen != (int)( pResult->nRecordCount * sizeof(DB_Table_WorldCountryWarLog) + sizeof(DB_Result_Read_WorldCountryWarLog)) )
4055 		{
4056 			ErrorLn("查询跨服国战结果信息数据条数与大小不符，nOutLen = "<<nOutLen);
4057 		}
4058 		else if (pResult->nRecordCount<1)
4058 		else if (pResult->nRecordCount<1)
4059 		{
4060 			TraceLn("查询跨服国战结果信息数据条数为0，条数 = "<<pResult->nRecordCount);
4061 		}
4062 		else
4110 	if(!obufData.good())
4111 	{
4112 		Error("查询跨服国战结果信息失败， 原因：obuf.good()=false" << endl);
4113 		return;		
4114 	}

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\CountryServer\CountryServer.cpp 151 KB CPP 文件 2014/2/25 14:23:48 2018/10/23 19:43:17 2018/10/23 19:43:17 20
1176 	switch(nCmdID)
1177 	{
1178 	case GAMEDB_REQUEST_WORLDCOUNTRY_WARLOG_ADD:		// 添加跨服国战结果信息
1179 		{
1180 			OnDBReturn_AddWarLog(nCmdID, nDBRetCode,pszDBRetDesc,nQueueIndex,pOutData,nOutLen);
1181 		}
1182 		break;
1183 	case GAMEDB_REQUEST_WORLDCOUNTRY_WARLOG_READ:		// 查询跨服国战结果信息
1184 		{
1185 			OnDBReturn_ReadWarLog(nCmdID, nDBRetCode,pszDBRetDesc,nQueueIndex,pOutData,nOutLen);
2207 		}
2208 		break;
2209 	case MSG_COUNTRY_HISTORY_GET_WARLOG:		// 请求取得跨服国战信息日志信息
2210 		{
2211 			if(data==NULL|| len != sizeof(SMsgCountryHistoryGetWarLog_CS))
2221 				break;
2222 			}
2223 			/// GAMEDB_REQUEST_WORLDCOUNTRY_WAR_READ 查询跨服国战日志信息 : 传入参数结构
2224 			DB_Param_Read_WorldCountryWarLog dbparm;
2224 			DB_Param_Read_WorldCountryWarLog dbparm;
2225 			dbparm.dwID			= pMsg->dwID;									// 跨服国战日志信息ID
2226 			dbparm.dwAddTime	= pMsg->dwAddTime;								// 跨服国战日志写入时间
2227 			dbparm.dwPlayerID	= pPerson->GetNumProp(CREATURE_PROP_PDBID);		// 查询的角色ID,用来返回找到角色并发给他
2229 			if(!pDBEngine->ExecuteSP(GAMEDB_REQUEST_WORLDCOUNTRY_WARLOG_READ, dbparm.dwPlayerID, (LPCSTR)&dbparm,sizeof(dbparm), static_cast<IDBRetSink *>(this),pPerson->GetFromGameWorldID() ))
2229 			if(!pDBEngine->ExecuteSP(GAMEDB_REQUEST_WORLDCOUNTRY_WARLOG_READ, dbparm.dwPlayerID, (LPCSTR)&dbparm,sizeof(dbparm), static_cast<IDBRetSink *>(this),pPerson->GetFromGameWorldID() ))
2230 			{
2231 				WarningLn("请求取得跨服国战信息日志信息失败！"<<pPerson->GetName()<<endl);
2232 				break;
2233 			}
3370 	}
3373 }
3376 /** 新增跨服国战日志
3377 @param   SWorldCountryWarLogInfo &addNode	: 日志信息
3378 @param   DWORD dwSaveToWorldID				: 要保存到的游戏区ID
3383 	if (sizeof(SWorldCountryWarLogInfo)>sizeof(DB_Table_WorldCountryWarLog))
3384 	{
3385 		ErrorLn("CCountryServer::AddWorldCountryWarLog() 新增跨服国战日志失败！原因：sizeof(SWorldCountryWarLogInfo)="<<sizeof(SWorldCountryWarLogInfo)<<">sizeof(DB_Table_WorldCountryWarLog)="<<sizeof(DB_Table_WorldCountryWarLog) );
3386 		return false;
3387 	}
3398 	if(!pDBEngine->ExecuteSP(GAMEDB_REQUEST_WORLDCOUNTRY_WARLOG_ADD, dbparm.data.dwID, (LPCSTR)&dbparm,sizeof(dbparm), static_cast<IDBRetSink *>(this),dwSaveToWorldID))
3399 	{
3400 		WarningLn("新增跨服国战日志失败！"<<dbparm.data.dwID<<endl);
3401 		return false;
3402 	}
3964 	pPKModePart->SwitchPKMode(pZoneMatronInfo->nPkMode);
3965 }
3967 /** 数据库请求返回回调方法 添加跨服国战结果信息
3968 @param   nCmdID ：命令ＩＤ
3969 @param   nDBRetCode：数据库请求返回值，参考上面定义
3983 	// 调式代码
3984 	char szBuf[512]={0};
3985 	sprintf_s(szBuf, sizeof(szBuf), "CCountryServer::OnDBReturn_AddWarLog() 添加跨服国战结果信息 nCmdID=%d,nDBRetCode=%d,nQueueIndex=%d,nOutLen=%d",
3986 		nCmdID,nDBRetCode,nQueueIndex,nOutLen);
3987 	TraceLn(szBuf);
4000 	if (pResult->nResult==0)
4001 	{
4002 		ErrorLn("添加跨服国战信息失败！nResult="<<pResult->nResult);
4003 	}
4005 }
4003 	}
4005 }
4007 /** 数据库请求返回回调方法 查询跨服国战结果信息
4008 @param   nCmdID ：命令ＩＤ
4009 @param   nDBRetCode：数据库请求返回值，参考上面定义
4021 	if (sizeof(SWorldCountryWarLogInfo)>sizeof(DB_Table_WorldCountryWarLog))
4022 	{
4023 		ErrorLn("CCountryServer::OnDBReturn_ReadWarLog() 查询跨服国战结果信息失败！原因：sizeof(SWorldCountryWarLogInfo)="<<sizeof(SWorldCountryWarLogInfo)<<">sizeof(DB_Table_WorldCountryWarLog)="<<sizeof(DB_Table_WorldCountryWarLog) );
4024 		return;
4025 	}
4027 	// 调式代码
4028 	char szBuf[512]={0};
4029 	sprintf_s(szBuf, sizeof(szBuf), "CCountryServer::OnDBReturn_ReadWarLog() 查询跨服国战结果信息 nCmdID=%d,nDBRetCode=%d,nQueueIndex=%d,nOutLen=%d",
4030 		nCmdID,nDBRetCode,nQueueIndex,nOutLen);
4031 	TraceLn(szBuf);
4037 	if(pOutData == NULL || nOutLen < sizeof(DB_Result_Read_WorldCountryWarLog))
4038 	{
4039 		ErrorLn("查询跨服国战结果信息数据大小非法，nOutLen = "<<nOutLen);	
4040 	}
4041 	else
4054 		if( nOutLen != (int)( pResult->nRecordCount * sizeof(DB_Table_WorldCountryWarLog) + sizeof(DB_Result_Read_WorldCountryWarLog)) )
4055 		{
4056 			ErrorLn("查询跨服国战结果信息数据条数与大小不符，nOutLen = "<<nOutLen);
4057 		}
4058 		else if (pResult->nRecordCount<1)
4058 		else if (pResult->nRecordCount<1)
4059 		{
4060 			TraceLn("查询跨服国战结果信息数据条数为0，条数 = "<<pResult->nRecordCount);
4061 		}
4062 		else
4110 	if(!obufData.good())
4111 	{
4112 		Error("查询跨服国战结果信息失败， 原因：obuf.good()=false" << endl);
4113 		return;		
4114 	}

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcClient\Client\CountryClient\CountryClient.cpp 133 KB CPP 文件 2014/2/25 8:25:18 2018/10/23 19:51:04 2018/10/23 19:51:04 21
445 		(LPCSTR) &eventSendData, sizeof(SEventCountryPlayerInfoUpdate_C) );	
447 }
449 // 查询跨服国战结果信息
450 void CCountryClient::OnMsgGetWorldWarLogInfo( ulong actionId, SGameMsgHead* head,void* data, size_t len)
451 {
460 #ifdef COUNTRY_PRINT_DEBUG_INF
461 	char szBuf[512]={0};
462 	sprintf_s(szBuf, _countof(szBuf), _NGT"CCountryClient::OnMsgGetWorldWarLogInfo() 查询跨服国战结果信息:bFind=%d",pMsg->bFind);
463 	TraceLn(szBuf);
464 #endif
472 		if(len != sizeof(SWorldCountryWarLogInfo) + sizeof(SMsgCountryHistorySetWarLog_SC))
473 		{
474 			ErrorLn("查询跨服国战结果信息返回数据大小不符，len = "<<len);
475 		}
476 		else
1131 	return &m_FindPlayerInfo;
1132 }
1134 /** 取得跨服国战信息日志信息
1135 @param  
1136 @param   
1135 @param  
1136 @param   
1137 @return  查询到的跨服国战信息日志信息
1138 */
1139 const SWorldCountryWarLogInfo*  CCountryClient::GetWorldCountryWarLogInfo(void)
1141 	return &m_worldWarLogInfo;
1142 }
1145 /** 取得跨服国战信息日志信息的排名节点信息
1146 @param  DWORD dwIndex : 序号
1147 @param   BYTE dwType: 对象类型	1表示玩家，2表示帮会
1146 @param  DWORD dwIndex : 序号
1147 @param   BYTE dwType: 对象类型	1表示玩家，2表示帮会
1148 @return  查询到的跨服国战信息日志信息排名节点信息
1149 */
1150 const SWorldCountryWarOrderNodeInfo*  CCountryClient::GetWorldCountryWarLogOrderNodeInfo(DWORD dwIndex,BYTE dwType)
1178 	pCountryEntityPart->FindPlayerInfo(dwPlayerID,szName);
1179 }
1182 /** 请求取得跨服国战信息日志信息
1183 @param  DWORD dwID 			: 跨服国战日志信息ID
1184 @param  DWORD dwAddTime 	: 跨服国战日志写入时间
1185 */
1186 void  CCountryClient::RequestWorldCountryWarLog(DWORD dwID ,DWORD dwAddTime)
1204 	}
1206 	SMsgCountryHistoryGetWarLog_CS sendData;
1207 	sendData.dwID			= dwID;							// 跨服国战日志信息ID
1208 	sendData.dwAddTime		= dwAddTime;					// 跨服国战日志写入时间
1209 	sendData.dwPlayerID		= pPerson->GetNumProp(CREATURE_PROP_PDBID);		// 查询的角色ID,用来返回找到角色并发给他
1209 	sendData.dwPlayerID		= pPerson->GetNumProp(CREATURE_PROP_PDBID);		// 查询的角色ID,用来返回找到角色并发给他
1211 	// 客户端发送给请求取得跨服国战信息日志信息
1212 	g_ExternalFacade.SendDataToZoneCountry(COUNTRY_GLOBAL_COUNTRYID,MSG_COUNTRY_HISTORY_GET_WARLOG,&sendData,sizeof(sendData) );
1213 }
1302 	return &(iter1->second);
1303 }
1307 /**  请求跨服国战信息
1308 @return  
1309 */
1312 	SMsgCountryWorldRequestInfo_OC sendData;
1313 	sendData.dwLastTime	= m_dwLastWarInfoTime;
1315 	// 客户端发送给请求取得跨服国战信息日志信息
1316 	g_ExternalFacade.SendDataToSocialCountry(COUNTRY_GLOBAL_COUNTRYID,MSG_COUNTRY_WORLDWAR_REQUEST,&sendData,sizeof(sendData) );
1317 	return true;
1440 	return  &(m_pIter2->second);
1442 }
1444 /** 取得跨服国家边境连通信息
1445 @return  SCountryWorldLinkInfo * 边境连通信息
1446 */
1456 	return &(iter->second);
1457 }
1459 /** 取得跨服国家边境连通信息
1460 @return  SCountryWorldLinkInfo * 边境连通信息
1461 */
1471 	return &(iter->second);
1472 }
1475 // 取得跨服国家边境连通编号以(游戏世界ID+国家ID+类型)组数编号 为关键字
1476 DWORD CCountryClient::GetCountryWorldLinkKey(DWORD dwWorldID,DWORD dwCountryID,DWORD dwType)
1477 {
1608 	return ::GetCommandFlagResID();
1609 }
1611 // 检查国家在跨服国战中的参战类型
1612 DWORD CCountryClient::CheckCountryWorldWarType(DWORD dwWorldID,DWORD dwCountryID,SCountryWorldWarInfo &node)
1613 {
1636 	return 0;
1637 }
1640 /** 取得指定国家的跨服国战信息
1641 DWORD dwWorldID			: 游戏世界ID
1642 DWORD dwCountryID		: 国家ID
1692 		if (node.dwStartTime>dwWeekStartTime || (node.dwStartTime>dwTodayStartTime && node.dwStartTime<dwTodayEndTime))
1693 		{
1694 			// 检查国家在跨服国战中的参战类型 0.无,1.攻,2.守,3.攻盟友,4.守盟友
1695 			DWORD dwMyJoinType = CheckCountryWorldWarType(dwWorldID,dwCountryID,node);	// 本国
1696 			if (dwMyJoinType==0)

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcClient\Client\CountryClient\CountryClient.cpp 131 KB CPP 文件 2014/2/25 13:42:00 2018/10/23 19:33:54 2018/10/23 19:33:54 21
445 		(LPCSTR) &eventSendData, sizeof(SEventCountryPlayerInfoUpdate_C) );	
447 }
449 // 查询跨服国战结果信息
450 void CCountryClient::OnMsgGetWorldWarLogInfo( ulong actionId, SGameMsgHead* head,void* data, size_t len)
451 {
460 #ifdef COUNTRY_PRINT_DEBUG_INF
461 	char szBuf[512]={0};
462 	sprintf_s(szBuf, _countof(szBuf), _NGT"CCountryClient::OnMsgGetWorldWarLogInfo() 查询跨服国战结果信息:bFind=%d",pMsg->bFind);
463 	TraceLn(szBuf);
464 #endif
472 		if(len != sizeof(SWorldCountryWarLogInfo) + sizeof(SMsgCountryHistorySetWarLog_SC))
473 		{
474 			ErrorLn("查询跨服国战结果信息返回数据大小不符，len = "<<len);
475 		}
476 		else
1131 	return &m_FindPlayerInfo;
1132 }
1134 /** 取得跨服国战信息日志信息
1135 @param  
1136 @param   
1135 @param  
1136 @param   
1137 @return  查询到的跨服国战信息日志信息
1138 */
1139 const SWorldCountryWarLogInfo*  CCountryClient::GetWorldCountryWarLogInfo(void)
1141 	return &m_worldWarLogInfo;
1142 }
1145 /** 取得跨服国战信息日志信息的排名节点信息
1146 @param  DWORD dwIndex : 序号
1147 @param   BYTE dwType: 对象类型	1表示玩家，2表示帮会
1146 @param  DWORD dwIndex : 序号
1147 @param   BYTE dwType: 对象类型	1表示玩家，2表示帮会
1148 @return  查询到的跨服国战信息日志信息排名节点信息
1149 */
1150 const SWorldCountryWarOrderNodeInfo*  CCountryClient::GetWorldCountryWarLogOrderNodeInfo(DWORD dwIndex,BYTE dwType)
1178 	pCountryEntityPart->FindPlayerInfo(dwPlayerID,szName);
1179 }
1182 /** 请求取得跨服国战信息日志信息
1183 @param  DWORD dwID 			: 跨服国战日志信息ID
1184 @param  DWORD dwAddTime 	: 跨服国战日志写入时间
1185 */
1186 void  CCountryClient::RequestWorldCountryWarLog(DWORD dwID ,DWORD dwAddTime)
1204 	}
1206 	SMsgCountryHistoryGetWarLog_CS sendData;
1207 	sendData.dwID			= dwID;							// 跨服国战日志信息ID
1208 	sendData.dwAddTime		= dwAddTime;					// 跨服国战日志写入时间
1209 	sendData.dwPlayerID		= pPerson->GetNumProp(CREATURE_PROP_PDBID);		// 查询的角色ID,用来返回找到角色并发给他
1209 	sendData.dwPlayerID		= pPerson->GetNumProp(CREATURE_PROP_PDBID);		// 查询的角色ID,用来返回找到角色并发给他
1211 	// 客户端发送给请求取得跨服国战信息日志信息
1212 	g_ExternalFacade.SendDataToZoneCountry(COUNTRY_GLOBAL_COUNTRYID,MSG_COUNTRY_HISTORY_GET_WARLOG,&sendData,sizeof(sendData) );
1213 }
1302 	return &(iter1->second);
1303 }
1307 /**  请求跨服国战信息
1308 @return  
1309 */
1312 	SMsgCountryWorldRequestInfo_OC sendData;
1313 	sendData.dwLastTime	= m_dwLastWarInfoTime;
1315 	// 客户端发送给请求取得跨服国战信息日志信息
1316 	g_ExternalFacade.SendDataToSocialCountry(COUNTRY_GLOBAL_COUNTRYID,MSG_COUNTRY_WORLDWAR_REQUEST,&sendData,sizeof(sendData) );
1317 	return true;
1440 	return  &(m_pIter2->second);
1442 }
1444 /** 取得跨服国家边境连通信息
1445 @return  SCountryWorldLinkInfo * 边境连通信息
1446 */
1456 	return &(iter->second);
1457 }
1459 /** 取得跨服国家边境连通信息
1460 @return  SCountryWorldLinkInfo * 边境连通信息
1461 */
1471 	return &(iter->second);
1472 }
1475 // 取得跨服国家边境连通编号以(游戏世界ID+国家ID+类型)组数编号 为关键字
1476 DWORD CCountryClient::GetCountryWorldLinkKey(DWORD dwWorldID,DWORD dwCountryID,DWORD dwType)
1477 {
1533 	return &(itr->second);
1534 }
1536 // 检查国家在跨服国战中的参战类型
1537 DWORD CCountryClient::CheckCountryWorldWarType(DWORD dwWorldID,DWORD dwCountryID,SCountryWorldWarInfo &node)
1538 {
1561 	return 0;
1562 }
1565 /** 取得指定国家的跨服国战信息
1566 DWORD dwWorldID			: 游戏世界ID
1567 DWORD dwCountryID		: 国家ID
1617 		if (node.dwStartTime>dwWeekStartTime || (node.dwStartTime>dwTodayStartTime && node.dwStartTime<dwTodayEndTime))
1618 		{
1619 			// 检查国家在跨服国战中的参战类型 0.无,1.攻,2.守,3.攻盟友,4.守盟友
1620 			DWORD dwMyJoinType = CheckCountryWorldWarType(dwWorldID,dwCountryID,node);	// 本国
1621 			if (dwMyJoinType==0)

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MatchServer\CountryBorderWar.cpp 70 KB CPP 文件 2014/2/25 0:08:42 2018/10/23 20:06:22 2018/10/23 20:06:22 41
5 ** 日  期:	2011-7-26
6 ** 版  本:	1.0
7 ** 描  述:	跨服边境战场系统
8 ** 应  用:  管理场景服中的所有跨服边境战场
9 	
10 **************************** 修改记录 ******************************
69 CCountryBorderWar::CCountryBorderWar(void)
70 {
71 	// 跨服边境战场状态标识 EMCountryBorderWarRunStep
72 	m_dwWarRunStep	= BorderWarRunStep_None;
72 	m_dwWarRunStep	= BorderWarRunStep_None;
74 	// 跨服边境战场关闭标志 EMCountryBorderWarEndFlag
75 	m_dwForceEndWar	= CountryBorderWarEndFlag_None;
77 	// 战场关闭时间
110 /** 资源事件执行接口
111 @param   WORD wEventID		:事件ID
112 @param   WORD dwPVPClassType:跨服PVP类型 EMPVPClassType
113 @param   WORD dwWarID		:相关战场ID
114 @param   WORD dwResID		:相关战争资源配置ID
125 		return;
126 	}
128 	// 跨服PVP类型不一致
129 	if (dwPVPClassType != GetPVPClass()->GetClass())
130 	{
129 	if (dwPVPClassType != GetPVPClass()->GetClass())
130 	{
131 		ErrorLn("CCountryBorderWar::OnWarResEvent() 跨服PVP类型不一致 dwPVPClassType("<< dwPVPClassType << ") != GetClass("<< GetPVPClass()->GetClass() <<")");
132 		return;
133 	}
188 /** 资源投票事件
189 @param   WORD wEventID		:事件ID
190 @param   WORD dwPVPClassType:跨服PVP类型 EMPVPClassType
191 @param   WORD dwWarID		:相关战场ID
192 @param   WORD dwResID		:相关战争资源配置ID
203 		return false;
204 	}
206 	// 跨服PVP类型不一致
207 	if (dwPVPClassType != GetPVPClass()->GetClass())
208 	{
207 	if (dwPVPClassType != GetPVPClass()->GetClass())
208 	{
209 		ErrorLn("CCountryBorderWar::OnWarResVote() 跨服PVP类型不一致 dwPVPClassType("<< dwPVPClassType << ") != GetClass("<< GetPVPClass()->GetClass() <<")");
210 		return false;
211 	}
357 		pStrikeInfo->dwEnterCamp = STRIKE_VIEWER_CAMPID;
358 	}
360 	// 加入跨服边境战场阵营
361 	bool bRet = CWar::Add(pPerson);
362 	if (bRet==false)
410 	DWORD dwNowTicks = GetTickCount();
411 	DWORD dwOldRunStep = m_dwWarRunStep;	// 旧状态标识
413 	// 跨服边境状态标识 EMCountryBorderWarRunStep
414 	m_dwWarRunStep = dwRunStep;
416 	// 相关处理代码
472 	// 发数据到社会服 
473 	g_pMatchServer->SendDataToSocial(MSG_MATCH_DATE_WARMSG,Match_WarMsg_WarStateChanged,GetID(),GetState(), m_dwWarRunStep);
475 	// 同步回本区更新状态备本区玩家知晓跨服边境战场状态 跨服边境战场执行状态子类型变化
476 	SendDataToBridgeZone(0,Match_WarMsg_BorderWarStepChanged,GetRoomID(),GetState(),m_dwWarRunStep);
478 	return true;
529 bool CCountryBorderWar::InitializeRun(void)
530 {
531 	// 跨服边境战场状态标识 EMCountryBorderWarRunStep
532 	m_dwWarRunStep = BorderWarRunStep_Init;
534 	return true;
720 			if (nExploit>0)
721 			{
722 				pCountryEntityPart->AddCountryExploit(COUNTRY_EXPLOIT_TYPE_KILL,nExploit,OssResAdd_CountryBorderWar,"跨服边境战获取杀人功勋",false);
723 			}
724 			//  增加政绩
725 			if (nCbsScore > 0)
726 			{
727 				pCountryEntityPart->AddCountryContribute(COUNTRY_CONTRIBUTE_TYPE_KILL,nCbsScore,OssResAdd_CountryBorderWar,"跨服边境战获取杀人政绩",false);
728 			}
729 			// 增加本周政绩
730 			if (nCbsScore > 0)
731 			{
732 				pCountryEntityPart->AddCountryHonour(COUNTRY_HONOUR_TYPE_KILL,nCbsScore,OssResAdd_CountryBorderWar,"跨服边境战获取杀人本周政绩",false);
733 			}
734 		}
862 /** 获取指定方向复活点坐标
863 @param   IPerson * pPerson	: 战争玩家
864 @param   DWORD dwTransFlag	: 跨服边境战场传送标识 EMCountryBorderWarTransFlag
865 @param   bool bNeedOffset	: 复活点需要偏移
866 @return POINT 复活点坐标
1083 				// 从玩家包裹中扣除通行证物品
1084 				char szReason[128];
1085 				sprintf_s(szReason,"跨服边境传送至天空战场");
1087 				IShortcutOperate* pShortCutOp = gZoneServiceProvider->GetServerModule()->GetShortcutOperate();
1088 				bool bCanRemove = pShortCutOp->CanRemoveGoods(pPerson,nItemID,1,false,false,true);
1114 // 				// 从玩家包裹中扣除通信证物品
1115 // 				int nRemoveNum = 1;
1116 // 				if (pPacketSkepPart->RemoveBindGoods(nItemID, nRemoveNum, OssResDel_CountryBorderWar, "跨服边境传送至天空战场", true, bySerial, false) == nRemoveNum)
1117 // 				{
1118 // 					// 设置通信证的有效时间
1232 		
1233 		ostrbuf osbTips;
1234 		osbTips << "跨服边境:总人数="<< dwTotalMemberCount<<"，"<< m_WarCamp[CountryWarCamp_Attack].szName << "=" << dwAttackMemberCount << "，" << m_WarCamp[CountryWarCamp_Defend].szName << "=" << dwDefendMemberCount<<"，" << m_WarCamp[dwCamp].szName<<"获胜" ;
1235 		ErrorLn(osbTips.c_str());
1237 		pLogServer->TrackGameNote(ENoteTrackType_Nation, 0, osbTips.c_str());
1242 }
1244 ////ICountryBorderWar//////////////////////////////////////////////////////////////////////
1246 /** 跨服边境战接收外部数据结构信息
1247 @return  SCountryBorderWarInfo *
1248 */
1408 				{
1409 					POINT ptRes = pWarRes->GetMapPoint();
1410 					ErrorLn("跨服边境：主战场中BOSS资源创建失败！资源ID="<<dwWarResIDArray[i]<<"; x="<<ptRes.x<<",y="<<ptRes.y );
1411 				}
1412 			}
1452 				{
1453 					POINT ptRes = pWarRes->GetMapPoint();
1454 					ErrorLn("跨服边境：主战场中BOSS资源创建失败！资源ID="<<dwWarResIDArray[i]<<"; x="<<ptRes.x<<",y="<<ptRes.y );
1455 				}
1456 			}
1632 	SetNumProp(BorderWarNum_OpenSkyTime,	(GetSkyOpenTime() - m_dwStartTime));			// 天空战场开放时间
1633 	SetNumProp(BorderWarNum_CloseSkyTime,	(GetSkyCloseTime() - m_dwStartTime-30));		// 天空战场关闭时间,结束前30秒禁止前往天空战场
1635 	// 发送跨服边境战场创建信息到参战游戏区的所有场景服
1636 	SendWarCreateEventToZone();
1637 }
1646 void CCountryBorderWar::OnEndWar(void)
1647 {
1648 	// 发送跨服边境战场结束信息到参战游戏区的所有场景服
1649 	SendWarEndEventToZone();
1650 }
1671 	}
1673 	DWORD dwDiffTime = m_dwCloseTime - dwNowTime;		// 时间差
1675 	// 发送跨服边境战场信息
1676 	for (DWORD i=0; i<4; i++)
1677 	{
1707 void CCountryBorderWar::CollectGameResource(void)
1708 {
1709 	// 发送跨服边境战场战场关闭信息到参战游戏区的所有场景服
1710 	SendWarCloseEventToZone();
1711 }
1853 			// 调用LUA，处理玩家杀人
1854 			CLuaParam param[6];
1855 			param[0] = GetPVPClass()->GetClass();					// 跨服PVP类型 EMPVPClassType
1856 			param[1] = GetID();										// 相关战场ID
1857 			param[2] = ANALYZEUID_SERIALNO(uidPlayer);				// 凶手
1868 		// 调用LUA，处理玩家杀人
1869 		CLuaParam param[6];
1870 		param[0] = GetPVPClass()->GetClass();					// 跨服PVP类型 EMPVPClassType
1871 		param[1] = GetID();										// 相关战场ID
1872 		param[2] = ANALYZEUID_SERIALNO(killerNode.uidPlayer);	// 凶手
2115 	SetCampWinResult(pPlayerNode->dwCamp+1, bSendResult);
2116 }
2118 // 发送跨服边境战场战场创建信息到参战游戏区的所有场景服
2119 bool CCountryBorderWar::SendWarCreateEventToZone(void)
2120 {
2152 	return SendDataToBridgeZone(0,Match_WarMsg_BorderWarCreate, GetRoomID(),0,0,obufData.data(), obufData.size());
2153 }
2155 // 发送跨服边境战场结束信息到参战游戏区的所有场景服
2156 bool CCountryBorderWar::SendWarEndEventToZone(void)
2157 {
2160 	return SendDataToBridgeZone(0,Match_WarMsg_BorderWarEnd, GetRoomID(),dwServerID,0);
2161 }
2163 // 发送跨服边境战场关闭信息到参战游戏区的所有场景服
2164 bool CCountryBorderWar::SendWarCloseEventToZone(void)
2165 {
2164 bool CCountryBorderWar::SendWarCloseEventToZone(void)
2165 {
2166 	// 更新场景服删除跨服边境战场场景信息
2167 	SMsgWarRemoveWar_SS sendData;
2168 	sendData.dwServerID			= gZoneServiceProvider->GetCenterServerConnector()->GetLocalServerCSID();		// 场景服ID
2240 		return false;
2241 	}
2243 	// 发跨服撮合信息消息 dwServerID:服务器ID ,跨服信息专用
2244 	return g_pMatchServer->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_SendWorldWarResult,dwCountryID,(bIsWin?1:0));
2245 }
2278 				// 游戏结束后回收资源
2279 				CollectGameResource();
2280 				// 设置结束跨服边境战场状态
2281 				SetState(WarState_Close);
2282 				break;
2282 				break;
2283 			}
2285 			// 准备跨服边境战场
2286 			OnReadyWar();
2288 			// 能否开战
2454 			// 设置状态
2455 			SetRunStep(BorderWarRunStep_None);
2457 			// 设置结束跨服边境战场状态
2458 			SetState(WarState_Close);
2459 		}
2500 							{
2501 								POINT ptRes = pWarRes->GetMapPoint();
2502 								ErrorLn("跨服边境：主战场中BOSS资源创建失败！资源ID="<<iter->first<<"; x="<<ptRes.x<<",y="<<ptRes.y );
2503 							}
2504 							else

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcClient\Client\MatchClient\CountryBorderWar.cpp 7 KB CPP 文件 2014/2/25 8:34:41 2018/10/23 19:52:17 2018/10/23 19:52:17 13
5 ** 日  期:	2011-7-26
6 ** 版  本:	1.0
7 ** 描  述:	跨服边境战场系统
8 ** 应  用:  	
9 	
24 CCountryBorderWar::CCountryBorderWar(void)
25 {
26 	// 跨服边境战玩法状态 EMCountryBorderWarRunStep
27 	m_dwState = BorderWarRunStep_None;
27 	m_dwState = BorderWarRunStep_None;
28 	// 跨服边境战玩法状态状态变化时间
29 	m_dwStateTime = 0;
29 	m_dwStateTime = 0;
30 	// 跨服BOSS战基本信息扩展数据结构
31 	memset(&m_WarBaseInfo, 0, sizeof(SCountryBorderWarBaseInfo));
32 }
152 bool CCountryBorderWar::Reset(void)
153 {
154 	// 跨服边境战玩法状态 EMCountryBorderWarRunStep
155 	m_dwState = BorderWarRunStep_None;
155 	m_dwState = BorderWarRunStep_None;
156 	// 跨服边境战玩法状态状态变化时间
157 	m_dwStateTime = 0;
157 	m_dwStateTime = 0;
158 	// 跨服BOSS战基本信息扩展数据结构
159 	memset(&m_WarBaseInfo, 0, sizeof(SCountryBorderWarBaseInfo));
161 	return true;
196 }
198 //////////////////////////////////////////////////////////////////////////
201 /** 取得跨服边境战扩展数据
202 @return
203 */
249 	switch(dwMsgCode)
250 	{
251 	case Match_WarMsg_BorderWarStateChanged:	// 更新跨服边境战状态变化
252 		{
253 			bHasDone = true;
255 			if (nNewlen>0)
256 			{
257 				ErrorLn("收到跨服边境战状态变化信息数据大小不符，nLen = "<<nNewlen);
258 				break;
259 			}
277 		}
278 		break;
279 	case Match_WarMsg_BorderWarAutoJoin:	// 客户端显示并可直接加入跨服边境战
280 		{
281 			bHasDone = true;
283 			if (nNewlen!=0)
284 			{
285 				ErrorLn("收到客户端显示并可直接加入跨服边境战信息到客户端数据大小不符，nLen ="<<nNewlen);
286 				break;
287 			}
301 		{
302 			bHasDone = true;
304 			ErrorLn("跨服边境战场客户端系统有一个服务器战场信息子消息未处理，dwMsgCode = "<< dwMsgCode);
305 		}
306 		break;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MatchServer\CountryBorderWar.cpp 70 KB CPP 文件 2014/2/25 14:26:59 2018/10/23 19:45:09 2018/10/23 19:45:09 41
5 ** 日  期:	2011-7-26
6 ** 版  本:	1.0
7 ** 描  述:	跨服边境战场系统
8 ** 应  用:  管理场景服中的所有跨服边境战场
9 	
10 **************************** 修改记录 ******************************
69 CCountryBorderWar::CCountryBorderWar(void)
70 {
71 	// 跨服边境战场状态标识 EMCountryBorderWarRunStep
72 	m_dwWarRunStep	= BorderWarRunStep_None;
72 	m_dwWarRunStep	= BorderWarRunStep_None;
74 	// 跨服边境战场关闭标志 EMCountryBorderWarEndFlag
75 	m_dwForceEndWar	= CountryBorderWarEndFlag_None;
77 	// 战场关闭时间
110 /** 资源事件执行接口
111 @param   WORD wEventID		:事件ID
112 @param   WORD dwPVPClassType:跨服PVP类型 EMPVPClassType
113 @param   WORD dwWarID		:相关战场ID
114 @param   WORD dwResID		:相关战争资源配置ID
125 		return;
126 	}
128 	// 跨服PVP类型不一致
129 	if (dwPVPClassType != GetPVPClass()->GetClass())
130 	{
129 	if (dwPVPClassType != GetPVPClass()->GetClass())
130 	{
131 		ErrorLn("CCountryBorderWar::OnWarResEvent() 跨服PVP类型不一致 dwPVPClassType("<< dwPVPClassType << ") != GetClass("<< GetPVPClass()->GetClass() <<")");
132 		return;
133 	}
188 /** 资源投票事件
189 @param   WORD wEventID		:事件ID
190 @param   WORD dwPVPClassType:跨服PVP类型 EMPVPClassType
191 @param   WORD dwWarID		:相关战场ID
192 @param   WORD dwResID		:相关战争资源配置ID
203 		return false;
204 	}
206 	// 跨服PVP类型不一致
207 	if (dwPVPClassType != GetPVPClass()->GetClass())
208 	{
207 	if (dwPVPClassType != GetPVPClass()->GetClass())
208 	{
209 		ErrorLn("CCountryBorderWar::OnWarResVote() 跨服PVP类型不一致 dwPVPClassType("<< dwPVPClassType << ") != GetClass("<< GetPVPClass()->GetClass() <<")");
210 		return false;
211 	}
357 		pStrikeInfo->dwEnterCamp = STRIKE_VIEWER_CAMPID;
358 	}
360 	// 加入跨服边境战场阵营
361 	bool bRet = CWar::Add(pPerson);
362 	if (bRet==false)
410 	DWORD dwNowTicks = GetTickCount();
411 	DWORD dwOldRunStep = m_dwWarRunStep;	// 旧状态标识
413 	// 跨服边境状态标识 EMCountryBorderWarRunStep
414 	m_dwWarRunStep = dwRunStep;
416 	// 相关处理代码
472 	// 发数据到社会服 
473 	g_pMatchServer->SendDataToSocial(MSG_MATCH_DATE_WARMSG,Match_WarMsg_WarStateChanged,GetID(),GetState(), m_dwWarRunStep);
475 	// 同步回本区更新状态备本区玩家知晓跨服边境战场状态 跨服边境战场执行状态子类型变化
476 	SendDataToBridgeZone(0,Match_WarMsg_BorderWarStepChanged,GetRoomID(),GetState(),m_dwWarRunStep);
478 	return true;
529 bool CCountryBorderWar::InitializeRun(void)
530 {
531 	// 跨服边境战场状态标识 EMCountryBorderWarRunStep
532 	m_dwWarRunStep = BorderWarRunStep_Init;
534 	return true;
720 			if (nExploit>0)
721 			{
722 				pCountryEntityPart->AddCountryExploit(COUNTRY_EXPLOIT_TYPE_KILL,nExploit,OssResAdd_CountryBorderWar,"跨服边境战获取杀人功勋",false);
723 			}
724 			//  增加政绩
725 			if (nCbsScore > 0)
726 			{
727 				pCountryEntityPart->AddCountryContribute(COUNTRY_CONTRIBUTE_TYPE_KILL,nCbsScore,OssResAdd_CountryBorderWar,"跨服边境战获取杀人政绩",false);
728 			}
729 			// 增加本周政绩
730 			if (nCbsScore > 0)
731 			{
732 				pCountryEntityPart->AddCountryHonour(COUNTRY_HONOUR_TYPE_KILL,nCbsScore,OssResAdd_CountryBorderWar,"跨服边境战获取杀人本周政绩",false);
733 			}
734 		}
862 /** 获取指定方向复活点坐标
863 @param   IPerson * pPerson	: 战争玩家
864 @param   DWORD dwTransFlag	: 跨服边境战场传送标识 EMCountryBorderWarTransFlag
865 @param   bool bNeedOffset	: 复活点需要偏移
866 @return POINT 复活点坐标
1083 				// 从玩家包裹中扣除通行证物品
1084 				char szReason[128];
1085 				sprintf_s(szReason,"跨服边境传送至天空战场");
1087 				IShortcutOperate* pShortCutOp = gZoneServiceProvider->GetServerModule()->GetShortcutOperate();
1088 				bool bCanRemove = pShortCutOp->CanRemoveGoods(pPerson,nItemID,1,false,false,true);
1114 // 				// 从玩家包裹中扣除通信证物品
1115 // 				int nRemoveNum = 1;
1116 // 				if (pPacketSkepPart->RemoveBindGoods(nItemID, nRemoveNum, OssResDel_CountryBorderWar, "跨服边境传送至天空战场", true, bySerial, false) == nRemoveNum)
1117 // 				{
1118 // 					// 设置通信证的有效时间
1232 		
1233 		ostrbuf osbTips;
1234 		osbTips << "跨服边境:总人数="<< dwTotalMemberCount<<"，"<< m_WarCamp[CountryWarCamp_Attack].szName << "=" << dwAttackMemberCount << "，" << m_WarCamp[CountryWarCamp_Defend].szName << "=" << dwDefendMemberCount<<"，" << m_WarCamp[dwCamp].szName<<"获胜" ;
1235 		ErrorLn(osbTips.c_str());
1237 		pLogServer->TrackGameNote(ENoteTrackType_Nation, 0, osbTips.c_str());
1242 }
1244 ////ICountryBorderWar//////////////////////////////////////////////////////////////////////
1246 /** 跨服边境战接收外部数据结构信息
1247 @return  SCountryBorderWarInfo *
1248 */
1408 				{
1409 					POINT ptRes = pWarRes->GetMapPoint();
1410 					ErrorLn("跨服边境：主战场中BOSS资源创建失败！资源ID="<<dwWarResIDArray[i]<<"; x="<<ptRes.x<<",y="<<ptRes.y );
1411 				}
1412 			}
1452 				{
1453 					POINT ptRes = pWarRes->GetMapPoint();
1454 					ErrorLn("跨服边境：主战场中BOSS资源创建失败！资源ID="<<dwWarResIDArray[i]<<"; x="<<ptRes.x<<",y="<<ptRes.y );
1455 				}
1456 			}
1632 	SetNumProp(BorderWarNum_OpenSkyTime,	(GetSkyOpenTime() - m_dwStartTime));			// 天空战场开放时间
1633 	SetNumProp(BorderWarNum_CloseSkyTime,	(GetSkyCloseTime() - m_dwStartTime-30));		// 天空战场关闭时间,结束前30秒禁止前往天空战场
1635 	// 发送跨服边境战场创建信息到参战游戏区的所有场景服
1636 	SendWarCreateEventToZone();
1637 }
1646 void CCountryBorderWar::OnEndWar(void)
1647 {
1648 	// 发送跨服边境战场结束信息到参战游戏区的所有场景服
1649 	SendWarEndEventToZone();
1650 }
1671 	}
1673 	DWORD dwDiffTime = m_dwCloseTime - dwNowTime;		// 时间差
1675 	// 发送跨服边境战场信息
1676 	for (DWORD i=0; i<4; i++)
1677 	{
1707 void CCountryBorderWar::CollectGameResource(void)
1708 {
1709 	// 发送跨服边境战场战场关闭信息到参战游戏区的所有场景服
1710 	SendWarCloseEventToZone();
1711 }
1853 			// 调用LUA，处理玩家杀人
1854 			CLuaParam param[6];
1855 			param[0] = GetPVPClass()->GetClass();					// 跨服PVP类型 EMPVPClassType
1856 			param[1] = GetID();										// 相关战场ID
1857 			param[2] = ANALYZEUID_SERIALNO(uidPlayer);				// 凶手
1868 		// 调用LUA，处理玩家杀人
1869 		CLuaParam param[6];
1870 		param[0] = GetPVPClass()->GetClass();					// 跨服PVP类型 EMPVPClassType
1871 		param[1] = GetID();										// 相关战场ID
1872 		param[2] = ANALYZEUID_SERIALNO(killerNode.uidPlayer);	// 凶手
2115 	SetCampWinResult(pPlayerNode->dwCamp+1, bSendResult);
2116 }
2118 // 发送跨服边境战场战场创建信息到参战游戏区的所有场景服
2119 bool CCountryBorderWar::SendWarCreateEventToZone(void)
2120 {
2152 	return SendDataToBridgeZone(0,Match_WarMsg_BorderWarCreate, GetRoomID(),0,0,obufData.data(), obufData.size());
2153 }
2155 // 发送跨服边境战场结束信息到参战游戏区的所有场景服
2156 bool CCountryBorderWar::SendWarEndEventToZone(void)
2157 {
2160 	return SendDataToBridgeZone(0,Match_WarMsg_BorderWarEnd, GetRoomID(),dwServerID,0);
2161 }
2163 // 发送跨服边境战场关闭信息到参战游戏区的所有场景服
2164 bool CCountryBorderWar::SendWarCloseEventToZone(void)
2165 {
2164 bool CCountryBorderWar::SendWarCloseEventToZone(void)
2165 {
2166 	// 更新场景服删除跨服边境战场场景信息
2167 	SMsgWarRemoveWar_SS sendData;
2168 	sendData.dwServerID			= gZoneServiceProvider->GetCenterServerConnector()->GetLocalServerCSID();		// 场景服ID
2240 		return false;
2241 	}
2243 	// 发跨服撮合信息消息 dwServerID:服务器ID ,跨服信息专用
2244 	return g_pMatchServer->SendDataBridgeToServer(dwSendServerID,MSG_MATCH_DATE_WARMSG,Match_WarMsg_SendWorldWarResult,dwCountryID,(bIsWin?1:0));
2245 }
2278 				// 游戏结束后回收资源
2279 				CollectGameResource();
2280 				// 设置结束跨服边境战场状态
2281 				SetState(WarState_Close);
2282 				break;
2282 				break;
2283 			}
2285 			// 准备跨服边境战场
2286 			OnReadyWar();
2288 			// 能否开战
2454 			// 设置状态
2455 			SetRunStep(BorderWarRunStep_None);
2457 			// 设置结束跨服边境战场状态
2458 			SetState(WarState_Close);
2459 		}
2500 							{
2501 								POINT ptRes = pWarRes->GetMapPoint();
2502 								ErrorLn("跨服边境：主战场中BOSS资源创建失败！资源ID="<<iter->first<<"; x="<<ptRes.x<<",y="<<ptRes.y );
2503 							}
2504 							else

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcClient\Client\MatchClient\CountryBorderWar.cpp 7 KB CPP 文件 2014/2/25 13:44:48 2018/10/23 19:34:25 2018/10/23 19:34:25 13
5 ** 日  期:	2011-7-26
6 ** 版  本:	1.0
7 ** 描  述:	跨服边境战场系统
8 ** 应  用:  	
9 	
24 CCountryBorderWar::CCountryBorderWar(void)
25 {
26 	// 跨服边境战玩法状态 EMCountryBorderWarRunStep
27 	m_dwState = BorderWarRunStep_None;
27 	m_dwState = BorderWarRunStep_None;
28 	// 跨服边境战玩法状态状态变化时间
29 	m_dwStateTime = 0;
29 	m_dwStateTime = 0;
30 	// 跨服BOSS战基本信息扩展数据结构
31 	memset(&m_WarBaseInfo, 0, sizeof(SCountryBorderWarBaseInfo));
32 }
152 bool CCountryBorderWar::Reset(void)
153 {
154 	// 跨服边境战玩法状态 EMCountryBorderWarRunStep
155 	m_dwState = BorderWarRunStep_None;
155 	m_dwState = BorderWarRunStep_None;
156 	// 跨服边境战玩法状态状态变化时间
157 	m_dwStateTime = 0;
157 	m_dwStateTime = 0;
158 	// 跨服BOSS战基本信息扩展数据结构
159 	memset(&m_WarBaseInfo, 0, sizeof(SCountryBorderWarBaseInfo));
161 	return true;
196 }
198 //////////////////////////////////////////////////////////////////////////
201 /** 取得跨服边境战扩展数据
202 @return
203 */
249 	switch(dwMsgCode)
250 	{
251 	case Match_WarMsg_BorderWarStateChanged:	// 更新跨服边境战状态变化
252 		{
253 			bHasDone = true;
255 			if (nNewlen>0)
256 			{
257 				ErrorLn("收到跨服边境战状态变化信息数据大小不符，nLen = "<<nNewlen);
258 				break;
259 			}
277 		}
278 		break;
279 	case Match_WarMsg_BorderWarAutoJoin:	// 客户端显示并可直接加入跨服边境战
280 		{
281 			bHasDone = true;
283 			if (nNewlen!=0)
284 			{
285 				ErrorLn("收到客户端显示并可直接加入跨服边境战信息到客户端数据大小不符，nLen ="<<nNewlen);
286 				break;
287 			}
301 		{
302 			bHasDone = true;
304 			ErrorLn("跨服边境战场客户端系统有一个服务器战场信息子消息未处理，dwMsgCode = "<< dwMsgCode);
305 		}
306 		break;

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\EnterManager\ConnectStateTrek.cpp 7 KB CPP 文件 2014/2/25 0:06:33 2018/10/23 20:04:20 2018/10/23 20:04:20 1
232 	m_pTerminal->SetPerson(NULL);
235 	m_pTerminal->Kickout(EKickoutClient_Reason_StarTrekFailed, 
236 		"跨服出现异常，错误代码：0xA998DE22，请尝试重新登录或者截图联系游戏管理员处理！！");
237 }

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\EnterManager\ConnectStateTrek.cpp 7 KB CPP 文件 2014/2/25 14:24:27 2018/10/23 19:43:36 2018/10/23 19:43:36 1
232 	m_pTerminal->SetPerson(NULL);
235 	m_pTerminal->Kickout(EKickoutClient_Reason_StarTrekFailed, 
236 		"跨服出现异常，错误代码：0xA998DE22，请尝试重新登录或者截图联系游戏管理员处理！！");
237 }

I:\work\source\蜀山神话\[src.cool]蜀山神话\src\server\gamesvr\CombatManager.cpp 28 KB CPP 文件 2012/4/21 1:05:17 2018/10/23 13:25:09 2018/10/23 13:25:09 1
877 bool CombatManager::IsStateValid(UINT32 duration, INT32 e_type)
878 {
879 	// 判断BUFF跨服时是否要保留
880     if (0 == duration)
881     {

I:\work\source\将军令\将军令源码\将军令源码\LIUJIA\甲1资源\sources\MTServer\MTServer\cMailTradeServer.cpp 8 KB CPP 文件 2013/5/30 1:04:18 2018/10/19 14:16:13 2018/10/19 14:16:13 1
59 	case MSG_MT_PING:
60 		{
61 			/*if (!m_pServerLink)*/ m_pServerLink = pLink; // 不跨服...
62 			
63 			//printf("Received ping from game server...\n");

I:\work\source\将军令\[src.cool]将军令全套源码\MTServer\MTServer\cMailTradeServer.cpp 8 KB CPP 文件 2013/5/30 1:04:20 2018/10/19 14:12:40 2018/10/19 14:12:40 1
59 	case MSG_MT_PING:
60 		{
61 			/*if (!m_pServerLink)*/ m_pServerLink = pLink; // 不跨服...
62 			
63 			//printf("Received ping from game server...\n");

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Cluster\LoginServer\ClientState_Game.cpp 20 KB CPP 文件 2014/2/25 0:01:20 2018/10/23 20:03:36 2018/10/23 20:03:36 1
530 				strBody += m_strPassword;
531 				strBody += "，请妥善保管好您的帐号及密码，祝您在《远征OL》游戏中玩的开心！《远征OL》官方网站：yz.szgla.com。";
532 				//strBody += "《远征OL》官方网站：http://yz.szgla.com。《远征OL》——以中国神话为背景2D热血PK网游。为战而生，四大职业随时自由切换，拒绝一职定终身。盛世跨服激战模式，体验最热血的PK激情。游戏画面唯美华丽，世界互通无缝连接，千人超大阵容PK享受无限乐趣。领先微端技术，史上最小的2M客户端，九秒进游戏，畅享热血PK之旅。《远征OL》获年度最受欢迎网络游戏(颁奖单位：17173）,新锐网络游戏(颁奖单位:腾讯)等16项专业大奖。";
534 			// 签名:(toemails+subject+body+key).md5()
535 			string strSign = strEmail;

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Cluster\LoginServer2\ClientState_Game.cpp 20 KB CPP 文件 2014/2/25 0:01:59 2018/10/23 20:03:38 2018/10/23 20:03:38 1
530 				strBody += m_strPassword;
531 				strBody += "，请妥善保管好您的帐号及密码，祝您在《远征OL》游戏中玩的开心！《远征OL》官方网站：yz.szgla.com。";
532 				//strBody += "《远征OL》官方网站：http://yz.szgla.com。《远征OL》——以中国神话为背景2D热血PK网游。为战而生，四大职业随时自由切换，拒绝一职定终身。盛世跨服激战模式，体验最热血的PK激情。游戏画面唯美华丽，世界互通无缝连接，千人超大阵容PK享受无限乐趣。领先微端技术，史上最小的2M客户端，九秒进游戏，畅享热血PK之旅。《远征OL》获年度最受欢迎网络游戏(颁奖单位：17173）,新锐网络游戏(颁奖单位:腾讯)等16项专业大奖。";
534 			// 签名:(toemails+subject+body+key).md5()
535 			string strSign = strEmail;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Cluster\LoginServer\ClientState_Game.cpp 20 KB CPP 文件 2014/2/25 14:20:46 2018/10/23 19:41:14 2018/10/23 19:41:14 1
530 				strBody += m_strPassword;
531 				strBody += "，请妥善保管好您的帐号及密码，祝您在《远征OL》游戏中玩的开心！《远征OL》官方网站：yz.szgla.com。";
532 				//strBody += "《远征OL》官方网站：http://yz.szgla.com。《远征OL》——以中国神话为背景2D热血PK网游。为战而生，四大职业随时自由切换，拒绝一职定终身。盛世跨服激战模式，体验最热血的PK激情。游戏画面唯美华丽，世界互通无缝连接，千人超大阵容PK享受无限乐趣。领先微端技术，史上最小的2M客户端，九秒进游戏，畅享热血PK之旅。《远征OL》获年度最受欢迎网络游戏(颁奖单位：17173）,新锐网络游戏(颁奖单位:腾讯)等16项专业大奖。";
534 			// 签名:(toemails+subject+body+key).md5()
535 			string strSign = strEmail;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Cluster\LoginServer2\ClientState_Game.cpp 20 KB CPP 文件 2014/2/25 14:21:04 2018/10/23 19:41:27 2018/10/23 19:41:27 1
530 				strBody += m_strPassword;
531 				strBody += "，请妥善保管好您的帐号及密码，祝您在《远征OL》游戏中玩的开心！《远征OL》官方网站：yz.szgla.com。";
532 				//strBody += "《远征OL》官方网站：http://yz.szgla.com。《远征OL》——以中国神话为背景2D热血PK网游。为战而生，四大职业随时自由切换，拒绝一职定终身。盛世跨服激战模式，体验最热血的PK激情。游戏画面唯美华丽，世界互通无缝连接，千人超大阵容PK享受无限乐趣。领先微端技术，史上最小的2M客户端，九秒进游戏，畅享热血PK之旅。《远征OL》获年度最受欢迎网络游戏(颁奖单位：17173）,新锐网络游戏(颁奖单位:腾讯)等16项专业大奖。";
534 			// 签名:(toemails+subject+body+key).md5()
535 			string strSign = strEmail;

I:\work\source\神仙传\[src.cool]神仙传\GAME\Project1\ZoneClientEditor\Source\Gameplay\ClientGameplayState.cpp 30 KB CPP 文件 2010/3/23 20:40:12 2018/10/23 13:31:17 2018/10/23 13:31:17 1
178 	//配方数据
179 	g_PrescriptionRepository.read();
180 	//跨服寻径
181 	g_StrideRepository.read();
182 	//宠物数据

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\ClanService\ClanService.cpp 113 KB CPP 文件 2014/2/25 0:21:17 2018/10/23 20:08:52 2018/10/23 20:08:52 6
1690 	else if (nTriggerID == CLAN_FRESH_MATRIX_TRIGGERID)		// 更新帮会阵法
1691 	{
1692 		// 取得跨服组队撮合系统服务
1693 		IMatchService *pMatchService = gGlobalSocialServer->GetMatchService();
1694 		if (pMatchService == NULL)
2762 		return;
2763 	}
2764 	// 取得跨服组队撮合系统服务
2765 	IMatchService *pMatchService = gGlobalSocialServer->GetMatchService();
2766 	if (pMatchService == NULL)
2983 void CClanService::AgainSetClanMatrixClearData(void)
2984 {
2985 	// 取得跨服组队撮合系统服务
2986 	IMatchService *pMatchService = gGlobalSocialServer->GetMatchService();
2987 	if (pMatchService == NULL)
3005 void CClanService::AgainSetClanMatrixSetData(void)
3006 {
3007 	// 取得跨服组队撮合系统服务
3008 	IMatchService *pMatchService = gGlobalSocialServer->GetMatchService();
3009 	if (pMatchService == NULL)
3027 void CClanService::SetMatrixClanPlace(const SMATRIX_CLAN_PLACE &sClanPlace)
3028 {
3029 	// 取得跨服组队撮合系统服务
3030 	IMatchService *pMatchService = gGlobalSocialServer->GetMatchService();
3031 	if (pMatchService == NULL)
3049 void CClanService::OpenCheckMatrixDataTimer(void)
3050 {
3051 	// 取得跨服组队撮合系统服务
3052 	IMatchService *pMatchService = gGlobalSocialServer->GetMatchService();
3053 	if (pMatchService == NULL)

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\ClanService\ClanService.cpp 113 KB CPP 文件 2014/2/25 14:30:43 2018/10/23 19:46:32 2018/10/23 19:46:32 6
1690 	else if (nTriggerID == CLAN_FRESH_MATRIX_TRIGGERID)		// 更新帮会阵法
1691 	{
1692 		// 取得跨服组队撮合系统服务
1693 		IMatchService *pMatchService = gGlobalSocialServer->GetMatchService();
1694 		if (pMatchService == NULL)
2762 		return;
2763 	}
2764 	// 取得跨服组队撮合系统服务
2765 	IMatchService *pMatchService = gGlobalSocialServer->GetMatchService();
2766 	if (pMatchService == NULL)
2983 void CClanService::AgainSetClanMatrixClearData(void)
2984 {
2985 	// 取得跨服组队撮合系统服务
2986 	IMatchService *pMatchService = gGlobalSocialServer->GetMatchService();
2987 	if (pMatchService == NULL)
3005 void CClanService::AgainSetClanMatrixSetData(void)
3006 {
3007 	// 取得跨服组队撮合系统服务
3008 	IMatchService *pMatchService = gGlobalSocialServer->GetMatchService();
3009 	if (pMatchService == NULL)
3027 void CClanService::SetMatrixClanPlace(const SMATRIX_CLAN_PLACE &sClanPlace)
3028 {
3029 	// 取得跨服组队撮合系统服务
3030 	IMatchService *pMatchService = gGlobalSocialServer->GetMatchService();
3031 	if (pMatchService == NULL)
3049 void CClanService::OpenCheckMatrixDataTimer(void)
3050 {
3051 	// 取得跨服组队撮合系统服务
3052 	IMatchService *pMatchService = gGlobalSocialServer->GetMatchService();
3053 	if (pMatchService == NULL)

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MatchServer\ClanBossWar.cpp 64 KB CPP 文件 2014/2/25 0:08:41 2018/10/23 20:06:22 2018/10/23 20:06:22 42
5 ** 日  期:	2011-7-26
6 ** 版  本:	1.0
7 ** 描  述:	跨服帮会BOSS战场系统
8 ** 应  用:  管理场景服中的所有跨服帮会BOSS战场战场	
9 	
10 **************************** 修改记录 ******************************
63 CClanBossWar::CClanBossWar(void)
64 {
65 	// 跨服跨服帮会BOSS战场信息ID，0为无效ID
66 	m_dwTaskWorldWarID		= 0;
67 	
68 	// 所属公共区世界ID
69 	m_dwTaskPublicWorldID	= 0;
71 	// 跨服帮会BOSS战场状态标识 EMClanBossWarRunStep
72 	m_dwWarRunStep	= ClanBossWarRunStep_None;
72 	m_dwWarRunStep	= ClanBossWarRunStep_None;
74 	// 跨服帮会BOSS战场关闭标志 EMBossWarEndFlag
75 	m_dwForceEndWar	= ClanBossWarEndFlag_None;
77 	// 战场关闭时间
96 /** 资源事件执行接口
97 @param   WORD wEventID		:事件ID
98 @param   WORD dwPVPClassType:跨服PVP类型 EMPVPClassType
99 @param   WORD dwWarID		:相关战场ID
100 @param   WORD dwResID		:相关战争资源配置ID
111 		return;
112 	}
114 	// 跨服PVP类型不一致
115 	if (dwPVPClassType != GetPVPClass()->GetClass())
116 	{
115 	if (dwPVPClassType != GetPVPClass()->GetClass())
116 	{
117 		ErrorLn("CClanBossWar::OnWarResEvent() 跨服PVP类型不一致 dwPVPClassType("<< dwPVPClassType << ") != GetClass("<< GetPVPClass()->GetClass() <<")");
118 		return;
119 	}
159 /** 资源投票事件
160 @param   WORD wEventID		:事件ID
161 @param   WORD dwPVPClassType:跨服PVP类型 EMPVPClassType
162 @param   WORD dwWarID		:相关战场ID
163 @param   WORD dwResID		:相关战争资源配置ID
174 		return false;
175 	}
177 	// 跨服PVP类型不一致
178 	if (dwPVPClassType != GetPVPClass()->GetClass())
179 	{
178 	if (dwPVPClassType != GetPVPClass()->GetClass())
179 	{
180 		ErrorLn("CClanBossWar::OnWarResVote() 跨服PVP类型不一致 dwPVPClassType("<< dwPVPClassType << ") != GetClass("<< GetPVPClass()->GetClass() <<")");
181 		return false;
182 	}
299 		pStrikeInfo->dwEnterCamp = STRIKE_VIEWER_CAMPID;
300 	}
302 	// 加入跨服帮会BOSS战场阵营
303 	bool bRet = CWar::Add(pPerson);
304 	if (bRet==false)
364 	DWORD dwNowTicks = GetTickCount();
365 	DWORD dwOldRunStep = m_dwWarRunStep;	// 旧状态标识
367 	// 跨服帮会BOSS战场状态标识 EMBossWarRunStep
368 	m_dwWarRunStep = dwRunStep;
370 	// 相关处理代码
430 	// 发数据到社会服 
431 	g_pMatchServer->SendDataToSocial(MSG_MATCH_DATE_WARMSG,Match_WarMsg_WarStateChanged,GetID(),GetState(), m_dwWarRunStep);
433 	// 同步回本区更新状态备本区玩家知晓跨服帮会BOSS战场状态 跨服帮会BOSS战场执行状态子类型变化
434 	SendDataToBridgeZone(0,Match_WarMsg_ClanBossWarStepChanged,GetRoomID(),GetState(),m_dwWarRunStep);
436 	return true;
548 bool CClanBossWar::InitializeRun(void)
549 {
550 	// 跨服帮会BOSS战场状态标识 EMClanBossWarRunStep
551 	m_dwWarRunStep = ClanBossWarRunStep_Init;
553 	return true;
576 	int nCurTime = (int)time(NULL);
577 	char szMsgBuf[512] = {0};
579 	// 跨服帮会BOSS战场战场子状态标识
580 	// 2011-11-1 修改：先进入杀人就有积分处理
581 	//if (m_dwWarRunStep!=ClanBossWarRunStep_Start && m_dwWarRunStep!=ClanBossWarRunStep_Running)
810 }
813 ////IBossWar//////////////////////////////////////////////////////////////////////
815 /** 跨服BOSS战接收外部数据结构信息
816 @return  SWorldBossWarInfo *
817 */
955 	// 资源初始化值		
956 	SetNumProp(BossWarNum_Boss, 100);			// BOSS血量百分比
958 	// 发送跨服帮会BOSS战场战场创建信息到参战游戏区的所有场景服
959 	SendWarCreateEventToZone();
960 }
1115 		}
1116 	}
1118 	// 发送跨服帮会BOSS战场战场结束信息到参战游戏区的所有场景服
1119 	SendWarEndEventToZone();
1120 }
1141 	}
1143 	DWORD dwDiffTime = m_dwCloseTime - dwNowTime;		// 时间差
1145 	// 发送跨服帮会BOSS战场信息
1146 	for (DWORD i=0; i<4; i++)
1147 	{
1235 		}
1236 	}
1238 	SWorldClanBossWarResultInfo warResultInfo;						// 发送到客户端的跨服帮会BOSS战日志信息
1239 	warResultInfo.dwPlayTime = (DWORD)time(NULL) - m_dwStartTime;	// 战斗持续时间
1241 	// 排序序号处理
1295 	// 玩家奖励处理
1296 	char szBuf[512]		= {0};
1297 	int nMaxMoney		= g_pMatchServer->GetWarConfigNumber(WarCfgNum_ClanBoss_MaxMoney);				// 跨服帮会BOSS-获得最高绑金
1298 	int nOtherMoney		= g_pMatchServer->GetWarConfigNumber(WarCfgNum_ClanBoss_OtherMoney);			// 跨服帮会BOSS-完成任务后可获赠送绑金
1299 	DWORD dwAdjLevel	= (DWORD)g_pMatchServer->GetWarConfigNumber(WarCfgNum_ClanBoss_AdjLevel);		// 跨服帮会BOSS-经验调节等级
1300 	DWORD dwConst1		= (DWORD)g_pMatchServer->GetWarConfigNumber(WarCfgNum_ClanBoss_Const1);			// 跨服帮会BOSS-经验调节常量1
1301 	DWORD dwConst2		= (DWORD)g_pMatchServer->GetWarConfigNumber(WarCfgNum_ClanBoss_Const2);			// 跨服帮会BOSS-经验调节常量2
1302 	DWORD dwConst3		= (DWORD)g_pMatchServer->GetWarConfigNumber(WarCfgNum_ClanBoss_Const3);			// 跨服帮会BOSS-经验调节常量3
1304 	// 每个参战帮会成员获取奖励
1305 	for (DWORD i=0; i<m_WarCamp.size(); i++)
1505 void CClanBossWar::CollectGameResource(void)
1506 {
1507 	// 发送跨服帮会BOSS战场战场关闭信息到参战游戏区的所有场景服
1508 	SendWarCloseEventToZone();
1509 }
1620 	// 发送玩家获取积分事件
1621 	SEventMatchCountryWarGetScore_S eventData;
1622 	eventData.dwPVPClassType	= GetPVPClass()->GetClass();					// 跨服PVP类型 EMPVPClassType
1623 	eventData.dwWarID			= GetID();										// 相关战场ID
1624 	eventData.uidPlayer			= playerNode.uidPlayer;							// 玩家UID
1638 	//{
1639 	//	CLuaParam param[5];
1640 	//	param[0] = eventData.dwPVPClassType;						//	跨服PVP类型 EMPVPClassType
1641 	//	param[1] = eventData.dwWarID;								//	相关战场ID
1642 	//	param[2] = ANALYZEUID_SERIALNO(eventData.uidPlayer);		//	玩家序列号
1759 			// 调用LUA，处理玩家杀人
1760 			CLuaParam param[6];
1761 			param[0] = GetPVPClass()->GetClass();					// 跨服PVP类型 EMPVPClassType
1762 			param[1] = GetID();										// 相关战场ID
1763 			param[2] = ANALYZEUID_SERIALNO(uidPlayer);				// 凶手
1774 		// 调用LUA，处理玩家杀人
1775 		CLuaParam param[6];
1776 		param[0] = GetPVPClass()->GetClass();					// 跨服PVP类型 EMPVPClassType
1777 		param[1] = GetID();										// 相关战场ID
1778 		param[2] = ANALYZEUID_SERIALNO(killerNode.uidPlayer);	// 凶手
1798 		return false;
1799 	}
1801 	// 跨服帮会BOSS-基础积分杀人数
1802 	DWORD dwTaskKillCount	= (DWORD)g_pMatchServer->GetWarConfigNumber(WarCfgNum_ClanBoss_TaskKillCount);
1804 	// 完成任务的标准积分
1919 	}
1920 }
1922 // 发送跨服帮会BOSS战场战场创建信息到参战游戏区的所有场景服
1923 bool CClanBossWar::SendWarCreateEventToZone(void)
1924 {
1964 	return SendDataToBridgeZone(0,Match_WarMsg_ClanBossWarCreate, GetRoomID(),0,0,obufData.data(), obufData.size());
1965 }
1967 // 发送跨服帮会BOSS战场结束信息到参战游戏区的所有场景服
1968 bool CClanBossWar::SendWarEndEventToZone(void)
1969 {
1972 	return SendDataToBridgeZone(0,Match_WarMsg_ClanBossWarEnd, GetRoomID(),dwServerID,0);
1973 }
1975 // 发送跨服帮会BOSS战场关闭信息到参战游戏区的所有场景服
1976 bool CClanBossWar::SendWarCloseEventToZone(void)
1977 {
1976 bool CClanBossWar::SendWarCloseEventToZone(void)
1977 {
1978 	// 更新场景服删除跨服帮会BOSS战场场景信息
1979 	SMsgWarRemoveWar_SS sendData;
1980 	sendData.dwServerID			= gZoneServiceProvider->GetCenterServerConnector()->GetLocalServerCSID();		// 场景服ID
2070 				// 游戏结束后回收资源
2071 				CollectGameResource();
2072 				// 设置结束跨服帮会BOSS战场状态
2073 				SetState(WarState_Close);
2074 				break;
2074 				break;
2075 			}
2077 			// 准备跨服帮会BOSS战场
2078 			OnReadyWar();
2080 			// 能否开战
2177 			// 设置状态
2178 			SetRunStep(ClanBossWarRunStep_None);
2180 			// 设置结束跨服帮会BOSS战场状态
2181 			SetState(WarState_Close);
2182 		}

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcClient\Client\MatchClient\ClanBossWar.cpp 13 KB CPP 文件 2014/2/25 8:34:40 2018/10/23 19:52:17 2018/10/23 19:52:17 23
5 ** 日  期:	2011-7-26
6 ** 版  本:	1.0
7 ** 描  述:	跨服帮会BOSS战场系统
8 ** 应  用:  	
9 	
24 CClanBossWar::CClanBossWar(void)
25 {
26 	// 跨服帮会BOSS战玩法状态 EMClanBossWarRunStep
27 	m_dwState = ClanBossWarRunStep_None;
27 	m_dwState = ClanBossWarRunStep_None;
28 	// 跨服帮会BOSS战玩法状态状态变化时间
29 	m_dwStateTime = 0;
30 	// 呆在复活点的时长
32 	// 本帮帮会积分
33 	m_dwClanScore = 0;
34 	// 跨服BOSS战基本信息扩展数据结构
35 	memset(&m_WarBaseInfo, 0, sizeof(SWorldClanBossWarBaseInfo));
36 	// 结果数据
157 bool CClanBossWar::Reset(void)
158 {
159 	// 跨服帮会BOSS战玩法状态 EMClanBossWarRunStep
160 	m_dwState = ClanBossWarRunStep_None;
160 	m_dwState = ClanBossWarRunStep_None;
161 	// 跨服帮会BOSS战玩法状态状态变化时间
162 	m_dwStateTime = 0;
163 	// 呆在复活点的时长
165 	// 本帮帮会积分
166 	m_dwClanScore = 0;
167 	// 跨服BOSS战基本信息扩展数据结构
168 	memset(&m_WarBaseInfo, 0, sizeof(SWorldClanBossWarBaseInfo));
169 	// 结果数据
207 }
209 //////////////////////////////////////////////////////////////////////////
212 /** 取得跨服帮会BOSS战扩展数据
213 @return
214 */
217 	return &m_WarBaseInfo;
218 }
220 /** 取得跨服帮会BOSS战本帮帮会详细数据,dwCampID为0则找自己帮会信息
221 @return
222 */
241 	return &(m_WarBaseInfo.clans[dwCamp]);
242 }
244 /** 取得跨服帮会BOSS战帮会详细数据
245 @param DWORD dwClanID : 帮会ID
246 @return
265 	return NULL;
266 }
269 /** 取得跨服帮会BOSS战结果日志信息
270 @return  跨服帮会BOSS战结果日志信息
271 */
272 SWorldClanBossWarResultInfo* CClanBossWar::GetWorldWarResultInfo(void)
274 	return &m_WarResultInfo;
275 }
277 /** 取得跨服帮会BOSS战日志信息的排名节点信息
278 @param  DWORD dwIndex	: 序号
279 @param  BYTE dwType		: 对象类型	1表示玩家，2表示帮会
278 @param  DWORD dwIndex	: 序号
279 @param  BYTE dwType		: 对象类型	1表示玩家，2表示帮会
280 @return  查询到的跨服帮会BOSS战日志信息排名节点信息
281 */
282 const SWorldClanBossWarOrderNodeInfo*  CClanBossWar::GetWorldWarLogOrderNodeInfo(DWORD dwIndex,BYTE dwType)
306 }
308 /** 获取本帮帮会积分数据
309 @param DWORD dwScoreID : 跨服帮会BOSS战积分类型ID EMWarScoreFlag  
310 @return
311 */
427 	switch(dwMsgCode)
428 	{
429 	case Match_WarMsg_ClanBossStateChanged:	// 更新跨服帮会BOSS战状态变化
430 		{
431 			bHasDone = true;
433 			if (nNewlen>0)
434 			{
435 				ErrorLn("收到跨服帮会BOSS战状态变化信息数据大小不符，nLen = "<<nNewlen);
436 				break;
437 			}
479 		}
480 		break;
481 	case Match_WarMsg_ClanBossWarResultInfo:		// 更新跨服帮会BOSS战场信息结果日志信息到客户端
482 		{
483 			bHasDone = true;
485 			if (nNewlen!=sizeof(SWorldClanBossWarResultInfo))
486 			{
487 				ErrorLn("更新跨服战场信息结果日志信息到客户端数据大小不符，nLen = "<<nNewlen);
488 				break;
489 			}
492 			DWORD dwPlayerID	= dwUserData2;		// 玩家角色ID
493 			DWORD dwCamp		= dwUserData3;		// 玩家阵营序号
495 			// 跨服帮会BOSS战场信息结果日志信息
496 			m_WarResultInfo		= (*((SWorldClanBossWarResultInfo *)pMsgData));
499 			// 返回请求结果给Lua
512 		}
513 		break;
514 	case Match_WarMsg_ClanBossWarAutoJoin:	// 客户端显示并可直接加入跨服帮会BOSS战
515 		{
516 			bHasDone = true;
518 			if (nNewlen!=0)
519 			{
520 				ErrorLn("收到客户端显示并可直接加入跨服帮会BOSS战信息到客户端数据大小不符，nLen ="<<nNewlen);
521 				break;
522 			}
536 		{
537 			bHasDone = true;
539 			ErrorLn("跨服帮会BOSS战场客户端系统有一个服务器战场信息子消息未处理，dwMsgCode = "<< dwMsgCode);
540 		}
541 		break;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MatchServer\ClanBossWar.cpp 64 KB CPP 文件 2014/2/25 14:26:58 2018/10/23 19:45:08 2018/10/23 19:45:08 42
5 ** 日  期:	2011-7-26
6 ** 版  本:	1.0
7 ** 描  述:	跨服帮会BOSS战场系统
8 ** 应  用:  管理场景服中的所有跨服帮会BOSS战场战场	
9 	
10 **************************** 修改记录 ******************************
63 CClanBossWar::CClanBossWar(void)
64 {
65 	// 跨服跨服帮会BOSS战场信息ID，0为无效ID
66 	m_dwTaskWorldWarID		= 0;
67 	
68 	// 所属公共区世界ID
69 	m_dwTaskPublicWorldID	= 0;
71 	// 跨服帮会BOSS战场状态标识 EMClanBossWarRunStep
72 	m_dwWarRunStep	= ClanBossWarRunStep_None;
72 	m_dwWarRunStep	= ClanBossWarRunStep_None;
74 	// 跨服帮会BOSS战场关闭标志 EMBossWarEndFlag
75 	m_dwForceEndWar	= ClanBossWarEndFlag_None;
77 	// 战场关闭时间
96 /** 资源事件执行接口
97 @param   WORD wEventID		:事件ID
98 @param   WORD dwPVPClassType:跨服PVP类型 EMPVPClassType
99 @param   WORD dwWarID		:相关战场ID
100 @param   WORD dwResID		:相关战争资源配置ID
111 		return;
112 	}
114 	// 跨服PVP类型不一致
115 	if (dwPVPClassType != GetPVPClass()->GetClass())
116 	{
115 	if (dwPVPClassType != GetPVPClass()->GetClass())
116 	{
117 		ErrorLn("CClanBossWar::OnWarResEvent() 跨服PVP类型不一致 dwPVPClassType("<< dwPVPClassType << ") != GetClass("<< GetPVPClass()->GetClass() <<")");
118 		return;
119 	}
159 /** 资源投票事件
160 @param   WORD wEventID		:事件ID
161 @param   WORD dwPVPClassType:跨服PVP类型 EMPVPClassType
162 @param   WORD dwWarID		:相关战场ID
163 @param   WORD dwResID		:相关战争资源配置ID
174 		return false;
175 	}
177 	// 跨服PVP类型不一致
178 	if (dwPVPClassType != GetPVPClass()->GetClass())
179 	{
178 	if (dwPVPClassType != GetPVPClass()->GetClass())
179 	{
180 		ErrorLn("CClanBossWar::OnWarResVote() 跨服PVP类型不一致 dwPVPClassType("<< dwPVPClassType << ") != GetClass("<< GetPVPClass()->GetClass() <<")");
181 		return false;
182 	}
299 		pStrikeInfo->dwEnterCamp = STRIKE_VIEWER_CAMPID;
300 	}
302 	// 加入跨服帮会BOSS战场阵营
303 	bool bRet = CWar::Add(pPerson);
304 	if (bRet==false)
364 	DWORD dwNowTicks = GetTickCount();
365 	DWORD dwOldRunStep = m_dwWarRunStep;	// 旧状态标识
367 	// 跨服帮会BOSS战场状态标识 EMBossWarRunStep
368 	m_dwWarRunStep = dwRunStep;
370 	// 相关处理代码
430 	// 发数据到社会服 
431 	g_pMatchServer->SendDataToSocial(MSG_MATCH_DATE_WARMSG,Match_WarMsg_WarStateChanged,GetID(),GetState(), m_dwWarRunStep);
433 	// 同步回本区更新状态备本区玩家知晓跨服帮会BOSS战场状态 跨服帮会BOSS战场执行状态子类型变化
434 	SendDataToBridgeZone(0,Match_WarMsg_ClanBossWarStepChanged,GetRoomID(),GetState(),m_dwWarRunStep);
436 	return true;
548 bool CClanBossWar::InitializeRun(void)
549 {
550 	// 跨服帮会BOSS战场状态标识 EMClanBossWarRunStep
551 	m_dwWarRunStep = ClanBossWarRunStep_Init;
553 	return true;
576 	int nCurTime = (int)time(NULL);
577 	char szMsgBuf[512] = {0};
579 	// 跨服帮会BOSS战场战场子状态标识
580 	// 2011-11-1 修改：先进入杀人就有积分处理
581 	//if (m_dwWarRunStep!=ClanBossWarRunStep_Start && m_dwWarRunStep!=ClanBossWarRunStep_Running)
810 }
813 ////IBossWar//////////////////////////////////////////////////////////////////////
815 /** 跨服BOSS战接收外部数据结构信息
816 @return  SWorldBossWarInfo *
817 */
955 	// 资源初始化值		
956 	SetNumProp(BossWarNum_Boss, 100);			// BOSS血量百分比
958 	// 发送跨服帮会BOSS战场战场创建信息到参战游戏区的所有场景服
959 	SendWarCreateEventToZone();
960 }
1115 		}
1116 	}
1118 	// 发送跨服帮会BOSS战场战场结束信息到参战游戏区的所有场景服
1119 	SendWarEndEventToZone();
1120 }
1141 	}
1143 	DWORD dwDiffTime = m_dwCloseTime - dwNowTime;		// 时间差
1145 	// 发送跨服帮会BOSS战场信息
1146 	for (DWORD i=0; i<4; i++)
1147 	{
1235 		}
1236 	}
1238 	SWorldClanBossWarResultInfo warResultInfo;						// 发送到客户端的跨服帮会BOSS战日志信息
1239 	warResultInfo.dwPlayTime = (DWORD)time(NULL) - m_dwStartTime;	// 战斗持续时间
1241 	// 排序序号处理
1295 	// 玩家奖励处理
1296 	char szBuf[512]		= {0};
1297 	int nMaxMoney		= g_pMatchServer->GetWarConfigNumber(WarCfgNum_ClanBoss_MaxMoney);				// 跨服帮会BOSS-获得最高绑金
1298 	int nOtherMoney		= g_pMatchServer->GetWarConfigNumber(WarCfgNum_ClanBoss_OtherMoney);			// 跨服帮会BOSS-完成任务后可获赠送绑金
1299 	DWORD dwAdjLevel	= (DWORD)g_pMatchServer->GetWarConfigNumber(WarCfgNum_ClanBoss_AdjLevel);		// 跨服帮会BOSS-经验调节等级
1300 	DWORD dwConst1		= (DWORD)g_pMatchServer->GetWarConfigNumber(WarCfgNum_ClanBoss_Const1);			// 跨服帮会BOSS-经验调节常量1
1301 	DWORD dwConst2		= (DWORD)g_pMatchServer->GetWarConfigNumber(WarCfgNum_ClanBoss_Const2);			// 跨服帮会BOSS-经验调节常量2
1302 	DWORD dwConst3		= (DWORD)g_pMatchServer->GetWarConfigNumber(WarCfgNum_ClanBoss_Const3);			// 跨服帮会BOSS-经验调节常量3
1304 	// 每个参战帮会成员获取奖励
1305 	for (DWORD i=0; i<m_WarCamp.size(); i++)
1505 void CClanBossWar::CollectGameResource(void)
1506 {
1507 	// 发送跨服帮会BOSS战场战场关闭信息到参战游戏区的所有场景服
1508 	SendWarCloseEventToZone();
1509 }
1620 	// 发送玩家获取积分事件
1621 	SEventMatchCountryWarGetScore_S eventData;
1622 	eventData.dwPVPClassType	= GetPVPClass()->GetClass();					// 跨服PVP类型 EMPVPClassType
1623 	eventData.dwWarID			= GetID();										// 相关战场ID
1624 	eventData.uidPlayer			= playerNode.uidPlayer;							// 玩家UID
1638 	//{
1639 	//	CLuaParam param[5];
1640 	//	param[0] = eventData.dwPVPClassType;						//	跨服PVP类型 EMPVPClassType
1641 	//	param[1] = eventData.dwWarID;								//	相关战场ID
1642 	//	param[2] = ANALYZEUID_SERIALNO(eventData.uidPlayer);		//	玩家序列号
1759 			// 调用LUA，处理玩家杀人
1760 			CLuaParam param[6];
1761 			param[0] = GetPVPClass()->GetClass();					// 跨服PVP类型 EMPVPClassType
1762 			param[1] = GetID();										// 相关战场ID
1763 			param[2] = ANALYZEUID_SERIALNO(uidPlayer);				// 凶手
1774 		// 调用LUA，处理玩家杀人
1775 		CLuaParam param[6];
1776 		param[0] = GetPVPClass()->GetClass();					// 跨服PVP类型 EMPVPClassType
1777 		param[1] = GetID();										// 相关战场ID
1778 		param[2] = ANALYZEUID_SERIALNO(killerNode.uidPlayer);	// 凶手
1798 		return false;
1799 	}
1801 	// 跨服帮会BOSS-基础积分杀人数
1802 	DWORD dwTaskKillCount	= (DWORD)g_pMatchServer->GetWarConfigNumber(WarCfgNum_ClanBoss_TaskKillCount);
1804 	// 完成任务的标准积分
1919 	}
1920 }
1922 // 发送跨服帮会BOSS战场战场创建信息到参战游戏区的所有场景服
1923 bool CClanBossWar::SendWarCreateEventToZone(void)
1924 {
1964 	return SendDataToBridgeZone(0,Match_WarMsg_ClanBossWarCreate, GetRoomID(),0,0,obufData.data(), obufData.size());
1965 }
1967 // 发送跨服帮会BOSS战场结束信息到参战游戏区的所有场景服
1968 bool CClanBossWar::SendWarEndEventToZone(void)
1969 {
1972 	return SendDataToBridgeZone(0,Match_WarMsg_ClanBossWarEnd, GetRoomID(),dwServerID,0);
1973 }
1975 // 发送跨服帮会BOSS战场关闭信息到参战游戏区的所有场景服
1976 bool CClanBossWar::SendWarCloseEventToZone(void)
1977 {
1976 bool CClanBossWar::SendWarCloseEventToZone(void)
1977 {
1978 	// 更新场景服删除跨服帮会BOSS战场场景信息
1979 	SMsgWarRemoveWar_SS sendData;
1980 	sendData.dwServerID			= gZoneServiceProvider->GetCenterServerConnector()->GetLocalServerCSID();		// 场景服ID
2070 				// 游戏结束后回收资源
2071 				CollectGameResource();
2072 				// 设置结束跨服帮会BOSS战场状态
2073 				SetState(WarState_Close);
2074 				break;
2074 				break;
2075 			}
2077 			// 准备跨服帮会BOSS战场
2078 			OnReadyWar();
2080 			// 能否开战
2177 			// 设置状态
2178 			SetRunStep(ClanBossWarRunStep_None);
2180 			// 设置结束跨服帮会BOSS战场状态
2181 			SetState(WarState_Close);
2182 		}

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcClient\Client\MatchClient\ClanBossWar.cpp 13 KB CPP 文件 2014/2/25 13:44:48 2018/10/23 19:34:25 2018/10/23 19:34:25 23
5 ** 日  期:	2011-7-26
6 ** 版  本:	1.0
7 ** 描  述:	跨服帮会BOSS战场系统
8 ** 应  用:  	
9 	
24 CClanBossWar::CClanBossWar(void)
25 {
26 	// 跨服帮会BOSS战玩法状态 EMClanBossWarRunStep
27 	m_dwState = ClanBossWarRunStep_None;
27 	m_dwState = ClanBossWarRunStep_None;
28 	// 跨服帮会BOSS战玩法状态状态变化时间
29 	m_dwStateTime = 0;
30 	// 呆在复活点的时长
32 	// 本帮帮会积分
33 	m_dwClanScore = 0;
34 	// 跨服BOSS战基本信息扩展数据结构
35 	memset(&m_WarBaseInfo, 0, sizeof(SWorldClanBossWarBaseInfo));
36 	// 结果数据
157 bool CClanBossWar::Reset(void)
158 {
159 	// 跨服帮会BOSS战玩法状态 EMClanBossWarRunStep
160 	m_dwState = ClanBossWarRunStep_None;
160 	m_dwState = ClanBossWarRunStep_None;
161 	// 跨服帮会BOSS战玩法状态状态变化时间
162 	m_dwStateTime = 0;
163 	// 呆在复活点的时长
165 	// 本帮帮会积分
166 	m_dwClanScore = 0;
167 	// 跨服BOSS战基本信息扩展数据结构
168 	memset(&m_WarBaseInfo, 0, sizeof(SWorldClanBossWarBaseInfo));
169 	// 结果数据
207 }
209 //////////////////////////////////////////////////////////////////////////
212 /** 取得跨服帮会BOSS战扩展数据
213 @return
214 */
217 	return &m_WarBaseInfo;
218 }
220 /** 取得跨服帮会BOSS战本帮帮会详细数据,dwCampID为0则找自己帮会信息
221 @return
222 */
241 	return &(m_WarBaseInfo.clans[dwCamp]);
242 }
244 /** 取得跨服帮会BOSS战帮会详细数据
245 @param DWORD dwClanID : 帮会ID
246 @return
265 	return NULL;
266 }
269 /** 取得跨服帮会BOSS战结果日志信息
270 @return  跨服帮会BOSS战结果日志信息
271 */
272 SWorldClanBossWarResultInfo* CClanBossWar::GetWorldWarResultInfo(void)
274 	return &m_WarResultInfo;
275 }
277 /** 取得跨服帮会BOSS战日志信息的排名节点信息
278 @param  DWORD dwIndex	: 序号
279 @param  BYTE dwType		: 对象类型	1表示玩家，2表示帮会
278 @param  DWORD dwIndex	: 序号
279 @param  BYTE dwType		: 对象类型	1表示玩家，2表示帮会
280 @return  查询到的跨服帮会BOSS战日志信息排名节点信息
281 */
282 const SWorldClanBossWarOrderNodeInfo*  CClanBossWar::GetWorldWarLogOrderNodeInfo(DWORD dwIndex,BYTE dwType)
306 }
308 /** 获取本帮帮会积分数据
309 @param DWORD dwScoreID : 跨服帮会BOSS战积分类型ID EMWarScoreFlag  
310 @return
311 */
427 	switch(dwMsgCode)
428 	{
429 	case Match_WarMsg_ClanBossStateChanged:	// 更新跨服帮会BOSS战状态变化
430 		{
431 			bHasDone = true;
433 			if (nNewlen>0)
434 			{
435 				ErrorLn("收到跨服帮会BOSS战状态变化信息数据大小不符，nLen = "<<nNewlen);
436 				break;
437 			}
479 		}
480 		break;
481 	case Match_WarMsg_ClanBossWarResultInfo:		// 更新跨服帮会BOSS战场信息结果日志信息到客户端
482 		{
483 			bHasDone = true;
485 			if (nNewlen!=sizeof(SWorldClanBossWarResultInfo))
486 			{
487 				ErrorLn("更新跨服战场信息结果日志信息到客户端数据大小不符，nLen = "<<nNewlen);
488 				break;
489 			}
492 			DWORD dwPlayerID	= dwUserData2;		// 玩家角色ID
493 			DWORD dwCamp		= dwUserData3;		// 玩家阵营序号
495 			// 跨服帮会BOSS战场信息结果日志信息
496 			m_WarResultInfo		= (*((SWorldClanBossWarResultInfo *)pMsgData));
499 			// 返回请求结果给Lua
512 		}
513 		break;
514 	case Match_WarMsg_ClanBossWarAutoJoin:	// 客户端显示并可直接加入跨服帮会BOSS战
515 		{
516 			bHasDone = true;
518 			if (nNewlen!=0)
519 			{
520 				ErrorLn("收到客户端显示并可直接加入跨服帮会BOSS战信息到客户端数据大小不符，nLen ="<<nNewlen);
521 				break;
522 			}
536 		{
537 			bHasDone = true;
539 			ErrorLn("跨服帮会BOSS战场客户端系统有一个服务器战场信息子消息未处理，dwMsgCode = "<< dwMsgCode);
540 		}
541 		break;

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\ChatService\ChatService.cpp 91 KB CPP 文件 2014/2/25 0:20:56 2018/10/23 20:08:50 2018/10/23 20:08:50 4
282 #endif
283 }
286 ////// 跨服发聊天消息接口 接口和原来一样，只多了一个游戏世界ID参数 ////////////////////////////////////////////////////////////////////
288 void ChatService::worldBroadcastSystemTips(DWORD dwWorldID,TipsType type ,dbid sender, ChatChannelType channel, InfoPos pos, const char* text)
289 {	
307 				header.wKeyModule  = MSG_MODULEID_CHAT;
308 				header.wKeyAction  = ChatMsg_BroadcastSystemTips;				// 系统向指定的用户列表广播系统提示信息
310 				// 跨服发聊天消息
311 				obuf1024 ob;
312 				ob<<header<<type<<sender<<channel<<pos<<text;
337 				header.wKeyModule  = MSG_MODULEID_CHAT;
338 				header.wKeyAction  = ChatMsg_BroadcastSystemTipsByID;				// 系统向指定的用户列表广播系统提示信息
340 				// 跨服发聊天消息
341 				obuf1024 ob;
342 				ob<<header<<type<<id<<channel<<pos<<text;
368 				header.wKeyModule  = MSG_MODULEID_CHAT;
369 				header.wKeyAction  = ChatMsg_SystemTips;				// 系统提示信息到达
371 				// 跨服发聊天消息
372 				obuf1024 ob;
373 				ob<<header<<type<<target<<pos<<text;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\ChatService\ChatService.cpp 91 KB CPP 文件 2014/2/25 14:30:35 2018/10/23 19:46:31 2018/10/23 19:46:31 4
282 #endif
283 }
286 ////// 跨服发聊天消息接口 接口和原来一样，只多了一个游戏世界ID参数 ////////////////////////////////////////////////////////////////////
288 void ChatService::worldBroadcastSystemTips(DWORD dwWorldID,TipsType type ,dbid sender, ChatChannelType channel, InfoPos pos, const char* text)
289 {	
307 				header.wKeyModule  = MSG_MODULEID_CHAT;
308 				header.wKeyAction  = ChatMsg_BroadcastSystemTips;				// 系统向指定的用户列表广播系统提示信息
310 				// 跨服发聊天消息
311 				obuf1024 ob;
312 				ob<<header<<type<<sender<<channel<<pos<<text;
337 				header.wKeyModule  = MSG_MODULEID_CHAT;
338 				header.wKeyAction  = ChatMsg_BroadcastSystemTipsByID;				// 系统向指定的用户列表广播系统提示信息
340 				// 跨服发聊天消息
341 				obuf1024 ob;
342 				ob<<header<<type<<id<<channel<<pos<<text;
368 				header.wKeyModule  = MSG_MODULEID_CHAT;
369 				header.wKeyAction  = ChatMsg_SystemTips;				// 系统提示信息到达
371 				// 跨服发聊天消息
372 				obuf1024 ob;
373 				ob<<header<<type<<target<<pos<<text;

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\ChatServer\ChatServer.cpp 40 KB CPP 文件 2014/2/25 0:05:21 2018/10/23 20:04:00 2018/10/23 20:04:00 4
514 	mgr->Broadcast((ClientID*)client_array, (WORD)client_num, ob.data(), (WORD)ob.size());
515 }
517 ////// 跨服发聊天消息接口 接口和原来一样，只多了一个游戏世界ID参数 ////////////////////////////////////////////////////////////////////
518 void ChatServer::worldBroadcastSystemTips(DWORD dwWorldID,TipsType type, dbid sender, ChatChannelType channel, InfoPos pos, const char* text)
519 {
537 				header.wKeyModule  = MSG_MODULEID_CHAT;
538 				header.wKeyAction  = ChatMsg_BroadcastSystemTips;				// 系统向指定的用户列表广播系统提示信息
540 				// 跨服发聊天消息
541 				obuf1024 ob;
542 				ob<<header<<type<<sender<<channel<<pos<<text;
567 				header.wKeyModule  = MSG_MODULEID_CHAT;
568 				header.wKeyAction  = ChatMsg_BroadcastSystemTipsByID;				// 系统向指定的用户列表广播系统提示信息
570 				// 跨服发聊天消息
571 				obuf1024 ob;
572 				ob<<header<<type<<id<<channel<<pos<<text;
597 				header.wKeyModule  = MSG_MODULEID_CHAT;
598 				header.wKeyAction  = ChatMsg_SystemTips;				// 系统提示信息到达
600 				// 跨服发聊天消息
601 				obuf1024 ob;
602 				ob<<header<<type<<target<<pos<<text;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\ChatServer\ChatServer.cpp 40 KB CPP 文件 2014/2/25 14:23:34 2018/10/23 19:43:11 2018/10/23 19:43:11 4
514 	mgr->Broadcast((ClientID*)client_array, (WORD)client_num, ob.data(), (WORD)ob.size());
515 }
517 ////// 跨服发聊天消息接口 接口和原来一样，只多了一个游戏世界ID参数 ////////////////////////////////////////////////////////////////////
518 void ChatServer::worldBroadcastSystemTips(DWORD dwWorldID,TipsType type, dbid sender, ChatChannelType channel, InfoPos pos, const char* text)
519 {
537 				header.wKeyModule  = MSG_MODULEID_CHAT;
538 				header.wKeyAction  = ChatMsg_BroadcastSystemTips;				// 系统向指定的用户列表广播系统提示信息
540 				// 跨服发聊天消息
541 				obuf1024 ob;
542 				ob<<header<<type<<sender<<channel<<pos<<text;
567 				header.wKeyModule  = MSG_MODULEID_CHAT;
568 				header.wKeyAction  = ChatMsg_BroadcastSystemTipsByID;				// 系统向指定的用户列表广播系统提示信息
570 				// 跨服发聊天消息
571 				obuf1024 ob;
572 				ob<<header<<type<<id<<channel<<pos<<text;
597 				header.wKeyModule  = MSG_MODULEID_CHAT;
598 				header.wKeyAction  = ChatMsg_SystemTips;				// 系统提示信息到达
600 				// 跨服发聊天消息
601 				obuf1024 ob;
602 				ob<<header<<type<<target<<pos<<text;

I:\work\source\蜀山神话\[src.cool]蜀山神话\src\common\protocol\CharDetailMessage.cpp 35 KB CPP 文件 2012/4/21 1:05:22 2018/10/23 13:25:07 2018/10/23 13:25:07 1
692 	m_strCharName = m_pMsg->ReadS();
693 }
695 //请求跨服观察
696 ObserverOtherGameRequestMessage::ObserverOtherGameRequestMessage(UINT32 clientNum, UINT32 nCharOid, const std::string& strName)
697 : PacketBase(MSG_OBSERVER_OTHER_GAME_REQUEST, clientNum, sizeof(UINT32) + strName.length() + 1)

I:\work\source\仙剑神曲\[src.cool]仙剑神曲\src\server\gamesvr\CharacterManager.cpp 64 KB CPP 文件 2012/4/22 2:05:34 2018/10/23 16:10:54 2018/10/23 16:10:54 1
945 {
946     CHECK_NULL(pPlayer);
948     // 构造技能战斗跨服同步信息
949     COMBAT_SVR_SYNC_DATA combatSyncData = COMBAT_SVR_SYNC_DATA_Build(
950         pPlayer->GetCombatData()->GetCurHp(), 

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MatchServer\CGameMatchAPI.cpp 148 KB CPP 文件 2014/2/25 0:08:39 2018/10/23 20:06:21 2018/10/23 20:06:21 71
5 ** 日  期:	2010-7-13
6 ** 版  本:	1.0
7 ** 描  述:	跨服组队撮合系统API接口
8 ** 应  用:  	
10 **************************** 修改记录 ******************************
1610 }
1612 ///////////// 跨区战场API /////////////////////////////////////////////////////////////
1614 /** 用现场创建跨服国战
1615 @param  DWORD dwWarTypeID		: 战场场类型 EMWarItemType
1616 @param  const char * szCampNames: 阵营名称列表，分号分割阵营名
1661 	if (pSchemeInfo==NULL)
1662 	{
1663 		ErrorLn("创建跨服国战失败，pSchemeInfo==NULL");
1664 		return 0;
1665 	}
2427 	return NULL;
2428 }
2431 /** 跨服领地BOSS战接收外部数据结构信息
2432 @param	 DWORD dwActorID	:玩家序列号
2433 @param	 DWORD dwWarID		:战场ID
2456 	return pBossWar->GetInfo();
2457 }
2459 /** 跨服领地BOSS战接收外部数据结构信息
2460 @param	 DWORD dwActorID	:玩家序列号
2461 @param	 DWORD dwWarID		:战场ID
2535 	return true;
2536 }
2538 /** 跨服领地BOSS战接收外部数据结构中指定帮会信息
2539 @param	 DWORD dwActorID	:玩家序列号
2540 @param	 DWORD dwWarID		:战场ID
2609 	return (DWORD)(pResAdjustServer->GetGameUpLevelLimit(dwCivilGrade));
2610 }
2612 /** 取得跨服边境战场对象
2613 @param	 DWORD dwZoneID		:场景ID
2614 @return  SCountryWarInfo *
2635 	return pBorderWar;
2636 }
2638 /** 跨服边境战场内传送玩家
2639 @param	 DWORD dwActorID	:玩家序列号
2640 @param	 DWORD dwTransFlag	:传送标识 EMCountryBorderWarTransFlag
2669 	}
2670 }
2672 /** 跨服边境战场内传送玩家是否能传送到天上战场
2673 @param	 DWORD dwActorID	:玩家序列号
2674 @param	 DWORD dwZoneID		:场景ID
2690 	return pBorderWar->CanMovetoSkyZone(pPerson);
2691 }
2693 /** 跨服边境战场击杀BOSS时AI触发事件后处理
2694 @param	DWORD dwActorID		: 玩家序列号
2695 @param	bool bSendResult	: 是否要发送结果信息到社会服,false=不发送
2735 	return pBorderWar->SetCampWinResult( pPlayerNode->dwCamp+1, bSendResult);
2736 }
2739 /** 检测跨服边境战场是否开启任务
2740 @param	DWORD dwActorID		: 玩家序列号
2741 @return  bool
2793 	return (pWar->GetNumProp(dwPaleResIndex)==0);
2794 }
2796 /** 检测跨服边境战场阵营数量
2797 @param	DWORD dwActorID		: 玩家序列号
2798 @return  DWORD
2825 		return 0;
2826 	}
2827 	// 跨服边境接收外部数据结构信息
2828 	SCountryBorderWarInfo * pWarInfo = pBorderWar->GetInfo();
2829 	if (NULL == pWarInfo)
3665 	// 战争资源生成
3666 	SEventMatchWarResStone_Gather_S eventData;
3667 	eventData.dwPVPClassType	= dwPVPType;		// 跨服PVP类型 EMPVPClassType
3668 	eventData.dwWarID			= dwWarID;			// 相关战场ID
3669 	eventData.uidMaster			= uidMaster;		// 采集人
3721 	// 战争资源生成
3722 	SEventMatchWarResBrushTank_Kill_S eventData;
3723 	eventData.dwPVPClassType	= dwPVPType;		// 跨服PVP类型 EMPVPClassType
3724 	eventData.dwWarID			= dwWarID;			// 相关战场ID
3725 	eventData.uidMaster			= uidMaster;		// 采集人
4752 bool CGameMatchAPI::GetMatrixOpen(void)
4753 {
4754 	// 取得跨服组队撮合服务器
4755 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
4756 	if (pMatchServer == NULL)
4774 bool CGameMatchAPI::CheckClanCreateMatrix(DWORD dwClanID)
4775 {
4776 	// 取得跨服组队撮合服务器
4777 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
4778 	if (pMatchServer == NULL)
4796 bool CGameMatchAPI::CheckUserCreateMatrix(DWORD dwPDBID)
4797 {
4798 	// 取得跨服组队撮合服务器
4799 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
4800 	if (pMatchServer == NULL)
4818 bool CGameMatchAPI::CreateSerialMatrix(DWORD dwPDBID, DWORD dwClanID, DWORD dwSerialID)
4819 {
4820 	// 取得跨服组队撮合服务器
4821 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
4822 	if (pMatchServer == NULL)
4839 void CGameMatchAPI::DeleteSerialMatrix(DWORD dwSerialID)
4840 {
4841 	// 取得跨服组队撮合服务器
4842 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
4843 	if (pMatchServer == NULL)
4861 void CGameMatchAPI::SetUserSerialMatrix(DWORD dwPDBID, DWORD dwSerialID)
4862 {
4863 	// 取得跨服组队撮合服务器
4864 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
4865 	if (pMatchServer == NULL)
4883 DWORD CGameMatchAPI::GetUserSerialMatrix(DWORD dwPDBID)
4884 {
4885 	// 取得跨服组队撮合服务器
4886 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
4887 	if (pMatchServer == NULL)
4905 void CGameMatchAPI::ClearUserSerialMatrix(DWORD dwPDBID, DWORD dwSerialID)
4906 {
4907 	// 取得跨服组队撮合服务器
4908 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
4909 	if (pMatchServer == NULL)
4927 void CGameMatchAPI::StartMatrixChallenge(DWORD dwSerialID, int nZoneID, int nLevel, BYTE nDifficulty)
4928 {
4929 	// 取得跨服组队撮合服务器
4930 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
4931 	if (pMatchServer == NULL)
4949 void CGameMatchAPI::SetNpcBingEctypeSerialEvent(int nNpcSID, DWORD dwPDBID)
4950 {
4951 	// 取得跨服组队撮合服务器
4952 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
4953 	if (pMatchServer == NULL)
4970 void CGameMatchAPI::ClearZoneIDMatrixInfo(int nZoneID)
4971 {
4972 	// 取得跨服组队撮合服务器
4973 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
4974 	if (pMatchServer == NULL)
4992 DWORD CGameMatchAPI::GetMatrixSerialByZoneID(int nZoneID)
4993 {
4994 	// 取得跨服组队撮合服务器
4995 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
4996 	if (pMatchServer == NULL)
5014 bool CGameMatchAPI::GetMatrixDataFinish(void)
5015 {
5016 	// 取得跨服组队撮合服务器
5017 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5018 	if (pMatchServer == NULL)
5036 const SMATRIX_NPC_INFO_SCHEMEINFO *CGameMatchAPI::GetMatrixNpcInfo(BYTE nID)
5037 {
5038 	// 取得跨服组队撮合服务器
5039 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5040 	if (pMatchServer == NULL)
5058 const SMATRIX_MONSTER_INFO_SCHEMEINFO *CGameMatchAPI::GetMatrixMonsterInfo(BYTE nID, BYTE nMinorID)
5059 {
5060 	// 取得跨服组队撮合服务器
5061 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5062 	if (pMatchServer == NULL)
5084 void CGameMatchAPI::CreateMinorIndexDummyMonster(DWORD dwSerialID, BYTE nMinorIndex, BYTE nPosIndex, int nPosX, int nPosY)
5085 {
5086 	// 取得跨服组队撮合服务器
5087 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5088 	if (pMatchServer == NULL)
5105 void CGameMatchAPI::PassMinorMatrix(DWORD dwSerialID, BYTE nMinorIndex)
5106 {
5107 	// 取得跨服组队撮合服务器
5108 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5109 	if (pMatchServer == NULL)
5126 UID CGameMatchAPI::CreateMinorIndexMonsterInDummyData(DWORD dwSerialID, BYTE nMinorIndex, int nMonsterID, int nPosX, int nPosY, DWORD dwPDBID, UID BeUid)
5127 {
5128 	// 取得跨服组队撮合服务器
5129 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5130 	if (pMatchServer == NULL)
5147 int CGameMatchAPI::DeleteMinorIndexMonsterInDummyData(DWORD dwSerialID, UID BeUid)
5148 {
5149 	// 取得跨服组队撮合服务器
5150 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5151 	if (pMatchServer == NULL)
5171 const SMATRIX_CREATE_MONSTER *CGameMatchAPI::GetLastDieMonsterInfo(DWORD dwSerialID)
5172 {
5173 	// 取得跨服组队撮合服务器
5174 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5175 	if (pMatchServer == NULL)
5194 void CGameMatchAPI::ClearCurrentMinorInfo(DWORD dwSerialID)
5195 {
5196 	// 取得跨服组队撮合服务器
5197 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5198 	if (pMatchServer == NULL)
5216 BYTE CGameMatchAPI::GetMinorIndexState(DWORD dwSerialID, BYTE nMinorIndex)
5217 {
5218 	// 取得跨服组队撮合服务器
5219 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5220 	if (pMatchServer == NULL)
5238 BYTE CGameMatchAPI::GetCurrentMinorIndex(DWORD dwSerialID)
5239 {
5240 	// 取得跨服组队撮合服务器
5241 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5242 	if (pMatchServer == NULL)
5260 void CGameMatchAPI::SendMatrixInfo(DWORD dwPDBID)
5261 {
5262 	// 取得跨服组队撮合服务器
5263 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5264 	if (pMatchServer == NULL)
5282 void CGameMatchAPI::SendMinorMatrixInfo(DWORD dwPDBID, DWORD dwClanID, BYTE nMinorIndex)
5283 {
5284 	// 取得跨服组队撮合服务器
5285 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5286 	if (pMatchServer == NULL)
5304 void CGameMatchAPI::SendClanAllMemberInfo(DWORD dwPDBID, DWORD dwClanID)
5305 {
5306 	// 取得跨服组队撮合服务器
5307 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5308 	if (pMatchServer == NULL)
5326 const SMATRIX_MINOR_INFO *CGameMatchAPI::GetMatrixMinorInfo(DWORD dwSerialID, BYTE nMinorIndex)
5327 {
5328 	// 取得跨服组队撮合服务器
5329 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5330 	if (pMatchServer == NULL)
5348 void CGameMatchAPI::CreateMatrixMonster(DWORD dwSerialID, BYTE nID, BYTE nMinorID, BYTE nMinorIndex, bool bCheckBrush)
5349 {
5350 	// 取得跨服组队撮合服务器
5351 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5352 	if (pMatchServer == NULL)
5370 void CGameMatchAPI::DeleteMatrixNpc(DWORD dwSerialID, BYTE nMinorIndex)
5371 {
5372 	// 取得跨服组队撮合服务器
5373 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5374 	if (pMatchServer == NULL)
5395 int CGameMatchAPI::GetMatrixNpc(DWORD dwSerialID, BYTE nMinorIndex)
5396 {
5397 	// 取得跨服组队撮合服务器
5398 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5399 	if (pMatchServer == NULL)
5417 void CGameMatchAPI::DeleteMatrixUser(DWORD dwSerialID, DWORD dwPDBID)
5418 {
5419 	// 取得跨服组队撮合服务器
5420 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5421 	if (pMatchServer == NULL)
5439 const SMATRIX_LAYER_INFO_SCHEMEINFO *CGameMatchAPI::GetMatrixLayerInfo(BYTE nID, BYTE nMinorIndex)
5440 {
5441 	// 取得跨服组队撮合服务器
5442 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5443 	if (pMatchServer == NULL)
5466 const SMATRIX_LAYER_FACTOR_SCHEMEINFO *CGameMatchAPI::GetMatrixLayerFactor(BYTE nID, BYTE nLayer)
5467 {
5468 	// 取得跨服组队撮合服务器
5469 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5470 	if (pMatchServer == NULL)
5493 const SMINOR_POINT_INFO_SCHEMEINFO *CGameMatchAPI::GetMinorPointInfo(BYTE nID, BYTE nMinorID)
5494 {
5495 	// 取得跨服组队撮合服务器
5496 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5497 	if (pMatchServer == NULL)
5523 const SMATRIX_RANDOM_POINT_INFO_SCHEMEINFO *CGameMatchAPI::GetMatrixRandomPointInfo(BYTE nID, BYTE nRandomID)
5524 {
5525 	// 取得跨服组队撮合服务器
5526 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5527 	if (pMatchServer == NULL)
5550 const SMINOR_PRIZE_GOODS_SCHEMEINFO *CGameMatchAPI::GetMinorPrizeGoods(BYTE nID, BYTE nMinorID, BYTE nDifficulty)
5551 {
5552 	// 取得跨服组队撮合服务器
5553 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5554 	if (pMatchServer == NULL)
5578 const SMATRIX_RANDOM_PRIZE_GOODS_SCHEMEINFO *CGameMatchAPI::GetMatrixRandomPrizeGoods(BYTE nID, BYTE nRandomID, BYTE nDifficulty)
5579 {
5580 	// 取得跨服组队撮合服务器
5581 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5582 	if (pMatchServer == NULL)
5606 const SMATRIX_CLAN_PLACE *CGameMatchAPI::GetMatrixEctypeClanPlace(DWORD dwSerialID)
5607 {
5608 	// 取得跨服组队撮合服务器
5609 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5610 	if (pMatchServer == NULL)
5628 BYTE CGameMatchAPI::GetMatrixPointLayerCount(DWORD dwSerialID, BYTE nLayer)
5629 {
5630 	// 取得跨服组队撮合服务器
5631 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5632 	if (pMatchServer == NULL)
5650 void CGameMatchAPI::SetMatrixPointLayerCount(DWORD dwSerialID, BYTE nLayer)
5651 {
5652 	// 取得跨服组队撮合服务器
5653 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5654 	if (pMatchServer == NULL)
5672 const SMATRIX_CLAN_FACTOR_SCHEMEINFO *CGameMatchAPI::GetMatrixClanFactor(BYTE nID, BYTE nPlace)
5673 {
5674 	// 取得跨服组队撮合服务器
5675 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5676 	if (pMatchServer == NULL)
5699 const SMATRIX_CLAN_PLACE *CGameMatchAPI::GetMatrixClanPlace(DWORD dwClanID)
5700 {
5701 	// 取得跨服组队撮合服务器
5702 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5703 	if (pMatchServer == NULL)
5723 void CGameMatchAPI::SetOpenMatrixKeyNum(DWORD dwSerialID, int nOpenMatrixKeyNum)
5724 {
5725 	// 取得跨服组队撮合服务器
5726 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5727 	if (pMatchServer == NULL)
5745 int CGameMatchAPI::GetOpenMatrixKeyNum(DWORD dwSerialID)
5746 {
5747 	// 取得跨服组队撮合服务器
5748 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5749 	if (pMatchServer == NULL)
5767 void CGameMatchAPI::SetMatrixRandomID(DWORD dwSerialID, BYTE nMinorIndex, BYTE nChooseRandomID)
5768 {
5769 	// 取得跨服组队撮合服务器
5770 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5771 	if (pMatchServer == NULL)
5789 BYTE CGameMatchAPI::GetMatrixRandomID(DWORD dwSerialID, BYTE nMinorIndex)
5790 {
5791 	// 取得跨服组队撮合服务器
5792 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5793 	if (pMatchServer == NULL)
5811 void CGameMatchAPI::SendPassMatrix(DWORD dwSerialID, DWORD dwCaptainPDBID)
5812 {
5813 	// 取得跨服组队撮合服务器
5814 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5815 	if (pMatchServer == NULL)
5833 bool CGameMatchAPI::GetPassBoss(DWORD dwSerialID)
5834 {
5835 	// 取得跨服组队撮合服务器
5836 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5837 	if (pMatchServer == NULL)
5855 const SMATRIX_RANKLIST *CGameMatchAPI::GetMatrixRankList(BYTE nCountryID)
5856 {
5857 	// 取得跨服组队撮合服务器
5858 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5859 	if (pMatchServer == NULL)
5877 void CGameMatchAPI::SendMatrixRankList(DWORD dwPDBID)
5878 {
5879 	// 取得跨服组队撮合服务器
5880 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5881 	if (pMatchServer == NULL)
5899 BYTE CGameMatchAPI::SetMatrixFailCloseDoor(DWORD dwSerialID, BYTE nMinorIndex)
5900 {
5901 	// 取得跨服组队撮合服务器
5902 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5903 	if (pMatchServer == NULL)
5921 bool CGameMatchAPI::GetPassMinorMatrix(DWORD dwSerialID, BYTE nMinorIndex)
5922 {
5923 	// 取得跨服组队撮合服务器
5924 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5925 	if (pMatchServer == NULL)
5943 int CGameMatchAPI::GetMatrixPassInfoCount(void)
5944 {
5945 	// 取得跨服组队撮合服务器
5946 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5947 	if (pMatchServer == NULL)
5965 const SMATRIX_PASS_INFO *CGameMatchAPI::GetMatrixPassInfo(int nIndex)
5966 {
5967 	// 取得跨服组队撮合服务器
5968 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5969 	if (pMatchServer == NULL)
5987 BYTE CGameMatchAPI::GetMatrixBoxIndex(DWORD dwSerialID)
5988 {
5989 	// 取得跨服组队撮合服务器
5990 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5991 	if (pMatchServer == NULL)
6009 BYTE CGameMatchAPI::GetMatrixID(DWORD dwSerialID)
6010 {
6011 	// 取得跨服组队撮合服务器
6012 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
6013 	if (pMatchServer == NULL)

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MatchServer\CGameMatchAPI.cpp 148 KB CPP 文件 2014/2/25 14:26:57 2018/10/23 19:45:08 2018/10/23 19:45:08 71
5 ** 日  期:	2010-7-13
6 ** 版  本:	1.0
7 ** 描  述:	跨服组队撮合系统API接口
8 ** 应  用:  	
10 **************************** 修改记录 ******************************
1610 }
1612 ///////////// 跨区战场API /////////////////////////////////////////////////////////////
1614 /** 用现场创建跨服国战
1615 @param  DWORD dwWarTypeID		: 战场场类型 EMWarItemType
1616 @param  const char * szCampNames: 阵营名称列表，分号分割阵营名
1661 	if (pSchemeInfo==NULL)
1662 	{
1663 		ErrorLn("创建跨服国战失败，pSchemeInfo==NULL");
1664 		return 0;
1665 	}
2427 	return NULL;
2428 }
2431 /** 跨服领地BOSS战接收外部数据结构信息
2432 @param	 DWORD dwActorID	:玩家序列号
2433 @param	 DWORD dwWarID		:战场ID
2456 	return pBossWar->GetInfo();
2457 }
2459 /** 跨服领地BOSS战接收外部数据结构信息
2460 @param	 DWORD dwActorID	:玩家序列号
2461 @param	 DWORD dwWarID		:战场ID
2535 	return true;
2536 }
2538 /** 跨服领地BOSS战接收外部数据结构中指定帮会信息
2539 @param	 DWORD dwActorID	:玩家序列号
2540 @param	 DWORD dwWarID		:战场ID
2609 	return (DWORD)(pResAdjustServer->GetGameUpLevelLimit(dwCivilGrade));
2610 }
2612 /** 取得跨服边境战场对象
2613 @param	 DWORD dwZoneID		:场景ID
2614 @return  SCountryWarInfo *
2635 	return pBorderWar;
2636 }
2638 /** 跨服边境战场内传送玩家
2639 @param	 DWORD dwActorID	:玩家序列号
2640 @param	 DWORD dwTransFlag	:传送标识 EMCountryBorderWarTransFlag
2669 	}
2670 }
2672 /** 跨服边境战场内传送玩家是否能传送到天上战场
2673 @param	 DWORD dwActorID	:玩家序列号
2674 @param	 DWORD dwZoneID		:场景ID
2690 	return pBorderWar->CanMovetoSkyZone(pPerson);
2691 }
2693 /** 跨服边境战场击杀BOSS时AI触发事件后处理
2694 @param	DWORD dwActorID		: 玩家序列号
2695 @param	bool bSendResult	: 是否要发送结果信息到社会服,false=不发送
2735 	return pBorderWar->SetCampWinResult( pPlayerNode->dwCamp+1, bSendResult);
2736 }
2739 /** 检测跨服边境战场是否开启任务
2740 @param	DWORD dwActorID		: 玩家序列号
2741 @return  bool
2793 	return (pWar->GetNumProp(dwPaleResIndex)==0);
2794 }
2796 /** 检测跨服边境战场阵营数量
2797 @param	DWORD dwActorID		: 玩家序列号
2798 @return  DWORD
2825 		return 0;
2826 	}
2827 	// 跨服边境接收外部数据结构信息
2828 	SCountryBorderWarInfo * pWarInfo = pBorderWar->GetInfo();
2829 	if (NULL == pWarInfo)
3665 	// 战争资源生成
3666 	SEventMatchWarResStone_Gather_S eventData;
3667 	eventData.dwPVPClassType	= dwPVPType;		// 跨服PVP类型 EMPVPClassType
3668 	eventData.dwWarID			= dwWarID;			// 相关战场ID
3669 	eventData.uidMaster			= uidMaster;		// 采集人
3721 	// 战争资源生成
3722 	SEventMatchWarResBrushTank_Kill_S eventData;
3723 	eventData.dwPVPClassType	= dwPVPType;		// 跨服PVP类型 EMPVPClassType
3724 	eventData.dwWarID			= dwWarID;			// 相关战场ID
3725 	eventData.uidMaster			= uidMaster;		// 采集人
4752 bool CGameMatchAPI::GetMatrixOpen(void)
4753 {
4754 	// 取得跨服组队撮合服务器
4755 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
4756 	if (pMatchServer == NULL)
4774 bool CGameMatchAPI::CheckClanCreateMatrix(DWORD dwClanID)
4775 {
4776 	// 取得跨服组队撮合服务器
4777 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
4778 	if (pMatchServer == NULL)
4796 bool CGameMatchAPI::CheckUserCreateMatrix(DWORD dwPDBID)
4797 {
4798 	// 取得跨服组队撮合服务器
4799 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
4800 	if (pMatchServer == NULL)
4818 bool CGameMatchAPI::CreateSerialMatrix(DWORD dwPDBID, DWORD dwClanID, DWORD dwSerialID)
4819 {
4820 	// 取得跨服组队撮合服务器
4821 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
4822 	if (pMatchServer == NULL)
4839 void CGameMatchAPI::DeleteSerialMatrix(DWORD dwSerialID)
4840 {
4841 	// 取得跨服组队撮合服务器
4842 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
4843 	if (pMatchServer == NULL)
4861 void CGameMatchAPI::SetUserSerialMatrix(DWORD dwPDBID, DWORD dwSerialID)
4862 {
4863 	// 取得跨服组队撮合服务器
4864 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
4865 	if (pMatchServer == NULL)
4883 DWORD CGameMatchAPI::GetUserSerialMatrix(DWORD dwPDBID)
4884 {
4885 	// 取得跨服组队撮合服务器
4886 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
4887 	if (pMatchServer == NULL)
4905 void CGameMatchAPI::ClearUserSerialMatrix(DWORD dwPDBID, DWORD dwSerialID)
4906 {
4907 	// 取得跨服组队撮合服务器
4908 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
4909 	if (pMatchServer == NULL)
4927 void CGameMatchAPI::StartMatrixChallenge(DWORD dwSerialID, int nZoneID, int nLevel, BYTE nDifficulty)
4928 {
4929 	// 取得跨服组队撮合服务器
4930 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
4931 	if (pMatchServer == NULL)
4949 void CGameMatchAPI::SetNpcBingEctypeSerialEvent(int nNpcSID, DWORD dwPDBID)
4950 {
4951 	// 取得跨服组队撮合服务器
4952 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
4953 	if (pMatchServer == NULL)
4970 void CGameMatchAPI::ClearZoneIDMatrixInfo(int nZoneID)
4971 {
4972 	// 取得跨服组队撮合服务器
4973 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
4974 	if (pMatchServer == NULL)
4992 DWORD CGameMatchAPI::GetMatrixSerialByZoneID(int nZoneID)
4993 {
4994 	// 取得跨服组队撮合服务器
4995 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
4996 	if (pMatchServer == NULL)
5014 bool CGameMatchAPI::GetMatrixDataFinish(void)
5015 {
5016 	// 取得跨服组队撮合服务器
5017 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5018 	if (pMatchServer == NULL)
5036 const SMATRIX_NPC_INFO_SCHEMEINFO *CGameMatchAPI::GetMatrixNpcInfo(BYTE nID)
5037 {
5038 	// 取得跨服组队撮合服务器
5039 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5040 	if (pMatchServer == NULL)
5058 const SMATRIX_MONSTER_INFO_SCHEMEINFO *CGameMatchAPI::GetMatrixMonsterInfo(BYTE nID, BYTE nMinorID)
5059 {
5060 	// 取得跨服组队撮合服务器
5061 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5062 	if (pMatchServer == NULL)
5084 void CGameMatchAPI::CreateMinorIndexDummyMonster(DWORD dwSerialID, BYTE nMinorIndex, BYTE nPosIndex, int nPosX, int nPosY)
5085 {
5086 	// 取得跨服组队撮合服务器
5087 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5088 	if (pMatchServer == NULL)
5105 void CGameMatchAPI::PassMinorMatrix(DWORD dwSerialID, BYTE nMinorIndex)
5106 {
5107 	// 取得跨服组队撮合服务器
5108 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5109 	if (pMatchServer == NULL)
5126 UID CGameMatchAPI::CreateMinorIndexMonsterInDummyData(DWORD dwSerialID, BYTE nMinorIndex, int nMonsterID, int nPosX, int nPosY, DWORD dwPDBID, UID BeUid)
5127 {
5128 	// 取得跨服组队撮合服务器
5129 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5130 	if (pMatchServer == NULL)
5147 int CGameMatchAPI::DeleteMinorIndexMonsterInDummyData(DWORD dwSerialID, UID BeUid)
5148 {
5149 	// 取得跨服组队撮合服务器
5150 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5151 	if (pMatchServer == NULL)
5171 const SMATRIX_CREATE_MONSTER *CGameMatchAPI::GetLastDieMonsterInfo(DWORD dwSerialID)
5172 {
5173 	// 取得跨服组队撮合服务器
5174 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5175 	if (pMatchServer == NULL)
5194 void CGameMatchAPI::ClearCurrentMinorInfo(DWORD dwSerialID)
5195 {
5196 	// 取得跨服组队撮合服务器
5197 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5198 	if (pMatchServer == NULL)
5216 BYTE CGameMatchAPI::GetMinorIndexState(DWORD dwSerialID, BYTE nMinorIndex)
5217 {
5218 	// 取得跨服组队撮合服务器
5219 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5220 	if (pMatchServer == NULL)
5238 BYTE CGameMatchAPI::GetCurrentMinorIndex(DWORD dwSerialID)
5239 {
5240 	// 取得跨服组队撮合服务器
5241 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5242 	if (pMatchServer == NULL)
5260 void CGameMatchAPI::SendMatrixInfo(DWORD dwPDBID)
5261 {
5262 	// 取得跨服组队撮合服务器
5263 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5264 	if (pMatchServer == NULL)
5282 void CGameMatchAPI::SendMinorMatrixInfo(DWORD dwPDBID, DWORD dwClanID, BYTE nMinorIndex)
5283 {
5284 	// 取得跨服组队撮合服务器
5285 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5286 	if (pMatchServer == NULL)
5304 void CGameMatchAPI::SendClanAllMemberInfo(DWORD dwPDBID, DWORD dwClanID)
5305 {
5306 	// 取得跨服组队撮合服务器
5307 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5308 	if (pMatchServer == NULL)
5326 const SMATRIX_MINOR_INFO *CGameMatchAPI::GetMatrixMinorInfo(DWORD dwSerialID, BYTE nMinorIndex)
5327 {
5328 	// 取得跨服组队撮合服务器
5329 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5330 	if (pMatchServer == NULL)
5348 void CGameMatchAPI::CreateMatrixMonster(DWORD dwSerialID, BYTE nID, BYTE nMinorID, BYTE nMinorIndex, bool bCheckBrush)
5349 {
5350 	// 取得跨服组队撮合服务器
5351 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5352 	if (pMatchServer == NULL)
5370 void CGameMatchAPI::DeleteMatrixNpc(DWORD dwSerialID, BYTE nMinorIndex)
5371 {
5372 	// 取得跨服组队撮合服务器
5373 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5374 	if (pMatchServer == NULL)
5395 int CGameMatchAPI::GetMatrixNpc(DWORD dwSerialID, BYTE nMinorIndex)
5396 {
5397 	// 取得跨服组队撮合服务器
5398 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5399 	if (pMatchServer == NULL)
5417 void CGameMatchAPI::DeleteMatrixUser(DWORD dwSerialID, DWORD dwPDBID)
5418 {
5419 	// 取得跨服组队撮合服务器
5420 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5421 	if (pMatchServer == NULL)
5439 const SMATRIX_LAYER_INFO_SCHEMEINFO *CGameMatchAPI::GetMatrixLayerInfo(BYTE nID, BYTE nMinorIndex)
5440 {
5441 	// 取得跨服组队撮合服务器
5442 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5443 	if (pMatchServer == NULL)
5466 const SMATRIX_LAYER_FACTOR_SCHEMEINFO *CGameMatchAPI::GetMatrixLayerFactor(BYTE nID, BYTE nLayer)
5467 {
5468 	// 取得跨服组队撮合服务器
5469 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5470 	if (pMatchServer == NULL)
5493 const SMINOR_POINT_INFO_SCHEMEINFO *CGameMatchAPI::GetMinorPointInfo(BYTE nID, BYTE nMinorID)
5494 {
5495 	// 取得跨服组队撮合服务器
5496 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5497 	if (pMatchServer == NULL)
5523 const SMATRIX_RANDOM_POINT_INFO_SCHEMEINFO *CGameMatchAPI::GetMatrixRandomPointInfo(BYTE nID, BYTE nRandomID)
5524 {
5525 	// 取得跨服组队撮合服务器
5526 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5527 	if (pMatchServer == NULL)
5550 const SMINOR_PRIZE_GOODS_SCHEMEINFO *CGameMatchAPI::GetMinorPrizeGoods(BYTE nID, BYTE nMinorID, BYTE nDifficulty)
5551 {
5552 	// 取得跨服组队撮合服务器
5553 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5554 	if (pMatchServer == NULL)
5578 const SMATRIX_RANDOM_PRIZE_GOODS_SCHEMEINFO *CGameMatchAPI::GetMatrixRandomPrizeGoods(BYTE nID, BYTE nRandomID, BYTE nDifficulty)
5579 {
5580 	// 取得跨服组队撮合服务器
5581 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5582 	if (pMatchServer == NULL)
5606 const SMATRIX_CLAN_PLACE *CGameMatchAPI::GetMatrixEctypeClanPlace(DWORD dwSerialID)
5607 {
5608 	// 取得跨服组队撮合服务器
5609 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5610 	if (pMatchServer == NULL)
5628 BYTE CGameMatchAPI::GetMatrixPointLayerCount(DWORD dwSerialID, BYTE nLayer)
5629 {
5630 	// 取得跨服组队撮合服务器
5631 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5632 	if (pMatchServer == NULL)
5650 void CGameMatchAPI::SetMatrixPointLayerCount(DWORD dwSerialID, BYTE nLayer)
5651 {
5652 	// 取得跨服组队撮合服务器
5653 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5654 	if (pMatchServer == NULL)
5672 const SMATRIX_CLAN_FACTOR_SCHEMEINFO *CGameMatchAPI::GetMatrixClanFactor(BYTE nID, BYTE nPlace)
5673 {
5674 	// 取得跨服组队撮合服务器
5675 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5676 	if (pMatchServer == NULL)
5699 const SMATRIX_CLAN_PLACE *CGameMatchAPI::GetMatrixClanPlace(DWORD dwClanID)
5700 {
5701 	// 取得跨服组队撮合服务器
5702 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5703 	if (pMatchServer == NULL)
5723 void CGameMatchAPI::SetOpenMatrixKeyNum(DWORD dwSerialID, int nOpenMatrixKeyNum)
5724 {
5725 	// 取得跨服组队撮合服务器
5726 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5727 	if (pMatchServer == NULL)
5745 int CGameMatchAPI::GetOpenMatrixKeyNum(DWORD dwSerialID)
5746 {
5747 	// 取得跨服组队撮合服务器
5748 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5749 	if (pMatchServer == NULL)
5767 void CGameMatchAPI::SetMatrixRandomID(DWORD dwSerialID, BYTE nMinorIndex, BYTE nChooseRandomID)
5768 {
5769 	// 取得跨服组队撮合服务器
5770 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5771 	if (pMatchServer == NULL)
5789 BYTE CGameMatchAPI::GetMatrixRandomID(DWORD dwSerialID, BYTE nMinorIndex)
5790 {
5791 	// 取得跨服组队撮合服务器
5792 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5793 	if (pMatchServer == NULL)
5811 void CGameMatchAPI::SendPassMatrix(DWORD dwSerialID, DWORD dwCaptainPDBID)
5812 {
5813 	// 取得跨服组队撮合服务器
5814 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5815 	if (pMatchServer == NULL)
5833 bool CGameMatchAPI::GetPassBoss(DWORD dwSerialID)
5834 {
5835 	// 取得跨服组队撮合服务器
5836 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5837 	if (pMatchServer == NULL)
5855 const SMATRIX_RANKLIST *CGameMatchAPI::GetMatrixRankList(BYTE nCountryID)
5856 {
5857 	// 取得跨服组队撮合服务器
5858 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5859 	if (pMatchServer == NULL)
5877 void CGameMatchAPI::SendMatrixRankList(DWORD dwPDBID)
5878 {
5879 	// 取得跨服组队撮合服务器
5880 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5881 	if (pMatchServer == NULL)
5899 BYTE CGameMatchAPI::SetMatrixFailCloseDoor(DWORD dwSerialID, BYTE nMinorIndex)
5900 {
5901 	// 取得跨服组队撮合服务器
5902 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5903 	if (pMatchServer == NULL)
5921 bool CGameMatchAPI::GetPassMinorMatrix(DWORD dwSerialID, BYTE nMinorIndex)
5922 {
5923 	// 取得跨服组队撮合服务器
5924 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5925 	if (pMatchServer == NULL)
5943 int CGameMatchAPI::GetMatrixPassInfoCount(void)
5944 {
5945 	// 取得跨服组队撮合服务器
5946 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5947 	if (pMatchServer == NULL)
5965 const SMATRIX_PASS_INFO *CGameMatchAPI::GetMatrixPassInfo(int nIndex)
5966 {
5967 	// 取得跨服组队撮合服务器
5968 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5969 	if (pMatchServer == NULL)
5987 BYTE CGameMatchAPI::GetMatrixBoxIndex(DWORD dwSerialID)
5988 {
5989 	// 取得跨服组队撮合服务器
5990 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
5991 	if (pMatchServer == NULL)
6009 BYTE CGameMatchAPI::GetMatrixID(DWORD dwSerialID)
6010 {
6011 	// 取得跨服组队撮合服务器
6012 	IMatchServer *pMatchServer = gZoneServiceProvider->GetMatchServer();
6013 	if (pMatchServer == NULL)

I:\work\source\罗德岛战记\[src.cool]罗德岛战记\Game\Src\CnsRunner\CCnsConnectionMgr.cpp 42 KB CPP 文件 2014/2/26 19:09:34 2018/10/22 15:51:04 2018/10/22 15:51:04 4
164 bool CCnsConnectionMgr::EnumAcceptorExCallBack(CAcceptorEx* pAcceptorEx, void* pContext)
165 {
166 	//在跨服中就不收原来服务器的消息了
167 	/*if(CallLuaFunction<bool>(GetLuaScriptWrapperSingleton().GetLuaState(), "CnsCrossServerMgr", "IsCrossServer", "I", pAcceptorEx->GetId()))
168 		return false;*/
178 bool CCnsConnectionMgr::EnumAcceptorExCallBackGwc(CAcceptorEx* pAcceptorEx, void* pContext)
179 {
180 	//在跨服中只接收跨服服务器的消息了
181 	/*if(!CallLuaFunction<bool>(GetLuaScriptWrapperSingleton().GetLuaState(), "CnsCrossServerMgr", "IsCrossServer", "I", pAcceptorEx->GetId()))
182 		return false;*/
1281 }
1283 /************************************************************************/
1284 /* 跨服                                                                 */
1285 /************************************************************************/
1286 void SetIgnoreGasMsg(uint32 uId, bool bIngore)

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\MiscService\CastleService.cpp 158 KB CPP 文件 2014/2/25 0:23:25 2018/10/23 20:09:05 2018/10/23 20:09:05 2
3494 		return nodeData;
3495 	}
3497 	// 新城战不开放跨服领地BOSS战
3498 	if (gGlobalSocialServer->IsNewCastleOpen())
3499 	{
3654 		return;
3655 	}
3657 	// 新城战不开放跨服领地BOSS战
3658 	if (gGlobalSocialServer->IsNewCastleOpen())
3659 	{

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\MiscService\CastleService.cpp 158 KB CPP 文件 2014/2/25 14:31:49 2018/10/23 19:46:44 2018/10/23 19:46:44 2
3494 		return nodeData;
3495 	}
3497 	// 新城战不开放跨服领地BOSS战
3498 	if (gGlobalSocialServer->IsNewCastleOpen())
3499 	{
3654 		return;
3655 	}
3657 	// 新城战不开放跨服领地BOSS战
3658 	if (gGlobalSocialServer->IsNewCastleOpen())
3659 	{

I:\work\source\神魔传奇\[src.cool]神魔传奇代码\Server\ScenesServer\CartoonPet.cpp 10 KB CPP 文件 2012/1/17 23:01:19 2018/10/23 13:18:01 2018/10/23 13:18:01 1
401 }
403 /*
404  * \brief 主人跨服时,保存其收养的宝宝的临时数据
405  * 
406  * \param dest 保存地址

I:\work\source\征途\征途-2\zhengtu\src\libscenesserver\CartoonPet.cpp 10 KB CPP 文件 2009/2/26 11:33:10 2018/10/23 19:34:23 2018/10/23 19:34:23 1
385 }
387 /*
388  * \brief 主人跨服时,保存其收养的宝宝的临时数据
389  * 
390  * \param dest 保存地址

I:\work\source\征途\征途-1\zhengtu\征途\server\src\ScenesServer\CartoonPet.cpp 9 KB CPP 文件 2006/5/11 8:57:30 2018/10/23 19:35:34 2018/10/23 19:35:34 1
390 }
392 /*
393  * \brief 主人跨服时，保存其收养的宝宝的临时数据
394  * 
395  * \param dest 保存地址

I:\work\source\书剑恩仇录\书剑恩仇录_zccode.com\书剑恩仇录\金\Src\MapServer\Server\Object\Bus.cpp 60 KB CPP 文件 2013/3/3 14:00:10 2018/10/23 13:34:42 2018/10/23 13:34:42 3
798 	CaculateMonsterExpRuler::eEXP_CALC_TYPE eCalcType 
799 		= CaculateMonsterExpRuler::eCALC_TYPE_TEAM;
801 	//如果是跨服副本
802 	if (pMap->GetMapType() == MAP_TYPE_FUBEN && pMap->m_FubenDataParty.IsRoomType())
803 	{
803 	{
804 		nValidMemberCount = GetValidOwnerListGroup(MAX_GROUP_MEMBER,apValidMember);
806 		eCalcType = CaculateMonsterExpRuler::eCALC_TYPE_GROUP; //按跨服军团分配
807 	}
808 	else
1083 		iFadeoutType = Obj_ItemRuler::FADE_OUT_TEAM;
1084 	}
1086 	//是否是跨服
1087 	BOOL BGroup = FALSE;
1088 	Map* pMap = GetMap();

I:\work\source\书剑恩仇录\[src.cool]书剑恩仇录\Src\MapServer\Server\Object\Bus.cpp 60 KB CPP 文件 2013/3/3 14:00:10 2018/10/23 13:34:25 2018/10/23 13:34:25 3
798 	CaculateMonsterExpRuler::eEXP_CALC_TYPE eCalcType 
799 		= CaculateMonsterExpRuler::eCALC_TYPE_TEAM;
801 	//如果是跨服副本
802 	if (pMap->GetMapType() == MAP_TYPE_FUBEN && pMap->m_FubenDataParty.IsRoomType())
803 	{
803 	{
804 		nValidMemberCount = GetValidOwnerListGroup(MAX_GROUP_MEMBER,apValidMember);
806 		eCalcType = CaculateMonsterExpRuler::eCALC_TYPE_GROUP; //按跨服军团分配
807 	}
808 	else
1083 		iFadeoutType = Obj_ItemRuler::FADE_OUT_TEAM;
1084 	}
1086 	//是否是跨服
1087 	BOOL BGroup = FALSE;
1088 	Map* pMap = GetMap();

I:\work\source\仙剑神曲\[src.cool]仙剑神曲\src\server\gamesvr\buff\BuffManager.cpp 12 KB CPP 文件 2012/4/22 2:05:32 2018/10/23 16:10:53 2018/10/23 16:10:53 1
459     else
460     {
461         // 角色跨服，有双倍时间BUFF，则设置双倍时间状态
462         if (pPlayer->HasPersistObjectState(CFLAG_DOUBLEEXPTIME))
463         {

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\SceneServer\MatchServer\BudoServer.cpp 52 KB CPP 文件 2014/2/25 0:08:37 2018/10/23 20:06:21 2018/10/23 20:06:21 2
1165 	// 调式代码
1166 	char szBuf[512]={0};
1167 	sprintf_s(szBuf,sizeof(szBuf), "CStrikeServer::HandleBridgeMessage()  跨服武道会系统服务器撮合信息子消息:来源游戏世界ID=%d,来源服务器ID=%d,子消息代码=%d,len=%d,用户数据=%d,%d,%d",
1168 		bridgeHead.dwWorldID,bridgeHead.dwServerID,pMsg->dwMsgCode,len,pMsg->dwUserData1,pMsg->dwUserData2,pMsg->dwUserData3);
1169 	TraceLn(szBuf);
1178 	default:
1179 		{
1180 			ErrorLn("武道会系统系统有一个跨服撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
1181 		}
1182 		break;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\SceneServer\MatchServer\BudoServer.cpp 52 KB CPP 文件 2014/2/25 14:26:56 2018/10/23 19:45:08 2018/10/23 19:45:08 2
1165 	// 调式代码
1166 	char szBuf[512]={0};
1167 	sprintf_s(szBuf,sizeof(szBuf), "CStrikeServer::HandleBridgeMessage()  跨服武道会系统服务器撮合信息子消息:来源游戏世界ID=%d,来源服务器ID=%d,子消息代码=%d,len=%d,用户数据=%d,%d,%d",
1168 		bridgeHead.dwWorldID,bridgeHead.dwServerID,pMsg->dwMsgCode,len,pMsg->dwUserData1,pMsg->dwUserData2,pMsg->dwUserData3);
1169 	TraceLn(szBuf);
1178 	default:
1179 		{
1180 			ErrorLn("武道会系统系统有一个跨服撮合信息子消息未处理，dwMsgCode = "<< pMsg->dwMsgCode);
1181 		}
1182 		break;

I:\work\source\书剑恩仇录\书剑恩仇录_zccode.com\书剑恩仇录\金\Src\Share\Core\BaseTool_Log.cpp 26 KB CPP 文件 2013/3/3 12:49:18 2018/10/23 13:35:56 2018/10/23 13:35:56 1
382 			if (g_Config.m_MultiGroupConfig.m_nGroupCount >  0)
383 			{
384 				iWorldID = INVALID_ID;//跨服上WorldID无效
385 			}
387 			int iMapID	 = g_Config.m_ConfigInfo.m_ServerID;

I:\work\source\书剑恩仇录\[src.cool]书剑恩仇录\Src\Share\Core\BaseTool_Log.cpp 26 KB CPP 文件 2013/3/3 12:49:18 2018/10/23 13:35:01 2018/10/23 13:35:01 1
382 			if (g_Config.m_MultiGroupConfig.m_nGroupCount >  0)
383 			{
384 				iWorldID = INVALID_ID;//跨服上WorldID无效
385 			}
387 			int iMapID	 = g_Config.m_ConfigInfo.m_ServerID;

I:\work\source\远征\[src.cool]远征\Xgame2001_source\SrcServer\Social\CountryService\BasePart.cpp 133 KB CPP 文件 2014/2/25 0:21:18 2018/10/23 20:08:52 2018/10/23 20:08:52 7
2009 	// 社会服务器请求广播数据到场景服部件
2010 	BroadcastData();
2012 	// 刷新跨服共享国家信息
2013 	UpdateWorldCountryInfo();
2014 }
2521 	// 社会服务器请求广播数据到场景服部件
2522 	BroadcastData();
2524 	// 刷新跨服共享国家信息
2525 	UpdateWorldCountryInfo();
2527 }
3310 		BroadcastData();
3311 	}
3313 	// 刷新跨服共享国家信息
3314 	UpdateWorldCountryInfo();
3316 #ifdef COUNTRY_PRINT_DEBUG_INF
3467 	// 社会服务器请求广播数据到场景服部件
3468 	BroadcastData();
3470 	// 刷新跨服共享国家信息
3471 	UpdateWorldCountryInfo();
3473 #ifdef COUNTRY_PRINT_DEBUG_INF
3478 #endif
3480 }
3482 /** 刷新跨服共享国家信息
3483 @param 
3484 */
3488 	if (!IsValid())
3489 	{
3490 		//ErrorLn("CBasePart::UpdateWorldCountryInfo() 由于当前国家不合法不能刷新跨服共享国家信息,国家ID="<< m_CountryBaseInfo.dwID);
3491 		return;
3492 	}
3726 	// 社会服务器请求广播数据到场景服部件
3727 	BroadcastData();
3729 	// 刷新跨服共享国家信息
3730 	UpdateWorldCountryInfo();
3731 	return ;

I:\work\source\远征\[src.cool]远征\Xgame2001_build\SrcServer\Social\CountryService\BasePart.cpp 133 KB CPP 文件 2014/2/25 14:30:49 2018/10/23 19:46:33 2018/10/23 19:46:33 7
2009 	// 社会服务器请求广播数据到场景服部件
2010 	BroadcastData();
2012 	// 刷新跨服共享国家信息
2013 	UpdateWorldCountryInfo();
2014 }
2521 	// 社会服务器请求广播数据到场景服部件
2522 	BroadcastData();
2524 	// 刷新跨服共享国家信息
2525 	UpdateWorldCountryInfo();
2527 }
3310 		BroadcastData();
3311 	}
3313 	// 刷新跨服共享国家信息
3314 	UpdateWorldCountryInfo();
3316 #ifdef COUNTRY_PRINT_DEBUG_INF
3467 	// 社会服务器请求广播数据到场景服部件
3468 	BroadcastData();
3470 	// 刷新跨服共享国家信息
3471 	UpdateWorldCountryInfo();
3473 #ifdef COUNTRY_PRINT_DEBUG_INF
3478 #endif
3480 }
3482 /** 刷新跨服共享国家信息
3483 @param 
3484 */
3488 	if (!IsValid())
3489 	{
3490 		//ErrorLn("CBasePart::UpdateWorldCountryInfo() 由于当前国家不合法不能刷新跨服共享国家信息,国家ID="<< m_CountryBaseInfo.dwID);
3491 		return;
3492 	}
3726 	// 社会服务器请求广播数据到场景服部件
3727 	BroadcastData();
3729 	// 刷新跨服共享国家信息
3730 	UpdateWorldCountryInfo();
3731 	return ;

I:\work\source\龙腾世界\[src.cool]龙腾世界\Code\Code\GraphNetServer\ApexProxyEx.cpp 7 KB CPP 文件 2007/1/12 16:57:52 2018/10/22 15:45:40 2018/10/22 15:45:40 1
95 	WORD wType = 1;
96 	//if ( bIsFormOtherServer )
97 	//{// 跨服务器就发重起
98 	//	wType = 3;
99 	//}

I:\work\source\蜀山神话\[src.cool]蜀山神话\src\server\tracksvr\ActivityManager.cpp 45 KB CPP 文件 2012/4/21 1:05:04 2018/10/23 13:25:20 2018/10/23 13:25:20 2
143 	/// 发布宗派活动处理
144 	void		HandleMakeGuildAct(FiMessage* pMsg);
145 	/// 玩家跨服跳地图需同步活动信息
146 	void		SyncActivityInfo(FiMessage* pMsg);
147     // 判断有无新活动因为玩家的升级而激活
1423         // 同步所有活动的状态
1424         SyncAllActivityState(pPlayer);
1426 		//角色跨服
1427 		if (pPlayer->GetPendingActId() > 0)
1428 		{

I:\work\source\仙剑神曲\[src.cool]仙剑神曲\src\server\tracksvr\ActivityManager.cpp 22 KB CPP 文件 2012/4/22 2:05:30 2018/10/23 16:12:02 2018/10/23 16:12:02 2
159     /// 退出活动
160     void        HandleQuitActivity(FiMessage* msg);
162 	/// 玩家跨服跳地图需同步活动信息
163 	void		SyncActivityInfo(FiMessage* pMsg);
165 	/// 维护更新今天之内可能发生的任务
767 	}
768     
769     //角色跨服
770 	if (false == pPlayer->IsFirstEnter())
771 	{		

